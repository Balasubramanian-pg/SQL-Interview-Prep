---
Functions: Scenario Based Problems
---
This query demonstrates how to calculate rolling (moving) aggregates like sums, averages, minimums, and maximums using window functions.

## The Query Structure

```SQL
WITH year_month_sales AS (
    SELECT
        DATEPART(year, order_date) AS year_order,
        DATEPART(month, order_date) AS month_order,
        SUM(sales) AS sales
    FROM cust_orders
    GROUP BY DATEPART(year, order_date), DATEPART(month, order_date)
)
SELECT
    *,
    SUM(sales) OVER(ORDER BY year_order ASC, month_order ASC
                  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_sum,
    AVG(sales) OVER(ORDER BY year_order ASC, month_order ASC
                  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_avg,
    MIN(sales) OVER(ORDER BY year_order ASC, month_order ASC
                  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_min,
    MAX(sales) OVER(ORDER BY year_order ASC, month_order ASC
                  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_max
FROM year_month_sales
```

## Key Components Explained

### 1. Common Table Expression (CTE)

```SQL
WITH year_month_sales AS (
    SELECT
        DATEPART(year, order_date) AS year_order,
        DATEPART(month, order_date) AS month_order,
        SUM(sales) AS sales
    FROM cust_orders
    GROUP BY DATEPART(year, order_date), DATEPART(month, order_date)
)
```

- Aggregates sales data by year and month
- Uses `DATEPART()` to extract year and month components
- Creates a temporary result set named `year_month_sales`

### 2. Window Frame Specification

```SQL
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
```

This defines a 3-row window for calculations:

- Current row
- 1 row before it (PRECEDING)
- 1 row after it (FOLLOWING)

### 3. Rolling Aggregates

1. **Rolling Sum**:
    
    ```SQL
    SUM(sales) OVER(...) AS rolling_sum
    ```
    
    - Calculates sum of current row + previous row + next row
2. **Rolling Average**:
    
    ```SQL
    AVG(sales) OVER(...) AS rolling_avg
    ```
    
    - Calculates average of the 3-row window
3. **Rolling Minimum**:
    
    ```SQL
    MIN(sales) OVER(...) AS rolling_min
    ```
    
    - Finds the minimum value in the 3-row window
4. **Rolling Maximum**:
    
    ```SQL
    MAX(sales) OVER(...) AS rolling_max
    ```
    
    - Finds the maximum value in the 3-row window

## Edge Cases

For the first and last rows in the result set:

- First row won't have a "preceding" row
- Last row won't have a "following" row
- The window functions automatically adjust to only include available rows

## Alternative Window Frames

1. **Trailing 3 months**:
    
    ```SQL
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ```
    
2. **Centered average**:
    
    ```SQL
    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ```
    
    (as shown in the original query)
    
3. **Cumulative sum**:
    
    ```SQL
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ```
    

## Practical Applications

- Calculating moving averages for trend analysis
- Identifying patterns in seasonal data
- Smoothing out fluctuations in time-series data
- Comparing current performance with recent history

This technique is particularly valuable for financial analysis, inventory management, and sales performance tracking where understanding trends over time is crucial.