This query analyzes office visitor data to determine:

1. Each visitor's most frequently visited floor
2. Their total number of visits
3. All resources they used

## Table Structure

```SQL
CREATE TABLE entries (
    name varchar(20),
    address varchar(20),
    email varchar(20),
    floor int,
    resources varchar(10)
);
```

## Query Breakdown

### 1. Distinct Resources CTE

```SQL
WITH Distinct_resources AS (
    SELECT name, resources FROM entries
)
```

- Gets unique name-resource combinations
- Eliminates duplicate resource entries per person

### 2. Aggregated Resources CTE

```SQL
,agg_resources AS (
    SELECT name, STRING_AGG(resources,',') AS used_resouces
    FROM distinct_resources
    GROUP BY name
)
```

- Concatenates all distinct resources used by each person
- Example output: "CPU,DESKTOP,MONITOR"

### 3. Total Visits CTE

```SQL
,total_visits AS (
    SELECT
        name,
        COUNT(1) AS total_visits,
        STRING_AGG(resources,',') AS resources_used
    FROM entries
    GROUP BY name
)
```

- Counts all visits per person
- Note: This includes duplicate resources in the string_agg

### 4. Floor Visits CTE

```SQL
,floor_visit AS (
    SELECT
        name,
        floor,
        COUNT(1) AS no_of_floor_visits,
        RANK() OVER(PARTITION BY name ORDER BY COUNT(1) DESC) AS rn
    FROM entries
    GROUP BY name, floor
)
```

- Counts visits per floor per person
- Ranks floors by visit frequency (1 = most visited)

### 5. Final Result

```SQL
SELECT
    fv.name,
    fv.floor AS most_visited_floor,
    tv.total_visits,
    ar.used_resouces
FROM floor_visit AS fv
INNER JOIN total_visits AS tv ON fv.name = tv.name
INNER JOIN agg_resources AS ar ON fv.name = ar.name
WHERE rn = 1;
```

- Joins all CTEs to produce final output
- Filters for only the most visited floor (rn = 1)

## Optimization Recommendations

1. **Consistent Resource Aggregation**:
    - The query calculates resources twice (in agg_resources and total_visits)
    - Recommend using only `agg_resources` since it handles duplicates
2. **Simplified Query**:

```SQL
WITH floor_visit AS (
    SELECT
        name,
        floor,
        COUNT(1) AS visits,
        RANK() OVER(PARTITION BY name ORDER BY COUNT(1) DESC) AS floor_rank
    FROM entries
    GROUP BY name, floor
),
visitor_stats AS (
    SELECT
        name,
        COUNT(1) AS total_visits,
        STRING_AGG(DISTINCT resources, ',') AS resources_used
    FROM entries
    GROUP BY name
)
SELECT
    fv.name,
    fv.floor AS most_visited_floor,
    vs.total_visits,
    vs.resources_used
FROM floor_visit fv
JOIN visitor_stats vs ON fv.name = vs.name
WHERE fv.floor_rank = 1;
```

1. **Handle Ties**:
    - Current query arbitrarily selects one floor if there's a tie
    - Consider adding tie-breaker logic if business needs dictate

## Expected Output

For the sample data, the output would be:

```Plain
name | most_visited_floor | total_visits | used_resouces
-----+--------------------+--------------+--------------
A    | 1                  | 3            | CPU,DESKTOP
B    | 2                  | 3            | DESKTOP,MONITOR
```