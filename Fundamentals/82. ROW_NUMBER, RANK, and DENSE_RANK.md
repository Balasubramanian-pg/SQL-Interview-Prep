## Key Differences Between Ranking Functions

|Function|Behavior with Ties|Sequence After Ties|Example Output (for values 10,20,20,30)|
|---|---|---|---|
|ROW_NUMBER()|Assigns unique numbers|Continues incrementing|1,2,3,4|
|RANK()|Same rank for ties, skips next numbers|Leaves gaps|1,2,2,4|
|DENSE_RANK()|Same rank for ties, no gaps|Continues sequentially|1,2,2,3|

## Example Query Demonstrating All Three

```SQL
SELECT
    EmployeeID,
    Name,
    DeptID,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DeptID ORDER BY Salary) AS RowNumber,
    RANK() OVER (PARTITION BY DeptID ORDER BY Salary) AS Rank,
    DENSE_RANK() OVER (PARTITION BY DeptID ORDER BY Salary) AS DenseRank
FROM Employees;
```

## Sample Output (Department 2)

```Plain
EmployeeID | Name     | DeptID | Salary | RowNumber | Rank | DenseRank
-----------+----------+--------+--------+-----------+------+----------
9          | Martin   | 2      | 35000  | 1         | 1    | 1
5          | Jack     | 2      | 45000  | 2         | 2    | 2
2          | Adam     | 2      | 50000  | 3         | 3    | 3
4          | Robert   | 2      | 50000  | 4         | 3    | 3
7          | Jennifer | 2      | 55000  | 5         | 5    | 4
8          | Lisa     | 2      | 85000  | 6         | 6    | 5
```

## Tie-Breaking Scenario

When you need to break ties (e.g., same salary), add additional columns to ORDER BY:

```SQL
SELECT
    EmployeeID,
    Name,
    DeptID,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DeptID ORDER BY Salary, EmployeeID) AS RowNumber,
    RANK() OVER (PARTITION BY DeptID ORDER BY Salary, EmployeeID) AS Rank,
    DENSE_RANK() OVER (PARTITION BY DeptID ORDER BY Salary, EmployeeID) AS DenseRank
FROM Employees;
```

## Practical Use Cases

1. **ROW_NUMBER()**:
    - When you need unique identifiers for pagination
    - When you want to select top N records per group
2. **RANK()**:
    - For competition rankings where you want to show position gaps
    - When you need to know "this is the 5th highest" including ties
3. **DENSE_RANK()**:
    - For tiered classifications without gaps
    - When you need sequential numbering regardless of ties

## Performance Considerations

All three functions have similar performance characteristics since they:

- Process data in a single pass
- Require sorting by the PARTITION BY and ORDER BY columns
- Benefit from indexes on those columns for large datasets