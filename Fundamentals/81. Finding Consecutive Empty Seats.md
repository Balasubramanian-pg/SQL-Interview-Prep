## Problem Analysis

We need to identify 3 or more consecutive empty seats ('Y') in a movie theater seating arrangement.

## Method 1: Using LEAD/LAG Functions

```SQL
SELECT * FROM (
    SELECT *,
        LAG(is_empty, 1) OVER(ORDER BY seat_no) AS prev_1,
        LAG(is_empty, 2) OVER(ORDER BY seat_no) AS prev_2,
        LEAD(is_empty, 1) OVER(ORDER BY seat_no) AS next_1,
        LEAD(is_empty, 2) OVER(ORDER BY seat_no) AS next_2
    FROM BMS
) A
WHERE (is_empty = 'Y' AND prev_1 = 'Y' AND prev_2 = 'Y')  -- Current is 3rd in sequence
   OR (is_empty = 'Y' AND prev_1 = 'Y' AND next_1 = 'Y')  -- Current is middle of sequence
   OR (is_empty = 'Y' AND next_1 = 'Y' AND next_2 = 'Y'); -- Current is 1st in sequence
```

**Pros**: Easy to understand logic for consecutive values

**Cons**: Doesn't show full sequence, just individual seats in sequences

## Method 2: Using Window Aggregation

```SQL
SELECT * FROM (
    SELECT *,
        SUM(CASE WHEN is_empty='Y' THEN 1 ELSE 0 END)
            OVER(ORDER BY seat_no ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS prev_2,
        SUM(CASE WHEN is_empty='Y' THEN 1 ELSE 0 END)
            OVER(ORDER BY seat_no ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS prev_next_1,
        SUM(CASE WHEN is_empty='Y' THEN 1 ELSE 0 END)
            OVER(ORDER BY seat_no ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS next_2
    FROM BMS
) a
WHERE prev_2=3 OR prev_next_1=3 OR next_2=3;
```

**Pros**: More concise than LEAD/LAG approach

**Cons**: Still identifies individual seats rather than ranges

## Method 3: Using ROW_NUMBER (Gaps and Islands)

```SQL
WITH diff_num AS (
    SELECT *,
        ROW_NUMBER() OVER(ORDER BY seat_no) AS rn,
        seat_no - ROW_NUMBER() OVER(ORDER BY seat_no) AS diff
    FROM bms
    WHERE is_empty='Y'
),
cnt AS (
    SELECT diff, COUNT(1) AS c
    FROM diff_num
    GROUP BY diff
    HAVING COUNT(1)>=3
)
SELECT * FROM diff_num
WHERE diff IN (SELECT diff FROM cnt)
ORDER BY seat_no;
```

**Pros**:

- Identifies complete sequences (islands) of consecutive seats
- Easily extendable to find sequences of any length
- Most elegant solution for this problem

**Cons**:

- Slightly more complex to understand initially
- Requires two CTEs

## Best Practice Recommendation

**Method 3 (Gaps and Islands)** is generally the best approach because:

1. It clearly identifies all seats in each consecutive sequence
2. It can be easily modified for different sequence lengths
3. It provides the complete range of seats rather than just indicators
4. It's more performant for large datasets

## Example Output

For the given data, the output would show seats 4-6, 8-11, and 13-14 as consecutive empty seat sequences.

## Alternative Solution (Showing Ranges)

```SQL
WITH sequences AS (
    SELECT
        MIN(seat_no) AS start_seat,
        MAX(seat_no) AS end_seat,
        COUNT(*) AS seat_count
    FROM (
        SELECT *,
            seat_no - ROW_NUMBER() OVER(ORDER BY seat_no) AS grp
        FROM bms
        WHERE is_empty = 'Y'
    ) t
    GROUP BY grp
    HAVING COUNT(*) >= 3
)
SELECT * FROM sequences;
```

This alternative shows the actual ranges of consecutive seats rather than individual seat numbers.