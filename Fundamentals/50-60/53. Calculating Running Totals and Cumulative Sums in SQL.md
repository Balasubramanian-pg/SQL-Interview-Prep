Here's how to properly calculate running totals and cumulative sums in SQL:

## Basic Running Total

```SQL
SELECT
    emp_id,
    emp_name,
    salary,
    SUM(salary) OVER(ORDER BY emp_id) AS running_total
FROM empm
ORDER BY emp_id;
```

## Key Considerations for Running Totals

1. **Ordering Column**:
    - Should be unique to ensure consistent results
    - If ordering by non-unique columns, add a tiebreaker

```SQL
-- With tiebreaker for non-unique ordering
SELECT
    emp_id,
    emp_name,
    salary,
    SUM(salary) OVER(ORDER BY salary, emp_id) AS running_total
FROM empm
ORDER BY salary, emp_id;
```

## Partitioned Running Totals (By Department)

```SQL
SELECT
    emp_id,
    emp_name,
    department_id,
    salary,
    SUM(salary) OVER(PARTITION BY department_id ORDER BY emp_id) AS dept_running_total,
    SUM(salary) OVER() AS grand_total
FROM empm
ORDER BY department_id, emp_id;
```

## Advanced Cumulative Calculations

```SQL
SELECT
    emp_id,
    emp_name,
    salary,
    -- Running total
    SUM(salary) OVER(ORDER BY emp_id ROWS UNBOUNDED PRECEDING) AS running_total,

    -- Moving average (last 3 rows)
    AVG(salary) OVER(ORDER BY emp_id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg,

    -- Cumulative percentage
    ROUND(salary * 100.0 / SUM(salary) OVER(), 2) AS pct_of_total,

    -- Rank within department
    RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) AS dept_salary_rank
FROM empm
ORDER BY emp_id;
```

## Handling Edge Cases

```SQL
-- With frame specification for precise control
SELECT
    emp_id,
    emp_name,
    salary,
    SUM(salary) OVER(ORDER BY emp_id
                     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,

    -- Alternate approach that's more explicit
    SUM(salary) OVER(ORDER BY emp_id
                     RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total_range
FROM empm
ORDER BY emp_id;
```

## Performance Considerations

1. For large datasets, ensure proper indexing on the ORDER BY column
2. Window functions perform better than self-joins for running totals
3. Use ROWS instead of RANGE for better performance (when appropriate)

These examples demonstrate how to calculate various cumulative aggregates while avoiding common pitfalls with duplicate values in the ordering column.
