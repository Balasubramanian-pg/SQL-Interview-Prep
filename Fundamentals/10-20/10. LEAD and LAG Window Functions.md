LEAD and LAG are powerful window functions that allow you to access data from other rows in your result set without using self-joins. Here's a detailed explanation with your examples:

## Basic Syntax

```SQL
LAG(column_name, offset, default_value) OVER (PARTITION BY partition_expression ORDER BY sort_expression)
LEAD(column_name, offset, default_value) OVER (PARTITION BY partition_expression ORDER BY sort_expression)
```

## Your Examples Explained

### 1. Basic Yearly Sales Analysis

```SQL
WITH year_sales AS (
    SELECT
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY DATEPART(year, order_date)
)
SELECT * FROM year_sales ORDER BY order_year;
```

### 2. Using LAG to Compare with Previous Year

```SQL
WITH year_sales AS (
    SELECT
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY DATEPART(year, order_date)
)
SELECT
    *,
    LAG(sales, 1, 0) OVER(ORDER BY order_year) AS previous_year_sales,
    sales - LAG(sales, 1, 0) OVER(ORDER BY order_year) AS year_over_year_growth
FROM year_sales
ORDER BY order_year;
```

### 3. Using LEAD to See Next Year's Data

```SQL
WITH year_sales AS (
    SELECT
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY DATEPART(year, order_date)
)
SELECT
    *,
    LEAD(sales, 1, 0) OVER(ORDER BY order_year) AS next_year_sales
FROM year_sales
ORDER BY order_year;
```

### 4. Reverse Order with LEAD (to simulate LAG)

```SQL
WITH year_sales AS (
    SELECT
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY DATEPART(year, order_date)
)
SELECT
    *,
    LEAD(sales, 1, 0) OVER(ORDER BY order_year DESC) AS previous_year_sales
FROM year_sales
ORDER BY order_year DESC;
```

### 5. Partitioned by Region

```SQL
WITH year_sales AS (
    SELECT
        region,
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY region, DATEPART(year, order_date)
)
SELECT
    *,
    LAG(sales, 1, 0) OVER(PARTITION BY region ORDER BY order_year) AS prev_year_sales
FROM year_sales
ORDER BY region, order_year;
```

### 6. Looking Back 2 Years by Region

```SQL
WITH year_sales AS (
    SELECT
        region,
        DATEPART(year, order_date) AS order_year,
        SUM(sales) AS sales
    FROM superstore_orders
    GROUP BY region, DATEPART(year, order_date)
)
SELECT
    *,
    LAG(sales, 2, 0) OVER(PARTITION BY region ORDER BY order_year) AS sales_two_years_ago
FROM year_sales
ORDER BY region, order_year;
```

## Key Concepts

1. **LAG()** - Accesses data from a previous row in the same result set
    - Parameters: (column, offset, default_value)
    - Example: `LAG(sales, 1, 0)` gets the previous row's sales value
2. **LEAD()** - Accesses data from a subsequent row in the same result set
    - Same parameters as LAG
    - Example: `LEAD(sales, 1, 0)` gets the next row's sales value
3. **PARTITION BY** - Divides the result set into partitions to which the function is applied
    - Example: Calculate year-over-year changes within each region separately
4. **ORDER BY** - Determines the logical order of rows within each partition

## Practical Applications

1. **Year-over-Year Comparison**:
    
    ```SQL
    WITH yearly_data AS (...)
    SELECT
        year,
        sales,
        LAG(sales, 1) OVER(ORDER BY year) AS prev_year,
        (sales - LAG(sales, 1) OVER(ORDER BY year)) / LAG(sales, 1) OVER(ORDER BY year) * 100 AS yoy_growth_pct
    FROM yearly_data
    ```
    
2. **Moving Averages**:
    
    ```SQL
    SELECT
        date,
        sales,
        AVG(sales) OVER(ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg
    FROM daily_sales
    ```
    
3. **Identifying Trends**:
    
    ```SQL
    SELECT
        product,
        month,
        sales,
        sales - LAG(sales, 1) OVER(PARTITION BY product ORDER BY month) AS monthly_change
    FROM product_sales
    ```
    

These window functions are essential for time-series analysis and comparing values across rows in your data.
