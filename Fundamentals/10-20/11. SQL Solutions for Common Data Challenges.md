Here's a comprehensive guide to solving various SQL problems, including your examples and additional insights:

## 1. Deleting Duplicates from a Table

```SQL
-- Using RANK() to identify and delete duplicates
WITH emp_table AS (
    SELECT *,
    RANK() OVER(PARTITION BY firstname, lastname ORDER BY employee_id DESC) AS rnk
    FROM empm
)
DELETE FROM emp_table WHERE rnk > 1;
```

**Alternative approach using ROW_NUMBER()**:

```SQL
WITH duplicates AS (
    SELECT *,
    ROW_NUMBER() OVER(PARTITION BY firstname, lastname ORDER BY employee_id) AS row_num
    FROM empm
)
DELETE FROM duplicates WHERE row_num > 1;
```

## 2. Finding the Nth Highest Salary

### Second highest salary:

```SQL
-- Method 1: Using subquery
SELECT MAX(salary) FROM emp
WHERE salary < (SELECT MAX(salary) FROM emp);

-- Method 2: Using TOP (SQL Server)
SELECT TOP 1 salary FROM
(SELECT TOP 2 salary FROM emp ORDER BY salary DESC) AS temp
ORDER BY salary ASC;
```

### Nth highest salary using DENSE_RANK():

```SQL
-- For 2nd highest
WITH salary_cte AS (
    SELECT *,
    DENSE_RANK() OVER(ORDER BY salary DESC) AS sal_order
    FROM emp
)
SELECT * FROM salary_cte WHERE sal_order = 2;

-- For Nth highest (replace N with desired number)
WITH salary_cte AS (
    SELECT *,
    DENSE_RANK() OVER(ORDER BY salary DESC) AS sal_order
    FROM emp
)
SELECT * FROM salary_cte WHERE sal_order = N;
```

**Key differences**:

- `RANK()` skips numbers after ties
- `DENSE_RANK()` doesn't skip numbers
- `ROW_NUMBER()` gives unique numbers even for ties

## 3. Employee-Manager Hierarchy (Self Join)

```SQL
-- Basic hierarchy query
SELECT
    e.emp_id,
    e.emp_name AS employee,
    m.emp_name AS manager
FROM empm e
INNER JOIN empm m ON e.manager_id = m.emp_id;
```

**Enhanced version with additional details**:

```SQL
SELECT
    e.emp_id,
    e.emp_name AS employee,
    e.salary,
    m.emp_name AS manager,
    m.salary AS manager_salary
FROM empm e
LEFT JOIN empm m ON e.manager_id = m.emp_id
ORDER BY e.salary DESC;
```

## Additional Useful Queries

### 4. Recursive Query for Full Organizational Hierarchy

```SQL
WITH org_hierarchy AS (
    -- Base case (top-level managers)
    SELECT
        emp_id,
        emp_name,
        manager_id,
        0 AS level,
        CAST(emp_name AS VARCHAR(1000)) AS hierarchy_path
    FROM empm
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case (employees)
    SELECT
        e.emp_id,
        e.emp_name,
        e.manager_id,
        oh.level + 1,
        CAST(oh.hierarchy_path + ' > ' + e.emp_name AS VARCHAR(1000))
    FROM empm e
    JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
)
SELECT * FROM org_hierarchy ORDER BY level, emp_name;
```

### 5. Employees with Salary Higher Than Their Manager

```SQL
SELECT
    e.emp_id,
    e.emp_name,
    e.salary,
    m.emp_name AS manager,
    m.salary AS manager_salary
FROM empm e
JOIN empm m ON e.manager_id = m.emp_id
WHERE e.salary > m.salary;
```

### 6. Department-wise Salary Analysis

```SQL
SELECT
    department,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary,
    MAX(salary) AS max_salary,
    MIN(salary) AS min_salary
FROM emp
GROUP BY department
ORDER BY avg_salary DESC;
```

### 7. Finding Employees with Common Managers

```SQL
SELECT
    m.emp_name AS manager,
    STRING_AGG(e.emp_name, ', ') AS team_members,
    COUNT(*) AS team_size
FROM empm e
JOIN empm m ON e.manager_id = m.emp_id
GROUP BY m.emp_name
ORDER BY team_size DESC;
```

**Note**: For MySQL, use `GROUP_CONCAT()` instead of `STRING_AGG()`

These queries provide powerful solutions for common business scenarios in employee data management, from basic operations to complex hierarchical analysis.
