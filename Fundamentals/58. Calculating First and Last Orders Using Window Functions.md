Here's a comprehensive solution to identify the first and last orders using `FIRST_VALUE` and `LAST_VALUE` window functions:

## Complete Solution

```SQL
SELECT
    order_id,
    order_date,
    sales AS total_due,
    YEAR(order_date) AS order_year,

    -- First order ID of the year (standard approach)
    FIRST_VALUE(order_id) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS first_order_id,

    -- First order date of the year
    FIRST_VALUE(order_date) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS first_order_date,

    -- Last order ID of the year (must specify proper frame)
    LAST_VALUE(order_id) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_order_id,

    -- Last order date of the year
    LAST_VALUE(order_date) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_order_date,

    -- First order amount of the year
    FIRST_VALUE(sales) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS first_order_amount,

    -- Last order amount of the year
    LAST_VALUE(sales) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date, order_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_order_amount
FROM superstore_orders
ORDER BY order_date, order_id;
```

## Key Improvements:

1. **Proper Window Framing**:
    - Added `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` to ensure `LAST_VALUE` works correctly
    - Without this, `LAST_VALUE` would only consider rows up to the current row
2. **Comprehensive Information**:
    - Returns both order IDs and dates for first/last orders
    - Includes sales amounts for first/last orders
    - Shows the year for easy grouping
3. **Accurate Ordering**:
    - Uses both `order_date` and `order_id` in `ORDER BY` to handle same-day orders
    - Ensures consistent results when multiple orders occur on boundary dates

## Alternative Approach (Using Subqueries):

```SQL
WITH yearly_orders AS (
    SELECT
        *,
        ROW_NUMBER() OVER(PARTITION BY YEAR(order_date) ORDER BY order_date, order_id) AS first_rn,
        ROW_NUMBER() OVER(PARTITION BY YEAR(order_date) ORDER BY order_date DESC, order_id DESC) AS last_rn
    FROM superstore_orders
)
SELECT
    order_id,
    order_date,
    sales AS total_due,
    YEAR(order_date) AS order_year,
    MAX(CASE WHEN first_rn = 1 THEN order_id END) OVER(PARTITION BY YEAR(order_date)) AS first_order_id,
    MAX(CASE WHEN first_rn = 1 THEN order_date END) OVER(PARTITION BY YEAR(order_date)) AS first_order_date,
    MAX(CASE WHEN last_rn = 1 THEN order_id END) OVER(PARTITION BY YEAR(order_date)) AS last_order_id,
    MAX(CASE WHEN last_rn = 1 THEN order_date END) OVER(PARTITION BY YEAR(order_date)) AS last_order_date
FROM yearly_orders
ORDER BY order_date, order_id;
```

## Performance Considerations:

1. For large datasets, ensure proper indexing on `order_date`
2. The window function approach is generally more efficient than self-joins
3. If you only need first/last values (not all rows), filter with a CTE:

```SQL
WITH yearly_boundaries AS (
    SELECT DISTINCT
        YEAR(order_date) AS order_year,
        FIRST_VALUE(order_id) OVER(PARTITION BY YEAR(order_date) ORDER BY order_date, order_id) AS first_order_id,
        LAST_VALUE(order_id) OVER(PARTITION BY YEAR(order_date) ORDER BY order_date, order_id
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_order_id
    FROM superstore_orders
)
SELECT * FROM yearly_boundaries ORDER BY order_year;
```