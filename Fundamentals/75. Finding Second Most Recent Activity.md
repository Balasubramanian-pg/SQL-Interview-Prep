## Problem Analysis

We need to find the second most recent activity for each user. If a user has only one activity, we should return that single activity.

## Solution Approach

### Step 1: Understand the Data Structure

```SQL
SELECT * FROM UserActivity;
```

This shows us all user activities with their time periods.

### Step 2: Calculate Activity Count and Rank

```SQL
SELECT *,
       COUNT(1) OVER(PARTITION BY username) AS total_activities,
       RANK() OVER(PARTITION BY username ORDER BY startDate DESC) AS rnk
FROM UserActivity;
```

This query:

- Counts total activities per user
- Ranks activities by recency (most recent first)

### Step 3: Filter the Results (Final Solution)

```SQL
WITH cte AS (
    SELECT *,
           COUNT(1) OVER(PARTITION BY username) AS total_activities,
           RANK() OVER(PARTITION BY username ORDER BY startDate DESC) AS rnk
    FROM UserActivity
)
SELECT username, activity, startDate, endDate
FROM cte
WHERE total_activities = 1 OR rnk = 2;
```

## How This Works

1. **Window Functions**:
    - `COUNT()` calculates how many activities each user has
    - `RANK()` orders activities within each user group by date (newest first)
2. **Filter Logic**:
    - `WHERE total_activities = 1` catches users with only one activity
    - `WHERE rnk = 2` selects the second most recent activity for users with multiple activities
3. **Edge Case Handling**:
    - Users with exactly one activity are included automatically
    - Users with multiple activities get their second newest activity

## Example Output

For the given data:

```Plain
Alice | Dancing | 2020-02-21 | 2020-02-23  (Second most recent)
Bob   | Travel  | 2020-02-11 | 2020-02-18  (Only activity)
```

## Alternative Approach

For databases that support `QUALIFY` (like Snowflake):

```SQL
SELECT *
FROM UserActivity
QUALIFY
    (RANK() OVER(PARTITION BY username ORDER BY startDate DESC) = 2)
    OR
    (COUNT(*) OVER(PARTITION BY username) = 1);
```

## Performance Considerations

1. **Indexing**: Ensure `username` and `startDate` are indexed for large datasets
2. **Partitioning**: For very large tables, consider partitioning by username
3. **Execution Plan**: Check that the query uses window functions efficiently