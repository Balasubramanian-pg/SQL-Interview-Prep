---
Functions: Theory
---
Common Table Expressions (CTEs) are powerful SQL constructs that improve query organization and readability. Let me explain them in detail with your examples and additional insights.

## Basic CTE Structure

```SQL
WITH cte_name AS (
    -- CTE query definition
    SELECT columns FROM table WHERE conditions
)
-- Main query that uses the CTE
SELECT * FROM cte_name;
```

## Your Examples Explained

### Example 1: Simple CTE

```SQL
WITH cte1 AS (
    SELECT emp_id, department_id FROM emp
)
SELECT * FROM cte1;
```

- Creates a temporary result set named `cte1` containing employee IDs and department IDs
- The main query simply selects all data from this CTE

### Example 2: CTE with Aggregation

```SQL
WITH cte2 AS (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM emp
    GROUP BY department_id
)
SELECT MAX(avg_salary) FROM cte2;
```

1. The CTE calculates average salary per department
2. The main query finds the maximum of these averages

### Equivalent without CTE:

```SQL
SELECT department_id, AVG(salary) AS avg_salary
FROM emp
GROUP BY department_id;
```

- This shows department-wise averages but doesn't find the maximum average

## Advanced CTE Features

### 1. Multiple CTEs in Single Query

```SQL
WITH
dept_stats AS (
    SELECT department_id, AVG(salary) AS avg_sal, COUNT(*) AS emp_count
    FROM emp
    GROUP BY department_id
),
top_depts AS (
    SELECT department_id
    FROM dept_stats
    WHERE avg_sal > (SELECT AVG(avg_sal) FROM dept_stats)
)
SELECT * FROM top_depts;
```

### 2. Recursive CTEs (for hierarchical data)

```SQL
WITH RECURSIVE emp_hierarchy AS (
    -- Base case
    SELECT emp_id, emp_name, manager_id, 1 AS level
    FROM emp
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case
    SELECT e.emp_id, e.emp_name, e.manager_id, eh.level + 1
    FROM emp e
    JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy ORDER BY level;
```

## Practical Benefits of CTEs

1. **Improved Readability**: Break complex queries into logical components
2. **Code Reuse**: Reference the same CTE multiple times in a query
3. **Recursive Queries**: Handle hierarchical data like org charts
4. **Debugging**: Test intermediate results by selecting from CTEs

## Performance Considerations

- CTEs are materialized in some databases (like PostgreSQL) but not in others (like SQL Server)
- For complex queries, consider temporary tables if performance is critical
- CTEs don't create persistent objects - they exist only during query execution

## Real-World Use Cases

1. **Data Preparation**:

```SQL
WITH clean_data AS (
    SELECT
        customer_id,
        REGEXP_REPLACE(phone, '[^0-9]', '') AS formatted_phone
    FROM customers
    WHERE phone IS NOT NULL
)
SELECT * FROM clean_data WHERE LENGTH(formatted_phone) = 10;
```

1. **Multi-step Analysis**:

```SQL
WITH
monthly_sales AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(amount) AS total_sales
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
),
growth_rates AS (
    SELECT
        month,
        total_sales,
        (total_sales - LAG(total_sales) OVER (ORDER BY month)) /
        LAG(total_sales) OVER (ORDER BY month)) AS growth_rate
    FROM monthly_sales
)
SELECT * FROM growth_rates WHERE growth_rate < 0;
```

CTEs are essential for writing maintainable, complex SQL queries while keeping your code organized and readable.