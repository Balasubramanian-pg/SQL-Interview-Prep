Here are several methods to find the second highest salary from an employee table, along with explanations of each approach:

## Table Setup

```SQL
CREATE TABLE employee (
    emp_id INT,
    emp_name CHAR(10),
    emp_salary INT
);

-- Sample data
INSERT INTO employee VALUES(1,'roshan',7000);
INSERT INTO employee VALUES(2,'Moshan',6000);
INSERT INTO employee VALUES(3,'kanti',5000);
INSERT INTO employee VALUES(4,'gagan',2000);
```

## Method 1: Using MAX (Works in all SQL dialects)

```SQL
SELECT MAX(emp_salary)
FROM employee
WHERE emp_salary < (SELECT MAX(emp_salary) FROM employee);
```

**How it works**:

1. The inner query finds the highest salary
2. The outer query finds the maximum salary that's less than the highest salary

## Method 2: Using LIMIT (MySQL, PostgreSQL, SQLite)

```SQL
SELECT emp_salary
FROM (
    SELECT emp_salary
    FROM employee
    ORDER BY emp_salary DESC
    LIMIT 2
) AS emp
ORDER BY emp_salary
LIMIT 1;
```

**How it works**:

1. Inner query gets top 2 salaries in descending order
2. Outer query sorts these 2 in ascending order and takes the first (which was originally second)

## Method 3: Using TOP (SQL Server)

```SQL
SELECT TOP 1 emp_salary
FROM (
    SELECT TOP 2 emp_salary
    FROM employee
    ORDER BY emp_salary DESC
) AS emp
ORDER BY emp_salary;
```

**How it works**:

1. Inner query gets top 2 salaries in descending order
2. Outer query sorts these 2 in ascending order and takes the first

## Additional Methods

### Method 4: Using OFFSET-FETCH (SQL Server 2012+, PostgreSQL)

```SQL
SELECT emp_salary
FROM employee
ORDER BY emp_salary DESC
OFFSET 1 ROW
FETCH NEXT 1 ROW ONLY;
```

### Method 5: Using DENSE_RANK (For handling ties)

```SQL
SELECT emp_salary
FROM (
    SELECT emp_salary, DENSE_RANK() OVER (ORDER BY emp_salary DESC) as rnk
    FROM employee
) t
WHERE rnk = 2;
```

### Method 6: Using ROW_NUMBER

```SQL
SELECT emp_salary
FROM (
    SELECT emp_salary, ROW_NUMBER() OVER (ORDER BY emp_salary DESC) as row_num
    FROM employee
) t
WHERE row_num = 2;
```

## Key Considerations:

1. **Ties**: Methods using RANK/DENSE_RANK handle ties differently than MAX/LIMIT/TOP
2. **Performance**: For large tables, MAX method is often most efficient
3. **Database compatibility**: Choose the method that works with your DBMS
4. **Empty/NULL cases**: Consider how your query handles tables with < 2 records or NULL salaries