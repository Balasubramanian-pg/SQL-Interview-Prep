Analytical functions like LEAD and LAG are powerful tools for comparing values across rows in your result set. Let's explore these functions in detail with your sales data example.

## Table Setup

```SQL
CREATE TABLE sales_table(
    year INT,
    quater_name VARCHAR(5),
    sales INT
);

-- Sample data
INSERT INTO sales_table VALUES (2018,'Q1',5000);
INSERT INTO sales_table VALUES (2018,'Q2',5500);
INSERT INTO sales_table VALUES (2018,'Q3',2500);
INSERT INTO sales_table VALUES (2018,'Q4',10000);
INSERT INTO sales_table VALUES (2019,'Q1',10000);
INSERT INTO sales_table VALUES (2019,'Q2',5500);
INSERT INTO sales_table VALUES (2019,'Q3',3000);
INSERT INTO sales_table VALUES (2019,'Q4',6000);
```

## LAG Function - Looking Backward

### 1. Basic LAG (Previous Quarter)

```SQL
SELECT
    year AS years,
    quater_name AS quaters,
    sales AS current_sales,
    LAG(sales) OVER(PARTITION BY year ORDER BY quater_name) AS previous_quater_sales
FROM sales_table;
```

**Key Points**:

- `PARTITION BY year` creates separate groups for each year
- `ORDER BY quater_name` ensures proper quarter sequence (Q1, Q2, Q3, Q4)
- For Q1 of each year, previous_quater_sales will be NULL (no previous quarter)

### 2. LAG with Offset (2 Quarters Prior)

```SQL
SELECT
    year AS years,
    quater_name AS quaters,
    sales AS current_sales,
    LAG(sales, 2) OVER(PARTITION BY year ORDER BY quater_name) AS two_quaters_prior_sales
FROM sales_table;
```

**Behavior**:

- For Q3 2018: Shows Q1 2018 sales (5000)
- For Q1/Q2: Shows NULL (not enough prior quarters in the partition)

## LEAD Function - Looking Forward

### 3. Basic LEAD (Next Quarter)

```SQL
SELECT
    year AS years,
    quater_name AS quaters,
    sales AS current_sales,
    LEAD(sales) OVER(PARTITION BY year ORDER BY quater_name) AS next_quater_sales
FROM sales_table;
```

### 4. LEAD with Descending Order (Simulating LAG)

```SQL
SELECT
    year AS years,
    quater_name AS quaters,
    sales AS current_sales,
    LEAD(sales) OVER(PARTITION BY year ORDER BY quater_name DESC) AS previous_quater_sales
FROM sales_table;
```

**Note**: This approach is less intuitive than using LAG for previous values

## Practical Applications

### 5. Quarter-over-Quarter Growth Calculation

```SQL
SELECT
    year,
    quater_name,
    sales,
    LAG(sales) OVER(PARTITION BY year ORDER BY quater_name) AS prev_quarter,
    ROUND(100.0 * (sales - LAG(sales) OVER(PARTITION BY year ORDER BY quater_name)) /
        LAG(sales) OVER(PARTITION BY year ORDER BY quater_name), 2) AS qoq_growth_pct
FROM sales_table;
```

### 6. Year-over-Year Comparison (Same Quarter)

```SQL
SELECT
    a.year,
    a.quater_name,
    a.sales AS current_year_sales,
    b.sales AS previous_year_sales,
    a.sales - b.sales AS yoy_difference
FROM sales_table a
LEFT JOIN sales_table b ON a.quater_name = b.quater_name AND a.year = b.year + 1;
```

### 7. Handling NULL Values with Defaults

```SQL
SELECT
    year,
    quater_name,
    sales,
    LAG(sales, 1, 0) OVER(PARTITION BY year ORDER BY quater_name) AS prev_quarter_with_default
FROM sales_table;
```

- Third parameter (0) replaces NULL with 0 for first quarter

## Key Differences: LEAD vs LAG

|   |   |   |
|---|---|---|
|Function|Direction|Typical Use Case|
|LAG|Looks backward|Compare with previous period|
|LEAD|Looks forward|Compare with next period|

These analytical functions are essential for time-series analysis, financial reporting, and performance trend identification in SQL.