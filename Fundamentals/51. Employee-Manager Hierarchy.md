Here's a comprehensive solution to display all levels of employee-manager hierarchy using recursive CTE:

## Complete Solution

```SQL
WITH EmployeeHierarchy AS (
    -- Base case: Top-level employees (those with no manager or dummy top manager)
    SELECT
        emp_id,
        emp_name,
        department_id,
        manager_id,
        0 AS level,
        CAST(emp_name AS VARCHAR(1000)) AS hierarchy_path
    FROM emmp
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: Employees reporting to someone
    SELECT
        e.emp_id,
        e.emp_name,
        e.department_id,
        e.manager_id,
        eh.level + 1,
        CAST(eh.hierarchy_path + ' -> ' + e.emp_name AS VARCHAR(1000))
    FROM emmp e
    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.emp_id
)
SELECT
    emp_id,
    emp_name,
    department_id,
    manager_id,
    level AS management_level,
    hierarchy_path
FROM EmployeeHierarchy
ORDER BY level, emp_name;
```

## Explanation:

1. **Base Case**:
    - Starts with top-level employees (where manager_id IS NULL)
    - Initializes level to 0 and begins the hierarchy path
2. **Recursive Case**:
    - Joins employees with their managers from the previous level
    - Increments the level by 1
    - Extends the hierarchy path with each employee
3. **Final Output**:
    - Shows employee details
    - Includes management level (0 = top, 1 = reports to top, etc.)
    - Displays full hierarchy path for each employee

## Alternative Version (With Manager Names):

```SQL
WITH EmployeeHierarchy AS (
    SELECT
        emp_id,
        emp_name,
        department_id,
        manager_id,
        0 AS level,
        CAST(emp_name AS VARCHAR(1000)) AS hierarchy_path
    FROM emmp
    WHERE manager_id IS NULL

    UNION ALL

    SELECT
        e.emp_id,
        e.emp_name,
        e.department_id,
        e.manager_id,
        eh.level + 1,
        CAST(eh.hierarchy_path + ' -> ' + e.emp_name AS VARCHAR(1000))
    FROM emmp e
    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.emp_id
)
SELECT
    eh.emp_id,
    eh.emp_name,
    eh.department_id,
    m.emp_name AS manager_name,
    eh.level,
    eh.hierarchy_path
FROM EmployeeHierarchy eh
LEFT JOIN emmp m ON eh.manager_id = m.emp_id
ORDER BY eh.level, eh.emp_name;
```

## Key Features:

1. **Handles Multiple Hierarchy Levels**: Works for organizations of any depth
2. **Visual Path**: Shows the complete chain of command for each employee
3. **Performance**: Efficiently processes hierarchical data
4. **Flexibility**: Can be adapted to include additional employee attributes

## Expected Output Example:

For your sample data, the output would show:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|emp_id|emp_name|department_id|manager_id|management_level|hierarchy_path|
|7|Jenny Jeff|999|NULL|0|Jenny Jeff|
|6|Mark Miles|NULL|7|1|Jenny Jeff -> Mark Miles|
|3|Hilary Riles|101|4|2|Jenny Jeff -> Mark Miles -> Hilary Riles|
|...|...|...|...|...|...|

This query is particularly useful for organizational reporting, understanding reporting structures, and analyzing management chains.

Here's a comprehensive solution to analyze email domains from your entries table:

## Complete Solution

```SQL
WITH email_domains AS (
    SELECT
        email,
        -- Extract domain (everything after @)
        SUBSTRING(email, CHARINDEX('@', email) + 1, LEN(email)) AS domain
    FROM entries
    WHERE email LIKE '%@%'  -- Ensure email contains @ symbol
)
SELECT
    domain,
    COUNT(*) AS email_count,
    STRING_AGG(email, ', ') AS sample_emails  -- Show sample emails from each domain
FROM email_domains
GROUP BY domain
ORDER BY email_count DESC, domain;
```

## Explanation:

1. **Domain Extraction**:
    - `CHARINDEX('@', email)` finds the position of the @ symbol
    - `SUBSTRING()` extracts everything after the @ symbol
    - The `WHERE` clause filters out invalid email formats
2. **Aggregation**:
    - Groups records by the extracted domain
    - Counts occurrences of each domain
    - Uses `STRING_AGG()` to show sample emails (SQL Server 2017+)
3. **Result Formatting**:
    - Orders by email count (descending) then alphabetically by domain
    - Provides both the count and sample emails for context

## Alternative Versions:

### For Older SQL Server Versions (pre-2017):

```SQL
SELECT
    SUBSTRING(email, CHARINDEX('@', email) + 1, LEN(email)) AS domain,
    COUNT(*) AS email_count,
    -- Alternative to STRING_AGG for older versions
    (
        SELECT TOP 5 email + ', '
        FROM entries e2
        WHERE SUBSTRING(e2.email, CHARINDEX('@', e2.email) + 1, LEN(e2.email)) =
              SUBSTRING(e1.email, CHARINDEX('@', e1.email) + 1, LEN(e1.email))
        FOR XML PATH('')
    ) AS sample_emails
FROM entries e1
WHERE email LIKE '%@%'
GROUP BY SUBSTRING(email, CHARINDEX('@', email) + 1, LEN(email))
ORDER BY email_count DESC;
```

### For MySQL/PostgreSQL:

```SQL
SELECT
    SUBSTRING(email, POSITION('@' IN email) + 1) AS domain,
    COUNT(*) AS email_count,
    GROUP_CONCAT(email SEPARATOR ', ') AS sample_emails
FROM entries
WHERE email LIKE '%@%'
GROUP BY domain
ORDER BY email_count DESC;
```

## Key Benefits:

1. **Accurate Domain Extraction**: Properly handles all email formats
2. **Performance**: Efficiently processes large datasets
3. **Insightful Output**: Shows both counts and sample emails
4. **Flexibility**: Can be adapted for different SQL dialects

This query helps identify which email domains are most common in your database, useful for marketing segmentation, fraud detection, or system analysis.