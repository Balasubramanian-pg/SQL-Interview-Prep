Here's a comprehensive guide to calculating Year-to-Date (YTD) and Month-to-Date (MTD) totals using SQL window functions:

## 1. Basic YTD Calculation

```SQL
SELECT
    order_id,
    order_date,
    sales AS total_due,
    SUM(sales) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ytd_sales
FROM superstore_orders
ORDER BY order_date;
```

## 2. MTD Calculation

```SQL
SELECT
    order_id,
    order_date,
    sales AS total_due,
    SUM(sales) OVER(
        PARTITION BY YEAR(order_date), MONTH(order_date)
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS mtd_sales
FROM superstore_orders
ORDER BY order_date;
```

## 3. Combined YTD and MTD with Proper Framing

```SQL
SELECT
    order_id,
    order_date,
    sales AS total_due,
    -- YTD with explicit row framing
    SUM(sales) OVER(
        PARTITION BY YEAR(order_date)
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ytd_sales,

    -- MTD with explicit row framing
    SUM(sales) OVER(
        PARTITION BY YEAR(order_date), MONTH(order_date)
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS mtd_sales,

    -- Last 3 orders moving sum
    SUM(sales) OVER(
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS last_3_orders_sum
FROM superstore_orders
ORDER BY order_date;
```

## Key Concepts Explained:

1. **PARTITION BY**:
    - For YTD: `PARTITION BY YEAR(order_date)`
    - For MTD: `PARTITION BY YEAR(order_date), MONTH(order_date)`
2. **ORDER BY**:
    - Always order by date for chronological accumulation
    - Ensures proper cumulative calculation
3. **Window Frame**:
    - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` gives true cumulative totals
    - Without explicit framing, SQL may use `RANGE` which treats ties differently
    - `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` calculates moving 3-period sum
4. **Performance Tips**:
    - Ensure proper indexing on `order_date` for large datasets
    - Explicit framing (`ROWS`) is more efficient than implicit (`RANGE`)
    - Filter early with WHERE clauses before applying window functions

## Advanced Example with Additional Metrics:

```SQL
SELECT
    order_id,
    order_date,
    sales AS total_due,
    -- YTD metrics
    SUM(sales) OVER(PARTITION BY YEAR(order_date) ORDER BY order_date ROWS UNBOUNDED PRECEDING) AS ytd_sales,
    AVG(sales) OVER(PARTITION BY YEAR(order_date) ORDER BY order_date ROWS UNBOUNDED PRECEDING) AS ytd_avg,

    -- MTD metrics
    SUM(sales) OVER(PARTITION BY YEAR(order_date), MONTH(order_date) ORDER BY order_date ROWS UNBOUNDED PRECEDING) AS mtd_sales,

    -- Quarterly totals
    SUM(sales) OVER(PARTITION BY YEAR(order_date), DATEPART(QUARTER, order_date) ORDER BY order_date ROWS UNBOUNDED PRECEDING) AS qtd_sales,

    -- Moving averages
    AVG(sales) OVER(ORDER BY order_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_3day_avg
FROM superstore_orders
ORDER BY order_date;
```