## Method 1: Using Self-Join Approach

```SQL
SELECT
    e.emp_id,
    e.emp_name,
    e.department_id,
    e.salary
FROM emp e
INNER JOIN (
    SELECT
        department_id,
        MAX(salary) AS max_salary
    FROM emp
    GROUP BY department_id
) AS dept_max ON e.department_id = dept_max.department_id
              AND e.salary = dept_max.max_salary
ORDER BY e.department_id;
```

## Method 2: Using Window Functions (Recommended)

```SQL
WITH ranked_salaries AS (
    SELECT
        emp_id,
        emp_name,
        department_id,
        salary,
        DENSE_RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
    FROM emp
)
SELECT
    emp_id,
    emp_name,
    department_id,
    salary
FROM ranked_salaries
WHERE salary_rank = 1
ORDER BY department_id;
```

## Method 3: Employees Earning Less Than Dept Avg But More Than Other Dept Avg

```SQL
WITH dept_avgs AS (
    SELECT
        department_id,
        AVG(salary) AS avg_salary
    FROM emp
    GROUP BY department_id
)
SELECT
    e.emp_id,
    e.emp_name,
    e.department_id,
    e.salary,
    da.avg_salary AS dept_avg_salary
FROM emp e
JOIN dept_avgs da ON e.department_id = da.department_id
WHERE e.salary < da.avg_salary
AND e.salary > ANY (
    SELECT avg_salary
    FROM dept_avgs
    WHERE department_id <> e.department_id
)
ORDER BY e.department_id, e.salary DESC;
```

## Key Differences:

1. **Performance**:
    - Window function approach (Method 2) is generally more efficient
    - Avoids self-join which can be expensive for large tables
2. **Handling Ties**:
    - `DENSE_RANK()` will show all employees who tie for top salary
    - Use `ROW_NUMBER()` if you want exactly one employee per department
3. **Readability**:
    - Window functions make the intention clearer
    - Easier to modify for other ranking scenarios
4. **Advanced Filtering**:
    - Method 3 demonstrates complex filtering across department averages
    - Uses CTE for cleaner logic and better performance

## Alternative for MySQL (without window functions):

```SQL
SELECT e1.*
FROM emp e1
LEFT JOIN emp e2 ON e1.department_id = e2.department_id AND e1.salary < e2.salary
WHERE e2.emp_id IS NULL;
```

Here's a solution to find employees whose salary is:

1. Less than their own department's average salary
2. But more than the average salary of at least one other department

## Complete Solution

```SQL
WITH dept_avg AS (
    SELECT
        department_id,
        AVG(salary) AS avg_salary
    FROM emp
    GROUP BY department_id
)
SELECT
    e.emp_id,
    e.emp_name,
    e.department_id,
    e.salary,
    da.avg_salary AS dept_avg_salary
FROM emp e
JOIN dept_avg da ON e.department_id = da.department_id
WHERE e.salary < da.avg_salary  -- Less than own department average
AND e.salary > ANY (            -- Greater than at least one other department's average
    SELECT avg_salary
    FROM dept_avg
    WHERE department_id <> e.department_id
)
ORDER BY e.department_id, e.salary;
```

## Explanation:

1. **CTE (dept_avg)**:
    - Calculates the average salary for each department
    - Creates a reference table for department averages
2. **Main Query**:
    - Joins employee data with department averages
    - Filters for employees earning less than their department average (`e.salary < da.avg_salary`)
    - Uses `> ANY` to find employees earning more than at least one other department's average
3. **Alternative to ANY**:
    
    - You could also use `EXISTS` for this condition:
    
    ```SQL
    AND EXISTS (
        SELECT 1
        FROM dept_avg da2
        WHERE da2.department_id <> e.department_id
        AND e.salary > da2.avg_salary
    )
    ```
    

## Example Output:

For sample data with:

- Dept 100 avg = 10,000
- Dept 200 avg = 12,000
- Dept 300 avg = 8,000

The query would return employees from:

- Dept 100 with salary between 8,000 and 10,000
- Dept 200 with salary between 8,000 and 12,000
- Dept 300 with salary less than 8,000 (but this would be excluded since no department has lower average)

## Key Notes:

1. The `> ANY` operator checks if the value is greater than at least one value in the subquery
2. This is different from `> ALL` which would require the salary to be greater than all other department averages
3. The query handles multiple departments automatically
4. For large datasets, ensure proper indexing on department_id and salary columns
