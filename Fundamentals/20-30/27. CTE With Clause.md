Common Table Expressions (CTEs) provide a cleaner way to write complex queries by breaking them into logical components. Here are several examples demonstrating CTE usage:

## 1. Basic CTE Example (vs Subquery)

```SQL
-- Without CTE (using subquery)
SELECT * FROM empl
WHERE salary > (SELECT AVG(salary) FROM empl);

-- With CTE (cleaner and more readable)
WITH avg_salary AS (
    SELECT AVG(salary) AS avg_sal FROM empl
)
SELECT * FROM empl
WHERE salary > (SELECT avg_sal FROM avg_salary);
```

## 2. Multiple CTEs in Single Query

```SQL
WITH avg_salary AS (
    SELECT AVG(salary) AS avg_sal FROM empl
),
max_salary AS (
    SELECT MAX(salary) AS max_sal FROM empl
),
min_salary AS (
    SELECT MIN(salary) AS min_sal FROM empl
)
SELECT
    e.*,
    a.avg_sal,
    m.max_sal,
    mi.min_sal,
    CASE
        WHEN e.salary > a.avg_sal THEN 'Above Average'
        ELSE 'Below Average'
    END AS salary_status
FROM empl e
CROSS JOIN avg_salary a
CROSS JOIN max_salary m
CROSS JOIN min_salary mi;
```

## 3. Recursive CTE Example (Hierarchical Data)

```SQL
-- Employee hierarchy (who reports to whom)
WITH emp_hierarchy AS (
    -- Base case (top-level employees)
    SELECT
        emp_id,
        emp_name,
        manager_id,
        0 AS level,
        CAST(emp_name AS VARCHAR(100)) AS hierarchy_path
    FROM empl
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case
    SELECT
        e.emp_id,
        e.emp_name,
        e.manager_id,
        eh.level + 1,
        CAST(eh.hierarchy_path + ' -> ' + e.emp_name AS VARCHAR(100))
    FROM empl e
    JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy
ORDER BY level, emp_name;
```

## 4. CTE with Window Functions

```SQL
WITH salary_ranks AS (
    SELECT
        emp_id,
        emp_name,
        salary,
        department_id,
        RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) AS dept_rank,
        RANK() OVER(ORDER BY salary DESC) AS overall_rank
    FROM empl
)
SELECT
    emp_name,
    salary,
    department_id,
    dept_rank AS "Department Rank",
    overall_rank AS "Overall Rank"
FROM salary_ranks
WHERE dept_rank <= 3
ORDER BY department_id, dept_rank;
```

## 5. CTE for Data Transformation

```SQL
WITH clean_data AS (
    SELECT
        emp_id,
        TRIM(emp_name) AS emp_name,
        department_id,
        CASE
            WHEN salary < 10000 THEN salary * 1.1  -- 10% raise for low salaries
            ELSE salary
        END AS adjusted_salary
    FROM empl
    WHERE emp_name IS NOT NULL
)
SELECT
    department_id,
    COUNT(*) AS employee_count,
    AVG(adjusted_salary) AS avg_adjusted_salary,
    SUM(adjusted_salary) AS total_salary_budget
FROM clean_data
GROUP BY department_id
ORDER BY avg_adjusted_salary DESC;
```

## Key Benefits of Using CTEs:

1. **Improved Readability**: Complex logic is broken into understandable parts
2. **Code Reuse**: Reference the same CTE multiple times in a query
3. **Recursive Queries**: Enable hierarchical data processing
4. **Debugging**: Easier to test intermediate results
5. **Maintenance**: Simpler to modify specific parts of complex queries

Remember that CTEs:

- Exist only during query execution
- Don't create permanent database objects
- Can reference previously defined CTEs in the same WITH clause
- Are evaluated each time they're referenced (not materialized by default)
