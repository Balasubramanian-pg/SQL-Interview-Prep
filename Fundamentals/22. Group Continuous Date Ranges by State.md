This query identifies continuous date ranges where the state remains the same (either 'success' or 'fail'):

```SQL
WITH date_groups AS (
    SELECT
        date_value,
        state,
        DATEADD(day, -1 * ROW_NUMBER() OVER(PARTITION BY state ORDER BY date_value), date_value) AS group_date
    FROM tasks
)
SELECT
    state,
    MIN(date_value) AS start_date,
    MAX(date_value) AS end_date
FROM date_groups
GROUP BY state, group_date
ORDER BY start_date;
```

## Explanation:

1. **Inner CTE (**`**date_groups**`**)**:
    - For each row, calculates a `group_date` by subtracting the row number from the date
    - Row numbers are partitioned by state and ordered by date
    - This creates the same `group_date` for consecutive dates with the same state
2. **Main Query**:
    - Groups by both state and the calculated `group_date`
    - Finds the minimum (start) and maximum (end) dates for each group
    - Returns the state along with the continuous date ranges

## How It Works:

- For consecutive dates with the same state, subtracting their row numbers will result in the same `group_date`
- Example for 'success' state:
    - 2019-01-01 (row 1) → 2019-01-01 - 1 = 2018-12-31
    - 2019-01-02 (row 2) → 2019-01-02 - 2 = 2018-12-31
    - 2019-01-03 (row 3) → 2019-01-03 - 3 = 2018-12-31
- These all get the same `group_date` (2018-12-31), so they're grouped together

## Expected Output:

For the sample data, the result would be:

|   |   |   |
|---|---|---|
|state|start_date|end_date|
|success|2019-01-01|2019-01-03|
|fail|2019-01-04|2019-01-05|
|success|2019-01-06|2019-01-06|

This shows:

- A continuous 'success' period from Jan 1-3
- A 'fail' period on Jan 4-5
- Another 'success' on Jan 6

## Alternative Solution (More Readable):

```SQL
WITH marked_dates AS (
    SELECT
        date_value,
        state,
        CASE
            WHEN LAG(state) OVER(ORDER BY date_value) = state
            THEN 0 ELSE 1
        END AS is_new_group
    FROM tasks
),
grouped_dates AS (
    SELECT
        date_value,
        state,
        SUM(is_new_group) OVER(ORDER BY date_value) AS group_id
    FROM marked_dates
)
SELECT
    state,
    MIN(date_value) AS start_date,
    MAX(date_value) AS end_date
FROM grouped_dates
GROUP BY state, group_id
ORDER BY start_date;
```

This alternative uses a different approach with `LAG()` to detect state changes and may be more intuitive for some users.