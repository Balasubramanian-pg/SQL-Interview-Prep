## Problem Statement

Find the review text that received the highest number of 'cool' votes, along with the corresponding business name.

## Solution Approach

```SQL
SELECT business_name, review_text
FROM (
    SELECT
        business_name,
        review_text,
        cool,
        DENSE_RANK() OVER(ORDER BY cool DESC) AS rnk
    FROM yelp_reviews
) sub
WHERE rnk = 1;
```

## Key Components Explained

1. **Subquery Structure**:
    - The inner query selects business name, review text, and cool votes count
    - It calculates a rank for each review based on cool votes
2. **Window Function**:
    - `DENSE_RANK() OVER(ORDER BY cool DESC)` assigns ranks:
        - The review with highest cool votes gets rank 1
        - If multiple reviews tie for highest, they all get rank 1
        - Subsequent reviews get ranks 2, 3, etc.
3. **Outer Query Filter**:
    - `WHERE rnk = 1` filters to only show the top-ranked review(s)

## Why This Works

- The query handles ties properly - if multiple reviews have the same highest number of cool votes, all will be returned
- Using DENSE_RANK() is better than RANK() here because we want consecutive ranking numbers
- The subquery approach is clean and efficient for this type of "top N" problem

## Alternative Approaches

1. Using MAX() with a self-join:

```SQL
SELECT business_name, review_text
FROM yelp_reviews
WHERE cool = (SELECT MAX(cool) FROM yelp_reviews);
```

1. Using LIMIT (if you only want one result, even with ties):

```SQL
SELECT business_name, review_text
FROM yelp_reviews
ORDER BY cool DESC
LIMIT 1;
```

## Learning Points

1. Window functions like DENSE_RANK() are powerful for ranking data
2. Subqueries can help organize complex filtering logic
3. Different ranking functions (RANK, DENSE_RANK, ROW_NUMBER) have subtle but important differences
4. There are often multiple ways to solve the same problem in SQL