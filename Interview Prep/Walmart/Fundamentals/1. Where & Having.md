# 1. *Difference between `WHERE` and `HAVING`?*
(Many confuse row filtering vs group filtering.)

*   **WHERE Clause**
> [!IMPORTANT]
> Filters rows BEFORE aggregation occurs.
*   Operates on individual rows from the base tables.
*   Cannot use aggregate functions in conditions.
*   Executes early in query processing.
*   Reduces the number of rows sent for grouping.

*   **HAVING Clause**
> [!NOTE]
> Filters groups AFTER aggregation occurs.
*   Operates on grouped/aggregated results.
*   Can use aggregate functions in conditions.
*   Executes after GROUP BY processing.
*   Filters the final grouped result set.

**Execution Order**

*   **Query Processing Sequence**
> [!TIP]
> WHERE executes before GROUP BY, HAVING executes after.
1.  FROM - Load tables
2.  WHERE - Filter individual rows
3.  GROUP BY - Group filtered rows
4.  HAVING - Filter groups
5.  SELECT - Return final results

**SQL Examples**

*   **WHERE Only (Row Filtering)**
```sql
-- Filter employees before any aggregation
SELECT Department, AVG(Salary) as AvgSalary
FROM Employees
WHERE Salary > 50000  -- Individual row filter
GROUP BY Department;
-- Only employees earning >50k are considered for averaging
```

*   **HAVING Only (Group Filtering)**
```sql
-- Filter after calculating averages
SELECT Department, AVG(Salary) as AvgSalary
FROM Employees
GROUP BY Department
HAVING AVG(Salary) > 80000;  -- Group filter
-- Only departments with average salary >80k appear
```

*   **WHERE + HAVING Combined**
```sql
-- Filter rows first, then filter groups
SELECT Department, AVG(Salary) as AvgSalary
FROM Employees
WHERE HireDate > '2020-01-01'  -- Row filter: recent hires only
GROUP BY Department
HAVING AVG(Salary) > 60000;    -- Group filter: high-paying depts
-- Clean, efficient two-stage filtering
```

**Common Mistakes**

*   **Using WHERE with Aggregates**
> [!CAUTION]
> WHERE cannot contain aggregate functions.
```sql
-- INVALID: Aggregate in WHERE clause
SELECT Department, AVG(Salary)
FROM Employees
WHERE AVG(Salary) > 80000  -- ERROR
GROUP BY Department;

-- CORRECT: Use HAVING instead
SELECT Department, AVG(Salary)
FROM Employees
GROUP BY Department
HAVING AVG(Salary) > 80000;  -- VALID
```

*   **Using HAVING without GROUP BY**
> [!NOTE]
> HAVING can be used without GROUP BY but acts on entire result as one group.
```sql
-- Valid but unusual - treats all rows as one group
SELECT AVG(Salary) as CompanyAvg
FROM Employees
HAVING AVG(Salary) > 50000;
```

**Performance Implications**

*   **WHERE Efficiency**
> [!TIP]
> Always use WHERE when possible to reduce data early.
*   Filters data before expensive grouping operations.
*   Smaller dataset for GROUP BY means faster execution.
*   Can utilize indexes effectively.

*   **HAVING Impact**
*   Processes all data through GROUP BY first.
*   Then filters the already-aggregated results.
*   Less efficient than pre-filtering with WHERE.

**Practical Scenarios**

*   **Use WHERE For:**
*   Filtering specific records before analysis.
*   Date range restrictions.
*   Status or category filters.
*   Any condition that doesn't require aggregates.

*   **Use HAVING For:**
*   Filtering based on group calculations.
*   Finding departments with high averages.
*   Groups meeting minimum count thresholds.
*   Top-N analysis per group.

**Real-World Examples**

*   **Sales Analysis**
```sql
-- Find product categories with high average sales in 2024
SELECT Category, AVG(SaleAmount) as AvgSale
FROM Sales
WHERE SaleDate >= '2024-01-01'  -- Filter recent sales first
GROUP BY Category
HAVING AVG(SaleAmount) > 1000   -- Then filter high-performing categories
AND COUNT(*) > 50;              -- With sufficient data points
```

*   **Employee Reporting**
```sql
-- Departments with many high-earning senior staff
SELECT Department, COUNT(*) as SeniorCount
FROM Employees
WHERE Salary > 80000 AND YearsExperience > 10  -- Filter individuals
GROUP BY Department
HAVING COUNT(*) >= 5;                         -- Filter department groups
```

**Best Practice Rule**
> [!IMPORTANT]
> Use WHERE to filter rows before grouping, use HAVING to filter groups after aggregation.
