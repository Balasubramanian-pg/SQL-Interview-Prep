# 4. *Explain the difference between `UNION` and `UNION ALL`.*
   (Duplicates handling is often missed.)

*   **UNION ALL**
> [!TIP]
> Combines results from multiple queries and includes ALL rows.
*   **Preserves duplicate rows** from all result sets.
*   Faster performance - no duplicate checking overhead.
*   Simply concatenates all results together.
*   Use when you know duplicates don't matter or are desired.

*   **UNION**
> [!IMPORTANT]
> Combines results and removes duplicate rows.
*   **Eliminates duplicate rows** across all result sets.
*   Slower performance - requires sorting and duplicate removal.
*   More resource-intensive for large datasets.
*   Use when you need distinct results only.

**Performance Impact**

*   **UNION ALL Processing**
> [!NOTE]
> UNION ALL executes faster because it does no duplicate checking.
*   Minimal overhead - just combines result sets.
*   No sorting or comparison operations.
*   Scalable to large datasets efficiently.

*   **UNION Processing**
> [!CAUTION]
> UNION requires sorting and duplicate elimination.
*   Database must sort all rows from all queries.
*   Then compares adjacent rows to remove duplicates.
*   Can be slow with large result sets.

**SQL Examples**

*   **UNION ALL Example**
```sql
-- Combines all employees from both offices, including duplicates
SELECT Name, Department FROM NY_Office
UNION ALL
SELECT Name, Department FROM LA_Office;
-- If same person exists in both offices, both rows appear
```

*   **UNION Example**
```sql
-- Combines employees and removes duplicates
SELECT Name, Department FROM NY_Office
UNION
SELECT Name, Department FROM LA_Office;
-- Each person appears only once, even if in both offices
```

**Visual Result Differences**

*   **Sample Data:**
*   NY_Office: (John, Sales), (Mary, Marketing), (John, Sales)
*   LA_Office: (Mary, Marketing), (David, IT), (John, Sales)

*   **UNION ALL Result:**
*   (John, Sales), (Mary, Marketing), (John, Sales), (Mary, Marketing), (David, IT), (John, Sales)
*   **6 rows** - all duplicates preserved

*   **UNION Result:**
*   (John, Sales), (Mary, Marketing), (David, IT)
*   **3 rows** - duplicates removed

**Column Requirements**

*   **Same Number of Columns**
> [!IMPORTANT]
> Both UNION and UNION ALL require identical number of columns.
*   All SELECT statements must have same column count.
*   Column names from first query are used in result.

*   **Compatible Data Types**
> [!NOTE]
> Corresponding columns must have compatible data types.
```sql
-- Valid UNION (compatible types)
SELECT CustomerName, City FROM Customers
UNION
SELECT SupplierName, City FROM Suppliers;

-- Invalid UNION (different column count)
SELECT Name, Department, Salary FROM Employees
UNION
SELECT Name, Department FROM Contractors; -- ERROR
```

**Practical Use Cases**

*   **Use UNION ALL When:**
*   Combining data from similar tables (archives, partitions).
*   Performance is critical and duplicates are acceptable.
*   You're certain no duplicates exist between result sets.
*   Building comprehensive lists from multiple sources.

*   **Use UNION When:**
*   Creating distinct lists from multiple tables.
*   Removing duplicates is a business requirement.
*   Generating unique reports from overlapping data sources.
*   Data quality requires elimination of duplicate entries.

**Best Practices**

*   **Default to UNION ALL**
> [!TIP]
> Start with UNION ALL unless you specifically need duplicate removal.
*   Better performance in most cases.
*   Explicit about your intent to keep all data.

*   **Consider Data Volume**
> [!CAUTION]
> UNION with large datasets can cause tempdb growth and performance issues.
*   Test with your actual data volumes.
*   Consider filtering before UNION to reduce data.

*   **Column Alignment**
```sql
-- Use NULL for missing columns
SELECT Name, Department, Salary, HireDate FROM FullTime_Employees
UNION ALL
SELECT Name, Department, NULL AS Salary, StartDate FROM Contractors;
```

**Memory and Resource Usage**

*   **UNION ALL**
*   Minimal memory requirements.
*   Streams data without intermediate storage.

*   **UNION**
*   Requires memory/tempdb for sorting.
*   Resource usage grows with data volume.
*   May need disk-based sorting for large datasets.
