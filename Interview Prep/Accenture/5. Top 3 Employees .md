# **5. Top 3 employees with highest salaries**
We assume table `Employees(emp_id, emp_name, salary)`.

```sql
SELECT emp_id, emp_name, salary
FROM Employees
ORDER BY salary DESC
LIMIT 3;   -- SQL Server would use TOP 3
```

## Business Value
Identifying top earners helps organizations:
- Understand compensation distribution
- Benchmark executive pay
- Analyze pay equity
- Plan for succession
- Review organizational structure

## Database Schema
```sql
CREATE TABLE Employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100) NOT NULL,
    salary DECIMAL(12,2) NOT NULL,
    department VARCHAR(50),
    position VARCHAR(50),
    hire_date DATE
    -- Additional employee attributes
);
```

## Enhanced SQL Solutions

### Standard Solution (Cross-Platform)
```sql
SELECT 
    emp_id, 
    emp_name, 
    salary,
    department,
    position
FROM Employees
ORDER BY salary DESC
LIMIT 3;  -- Use TOP 3 in SQL Server, FETCH FIRST 3 ROWS ONLY in Oracle
```

### Window Function Approach (More Flexible)
```sql
WITH RankedEmployees AS (
    SELECT 
        emp_id,
        emp_name,
        salary,
        department,
        position,
        DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
    FROM Employees
)
SELECT 
    emp_id, 
    emp_name, 
    salary,
    department,
    position
FROM RankedEmployees
WHERE salary_rank <= 3;
```

### Handling Ties (Alternative)
```sql
SELECT 
    e.emp_id, 
    e.emp_name, 
    e.salary,
    e.department,
    e.position
FROM Employees e
WHERE (
    SELECT COUNT(DISTINCT e2.salary)
    FROM Employees e2
    WHERE e2.salary > e.salary
) < 3
ORDER BY e.salary DESC, e.emp_name;
```

## Key Enhancements

1. **Added Contextual Data**:
   - Included department and position information
   - Makes results more actionable for HR

2. **Multiple Approaches**:
   - Standard LIMIT/TOP solution for simplicity
   - Window function for more complex ranking needs
   - Tie-handling version for exact top-N requirements

3. **Cross-Platform Compatibility**:
   - Noted syntax variations for different SQL dialects

## Sample Data and Results

**Employees Table:**
| emp_id | emp_name | salary  | department  | position          |
|--------|----------|---------|-------------|-------------------|
| 101    | Sarah    | 150000  | Executive   | CEO               |
| 102    | Michael  | 145000  | Executive   | CFO               |
| 103    | Emily    | 145000  | Executive   | CTO               |
| 104    | David    | 120000  | Engineering | VP of Engineering |
| 105    | John     | 110000  | Marketing   | Director          |

**Expected Results (Standard Solution):**
| emp_id | emp_name | salary  | department  | position  |
|--------|----------|---------|-------------|-----------|
| 101    | Sarah    | 150000  | Executive   | CEO       |
| 102    | Michael  | 145000  | Executive   | CFO       |
| 103    | Emily    | 145000  | Executive   | CTO       |

**Expected Results (Window Function with DENSE_RANK):**
| emp_id | emp_name | salary  | department  | position  |
|--------|----------|---------|-------------|-----------|
| 101    | Sarah    | 150000  | Executive   | CEO       |
| 102    | Michael  | 145000  | Executive   | CFO       |
| 103    | Emily    | 145000  | Executive   | CTO       |

## Alternative Approaches

1. **Department-Specific Top Earners**:
```sql
WITH DeptRankings AS (
    SELECT 
        emp_id,
        emp_name,
        salary,
        department,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank
    FROM Employees
)
SELECT * FROM DeptRankings WHERE dept_rank <= 3;
```

2. **With Salary Percentile Information**:
```sql
SELECT 
    emp_id, 
    emp_name, 
    salary,
    department,
    PERCENT_RANK() OVER (ORDER BY salary) * 100 AS percentile
FROM Employees
ORDER BY salary DESC
LIMIT 3;
```

3. **Historical Comparison**:
```sql
WITH CurrentTop AS (
    SELECT emp_id FROM Employees ORDER BY salary DESC LIMIT 3
)
SELECT 
    e.emp_id,
    e.emp_name,
    e.salary,
    e.department,
    h.salary AS last_year_salary,
    ROUND((e.salary - h.salary)/h.salary*100, 2) AS pct_increase
FROM Employees e
JOIN EmployeeHistory h ON e.emp_id = h.emp_id
WHERE e.emp_id IN (SELECT emp_id FROM CurrentTop)
AND h.effective_date = CURRENT_DATE - INTERVAL '1 year';
```

## Performance Optimization

1. **Indexing Strategy**:
```sql
CREATE INDEX idx_employees_salary ON Employees(salary DESC);
CREATE INDEX idx_employees_dept_salary ON Employees(department, salary DESC);
```

2. **Materialized View for Frequent Reports**:
```sql
CREATE MATERIALIZED VIEW mv_top_earners AS
SELECT emp_id, emp_name, salary, department, position
FROM Employees
ORDER BY salary DESC
LIMIT 10
WITH DATA;
```

## Business Applications

1. **Compensation Review**:
   - Compare top salaries to market benchmarks
   - Assess pay equity across demographics

2. **Succession Planning**:
   - Identify key positions with highest compensation
   - Plan for leadership transitions

3. **Budget Forecasting**:
   - Project compensation growth for high earners
   - Model impact of bonus structures

4. **Organizational Analysis**:
   - Review concentration of high salaries in departments
   - Assess span of control for high-paid managers

## Extended Analysis

1. **Salary Distribution Visualization**:
   - Histogram of all employee salaries
   - Highlight top 3 earners in context

2. **Compensation Ratio Analysis**:
```sql
SELECT 
    (SELECT MAX(salary) FROM Employees) AS top_salary,
    (SELECT AVG(salary) FROM Employees) AS avg_salary,
    (SELECT MAX(salary) FROM Employees) / 
    (SELECT AVG(salary) FROM Employees) AS ratio;
```

3. **Pay Equity Audit**:
```sql
SELECT 
    gender,
    COUNT(*) AS employees,
    AVG(salary) AS avg_salary,
    MAX(salary) AS max_salary
FROM Employees
GROUP BY gender
ORDER BY avg_salary DESC;
```
