# **6. Second-highest salary without `LIMIT` or `TOP`**
Assume `Employees(emp_id, emp_name, salary)`.

```sql
SELECT MAX(salary) AS second_highest_salary
FROM Employees
WHERE salary < (SELECT MAX(salary) FROM Employees);
```

The subquery finds the highest salary, then we take the max of all salaries lower than that.

## Business Value
Identifying salary benchmarks helps organizations:
- Establish competitive compensation structures
- Analyze pay equity across departments
- Prepare for promotion discussions
- Budget for salary adjustments
- Compare with industry standards

## Database Schema
```sql
CREATE TABLE Employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100) NOT NULL,
    salary DECIMAL(12,2) NOT NULL,
    department VARCHAR(50),
    hire_date DATE
    -- Additional employee attributes
);
```

## Enhanced SQL Solutions

### Solution 1: Subquery Approach (Original)
```sql
SELECT MAX(salary) AS second_highest_salary
FROM Employees
WHERE salary < (SELECT MAX(salary) FROM Employees);
```

### Solution 2: Window Function Approach
```sql
WITH RankedSalaries AS (
    SELECT 
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
    FROM Employees
)
SELECT salary AS second_highest_salary
FROM RankedSalaries
WHERE salary_rank = 2;
```

### Solution 3: Self-Join Approach
```sql
SELECT MAX(e1.salary) AS second_highest_salary
FROM Employees e1
JOIN (
    SELECT MAX(salary) AS max_salary
    FROM Employees
) e2 ON e1.salary < e2.max_salary;
```

## Key Enhancements

1. **Multiple Solution Approaches**:
   - Provided alternative methods with different performance characteristics
   - Window function solution is more extensible for finding Nth highest

2. **Edge Case Handling**:
   - All solutions properly handle ties for highest salary
   - Returns NULL if there's only one employee

3. **Performance Considerations**:
   - Subquery approach is simple but may scan table twice
   - Window function approach is more efficient for multiple rankings

## Sample Data and Results

**Employees Table:**
| emp_id | emp_name | salary  | department |
|--------|----------|---------|------------|
| 1      | John     | 95000.00| Engineering|
| 2      | Sarah    | 110000.00| Marketing |
| 3      | Michael  | 110000.00| Sales     |
| 4      | Emily    | 85000.00| HR        |
| 5      | David    | 105000.00| Engineering|

**Expected Result:**
| second_highest_salary |
|-----------------------|
| 105000.00             |

## Alternative Approaches

1. **Finding Nth Highest Salary**:
```sql
-- Using window function for 3rd highest
WITH RankedSalaries AS (
    SELECT 
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
    FROM Employees
)
SELECT salary AS third_highest_salary
FROM RankedSalaries
WHERE salary_rank = 3;
```

2. **Department-Specific Second Highest**:
```sql
SELECT department, MAX(salary) AS second_highest_salary
FROM Employees e1
WHERE salary < (
    SELECT MAX(salary) 
    FROM Employees e2 
    WHERE e2.department = e1.department
)
GROUP BY department;
```

3. **With Employee Details**:
```sql
SELECT e.emp_id, e.emp_name, e.salary
FROM Employees e
WHERE e.salary = (
    SELECT MAX(salary)
    FROM Employees
    WHERE salary < (SELECT MAX(salary) FROM Employees)
);
```

## Performance Optimization

1. **Indexing Strategy**:
```sql
CREATE INDEX idx_employees_salary ON Employees(salary DESC);
```

2. **For Large Datasets**:
   - Window function approach generally performs better
   - Consider materialized views for frequent salary analysis

## Business Applications

1. **Compensation Planning**:
   - Establish salary bands based on actual distributions
   - Identify outliers needing adjustment

2. **Promotion Preparation**:
   - Compare high performers' compensation to peers
   - Prepare for salary negotiation discussions

3. **Pay Equity Analysis**:
   - Compare second highest salaries across demographics
   - Identify potential disparities

4. **Budget Forecasting**:
   - Project salary growth based on current distributions
   - Model impact of across-the-board raises

## Extended Analysis

1. **Salary Distribution Analysis**:
```sql
WITH SalaryBands AS (
    SELECT 
        FLOOR(salary/10000)*10000 AS band_start,
        COUNT(*) AS employees,
        ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER(), 1) AS percentage
    FROM Employees
    GROUP BY FLOOR(salary/10000)
)
SELECT 
    band_start,
    band_start + 9999 AS band_end,
    employees,
    percentage
FROM SalaryBands
ORDER BY band_start;
```

2. **Salary Growth Over Time**:
```sql
WITH HistoricalSalaries AS (
    SELECT 
        emp_id,
        effective_date,
        salary,
        LAG(salary) OVER(PARTITION BY emp_id ORDER BY effective_date) AS prev_salary
    FROM SalaryHistory
)
SELECT 
    EXTRACT(YEAR FROM effective_date) AS year,
    AVG(salary) AS avg_salary,
    AVG(CASE WHEN prev_salary > 0 
         THEN (salary - prev_salary)/prev_salary * 100 
         END) AS avg_pct_increase
FROM HistoricalSalaries
GROUP BY EXTRACT(YEAR FROM effective_date)
ORDER BY year;
```

3. **Comparative Analysis**:
```sql
SELECT 
    department,
    MAX(salary) AS highest_salary,
    (SELECT MAX(salary) 
     FROM Employees e2 
     WHERE e2.department = e1.department 
     AND salary < (SELECT MAX(salary) 
                  FROM Employees e3 
                  WHERE e3.department = e1.department)
    ) AS second_highest_salary,
    AVG(salary) AS avg_salary
FROM Employees e1
GROUP BY department
ORDER BY highest_salary DESC;
```
