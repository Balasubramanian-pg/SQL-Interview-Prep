# SQL Trick Questions - Syntax & Behavior Gotchas

*   **JOIN vs WHERE with NULLs**
> [!CAUTION]
> INNER JOIN and WHERE conditions handle NULLs the same - both exclude NULL matches.
```sql
-- Both queries behave identically with NULL ids
SELECT * FROM A INNER JOIN B ON A.id = B.id;
SELECT * FROM A, B WHERE A.id = B.id;
-- NULL = NULL returns UNKNOWN, so rows with NULL ids are excluded from both
```

*   **GROUP BY with Non-Aggregated Columns**
> [!IMPORTANT]
> Most SQL engines require ALL non-aggregated columns in GROUP BY.
```sql
-- FAILS in strict SQL modes (MySQL with ONLY_FULL_GROUP_BY)
SELECT id, name, department FROM employees GROUP BY id;

-- WORKS - all non-aggregated columns in GROUP BY
SELECT id, name, department FROM employees GROUP BY id, name, department;

-- WORKS - non-grouped columns wrapped in aggregates
SELECT id, MAX(name) as name, COUNT(department) as dept_count 
FROM employees GROUP BY id;
```

*   **DELETE with JOIN Syntax Variations**
> [!NOTE]
> DELETE JOIN syntax varies significantly across database systems.
```sql
-- MySQL DELETE JOIN
DELETE A FROM A INNER JOIN B ON A.id = B.id WHERE B.flag = 1;

-- SQL Server DELETE JOIN  
DELETE A FROM A INNER JOIN B ON A.id = B.id WHERE B.flag = 1;

-- Standard SQL with subquery (works everywhere)
DELETE FROM A WHERE id IN (SELECT id FROM B WHERE flag = 1);
```

*   **UNION vs UNION ALL Duplicate Handling**
> [!TIP]
> UNION removes duplicates, UNION ALL preserves them - performance differs greatly.
```sql
-- Removes duplicates (slower)
SELECT name FROM customers 
UNION 
SELECT name FROM suppliers;

-- Keeps all rows (faster)
SELECT name FROM customers 
UNION ALL 
SELECT name FROM suppliers;
```

*   **NULL Comparison Classic Trap**
> [!WARNING]
> Never use = NULL or <> NULL - always use IS NULL/IS NOT NULL.
```sql
-- WRONG: Returns empty result set
SELECT * FROM employees WHERE manager_id = NULL;

-- CORRECT: Finds rows where manager_id is NULL
SELECT * FROM employees WHERE manager_id IS NULL;

-- WRONG: Returns empty result set  
SELECT * FROM employees WHERE manager_id <> NULL;

-- CORRECT: Finds rows where manager_id has values
SELECT * FROM employees WHERE manager_id IS NOT NULL;
```

**More Common SQL Traps**

*   **Date/Time Literal Formats**
```sql
-- MySQL (works)
SELECT * FROM orders WHERE order_date = '2024-01-15';

-- Oracle (fails - needs TO_DATE)
SELECT * FROM orders WHERE order_date = '2024-01-15'; -- ERROR

-- SQL Server (depends on settings)
SELECT * FROM orders WHERE order_date = '2024-01-15'; -- Risky
```

*   **Implicit Type Conversion**
```sql
-- May work or fail depending on database
SELECT * FROM products WHERE product_id = '123'; -- string vs number
SELECT * FROM sales WHERE amount = '100.50'; -- string vs decimal
```

*   **COUNT() Variations**
```sql
-- Different results with NULLs
SELECT COUNT(*) FROM employees; -- counts all rows
SELECT COUNT(manager_id) FROM employees; -- counts non-NULL manager_id only
SELECT COUNT(1) FROM employees; -- counts all rows (same as COUNT(*))
```

*   **Boolean Expressions with NULL**
```sql
-- Surprising results with NULLs
SELECT * FROM tasks WHERE completed = TRUE; -- misses NULL values
SELECT * FROM tasks WHERE completed <> TRUE; -- also misses NULL values
SELECT * FROM tasks WHERE completed IS NOT TRUE; -- includes FALSE and NULL
```

**Defensive SQL Strategies**

*   **Always Test Edge Cases**
> [!TIP]
> Assume NULLs, empty strings, and duplicates exist in your data.
*   Test queries with NULL values in join columns.
*   Verify behavior with duplicate records.
*   Check empty result set scenarios.

*   **Use Explicit Syntax**
```sql
-- Be explicit about join types
SELECT * FROM A INNER JOIN B ON A.id = B.id; -- not comma joins

-- Use standard date formats or functions
SELECT * FROM orders WHERE order_date = DATE '2024-01-15';

-- Specify column lists instead of SELECT *
SELECT id, name, department FROM employees;
```

*   **Understand Your Database Engine**
> [!NOTE]
> MySQL, PostgreSQL, SQL Server, and Oracle have different default behaviors.
*   Know your SQL_MODE settings in MySQL.
*   Understand ANSI compatibility levels.
*   Test cross-platform if supporting multiple databases.
