## 17. What is **foreign key cascading**, and how does it work?

**Foreign key cascading** is a feature in relational databases that automatically triggers actions (like updates or deletes) on related rows in child tables when a referenced row in the parent table is modified. This ensures **referential integrity** without manual intervention.

## **How It Works**
When you define a foreign key with cascading rules, the database automatically:
- **Updates** or **deletes** related rows in child tables based on changes to the parent table.

## **Types of Cascading Actions**

| Action               | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| **ON DELETE CASCADE**| Deletes all child rows referencing a parent row when the parent is deleted.|
| **ON UPDATE CASCADE**| Updates child rows if the referenced parent key is updated.                |
| **SET NULL**         | Sets foreign key values to NULL if the parent row is deleted/updated.      |
| **SET DEFAULT**      | Sets foreign key values to a default if the parent row is deleted/updated. |

## **Example**
Suppose you have two tables:
- **Parent**: `customers(id, name)`
- **Child**: `orders(customer_id, order_date)`

### **SQL with Cascading Delete**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id)
        REFERENCES customers(id)
        ON DELETE CASCADE  -- Deletes all orders if a customer is deleted
);
```
- If a `customer` is deleted, all their `orders` are **automatically deleted**.

### **SQL with Cascading Update**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id)
        REFERENCES customers(id)
        ON UPDATE CASCADE  -- Updates customer_id in orders if customers.id changes
);
```
- If a `customer.id` is updated, all matching `orders.customer_id` values are updated.

## **Why Use Cascading?**
- **Maintains data consistency**: No orphaned records.
- **Reduces manual code**: No need to write triggers or application logic.
- **Simplifies maintenance**: Changes propagate automatically.

### **Key Callouts**

<ins>**Callout 1: Referential Integrity**</ins>
- Ensures child rows always reference valid parent rows.

<ins>**Callout 2: Performance Impact**</ins>
- Cascading operations can be **expensive** for large tables (e.g., deleting a customer with 1M orders).

<ins>**Callout 3: Use Cases**</ins>
- Ideal for **one-to-many** relationships (e.g., users and their posts).
- Avoid for **many-to-many** or complex hierarchies.

<ins>**Callout 4: Alternatives**</ins>
- Use **triggers** or **application logic** for more control.

<ins>**Callout 5: Risks**</ins>
- Accidental mass deletes (e.g., `DELETE FROM customers` could wipe out all orders).

**Best Practice:**
Use cascading judiciouslyâ€”only when the relationship is **exclusive** and the action is **logically safe**. For critical data, consider **SET NULL** or manual handling.
