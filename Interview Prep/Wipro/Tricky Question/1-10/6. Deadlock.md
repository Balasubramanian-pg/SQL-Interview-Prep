## 6. What is a **deadlock**, and how can it be resolved?

### **What is a Deadlock?**
A **deadlock** occurs when two or more transactions are **blocked forever**, each waiting for the other to release a lock on a resource (e.g., a database row or table). This creates a **circular dependency**, causing all transactions to stall.

### **Example of a Deadlock**
Imagine two transactions:
- **Transaction 1**: Locks **Row A**, then requests **Row B**.
- **Transaction 2**: Locks **Row B**, then requests **Row A**.

Both transactions wait indefinitely, resulting in a deadlock.

### **How to Resolve Deadlocks?**

#### **1. Prevention**
- **Lock Ordering**: Always acquire locks in the same order (e.g., alphabetically by table name).
- **Avoid User Interaction**: Never hold locks while waiting for user input.
- **Use Timeouts**: Set a lock timeout to abort transactions after a specified period.
- **Single Statement Transactions**: Keep transactions short and atomic.

#### **2. Detection and Recovery**
- **Database Detection**: Most databases (e.g., SQL Server, PostgreSQL) automatically detect deadlocks and **terminate one of the transactions** (the "victim").
- **Retry Logic**: Applications should catch deadlock errors and **retry the transaction**.

#### **3. Avoiding Long Transactions**
- **Short Transactions**: Minimize the time locks are held.
- **Optimize Queries**: Reduce the number of rows locked.

#### **4. Use Lower Isolation Levels**
- **Read Committed** or **Snapshot Isolation**: Reduces lock contention compared to **Serializable**.

### **How Databases Handle Deadlocks**
- **SQL Server/PostgreSQL**: Automatically detects deadlocks and rolls back one transaction.
- **MySQL (InnoDB)**: Uses a wait-for graph to detect deadlocks and aborts the least expensive transaction.
- **Oracle**: Uses a timeout-based approach.

### **Example: Deadlock Resolution in Code**
```sql
-- Example in T-SQL (SQL Server)
BEGIN TRY
    BEGIN TRANSACTION;
        -- Transaction logic here
    COMMIT;
END TRY
BEGIN CATCH
    IF ERROR_NUMBER() = 1205 -- Deadlock error
    BEGIN
        ROLLBACK;
        -- Log the deadlock and retry
        WAITFOR DELAY '00:00:01'; -- Wait before retry
        -- Retry the transaction
    END
END CATCH;
```

### **Key Callouts**

<ins>**Callout 1: Circular Wait**</ins>
- Deadlocks occur due to **circular dependencies** between transactions.

<ins>**Callout 2: Automatic Detection**</ins>
- Most databases detect and resolve deadlocks by aborting one transaction.

<ins>**Callout 3: Retry Logic**</ins>
- Applications should **retry aborted transactions** after a short delay.

<ins>**Callout 4: Lock Timeouts**</ins>
- Set a **lock timeout** to avoid indefinite waits.

<ins>**Callout 5: Best Practices**</ins>
- Keep transactions **short and simple**.
- Avoid **nested transactions** and **user interaction** during transactions.

**Summary:**
- **Deadlocks** are circular dependencies between transactions.
- **Resolve** by preventing (lock ordering, timeouts) or recovering (retry logic).
- **Databases** automatically detect and abort deadlocks, but applications must handle retries.
