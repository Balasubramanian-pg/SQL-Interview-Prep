## 7. Difference between **clustered** and **non-clustered indexes**.

Here’s a clear breakdown of the differences between **clustered** and **non-clustered indexes**, including their structure, performance, and use cases:

## **1. Clustered Index**
### **What is a Clustered Index?**
- Determines the **physical order** of data in a table.
- The table’s data rows are **stored in the same order** as the clustered index key.
- **Only one clustered index per table** (since data can’t be sorted in multiple ways).

### **How It Works**
- Acts like a **phone book**: Data is physically sorted by the index key.
- **Leaf nodes** contain the **actual data rows**.

### **Pros**
- **Faster for range queries**: Data is physically ordered, so scans are efficient.
- **No extra storage**: Data is not duplicated (the index is the table).

### **Cons**
- **Slower writes**: Inserts/updates/deletes require reordering the table.
- **Only one per table**: Limits flexibility.

### **Example**
```sql
-- Creates a clustered index on the 'id' column
CREATE CLUSTERED INDEX IX_Employee_ID ON Employees(id);
```
- The `Employees` table is physically sorted by `id`.
- 
## **2. Non-Clustered Index**
### **What is a Non-Clustered Index?**
- A **separate structure** from the data, containing a **copy of the indexed columns** and a **pointer** to the actual row.
- **Multiple non-clustered indexes** can exist per table.

### **How It Works**
- Acts like an **index in a textbook**: Points to the location of the data.
- **Leaf nodes** contain the **indexed columns + a pointer** (to the clustered index or heap).

### **Pros**
- **Faster for point lookups**: Quickly finds specific rows.
- **Multiple indexes**: Supports many query patterns.
- **No physical reordering**: Writes are faster than clustered indexes.

### **Cons**
- **Extra storage**: Requires space for the index structure.
- **Slower for range scans**: May need to fetch data from the main table.

### **Example**
```sql
-- Creates a non-clustered index on the 'last_name' column
CREATE NONCLUSTERED INDEX IX_Employee_Name ON Employees(last_name);
```
- The index stores `last_name` values and pointers to the actual rows.

## **Clustered vs. Non-Clustered Indexes**



| Feature                | **Clustered Index**                          | **Non-Clustered Index**                     |
|------------------------|---------------------------------------------|---------------------------------------------|
| **Physical Order**     | Determines the physical order of data.      | Separate structure; points to data.       |
| **Number per Table**   | Only **one**.                               | **Multiple** allowed.                       |
| **Storage**            | No extra storage (data is the index).       | Requires extra storage.                     |
| **Read Performance**   | Faster for **range queries**.               | Faster for **point lookups**.               |
| **Write Performance**  | Slower (reorders data).                     | Faster (no physical reordering).           |
| **Use Case**           | Columns frequently used for sorting/scanning. | Columns frequently used for filtering.     |

### **Key Callouts**

<ins>**Callout 1: Physical vs. Logical Order**</ins>
- **Clustered**: Physically reorders the table.
- **Non-clustered**: Logical structure; points to the data.

<ins>**Callout 2: Only One Clustered Index**</ins>
- A table can have **only one clustered index** (since data can’t be sorted in multiple ways).
- **Non-clustered indexes** can have many (e.g., one for `last_name`, one for `email`).

<ins>**Callout 3: Performance Trade-offs**</ins>
- **Clustered**: Best for **range queries** (e.g., `WHERE id BETWEEN 10 AND 20`).
- **Non-clustered**: Best for **point queries** (e.g., `WHERE last_name = 'Smith'`).

<ins>**Callout 4: Storage Overhead**</ins>
- **Non-clustered indexes** require extra storage for the index structure and pointers.

<ins>**Callout 5: Default Clustered Index**</ins>
- In most databases, the **primary key** is automatically the clustered index (unless specified otherwise).
  
**When to Use Which?**
- **Use a clustered index** for:
  - Columns frequently used in **range queries** or **sorting** (e.g., `id`, `date`).
  - Tables where **read performance** is critical.

- **Use non-clustered indexes** for:
  - Columns frequently used in **WHERE clauses** or **joins**.
  - Tables where **multiple query patterns** exist.

---
**Example:**
- **Clustered Index**: `CREATE CLUSTERED INDEX IX_Orders_Date ON Orders(order_date);` (for time-based range queries).
- **Non-Clustered Index**: `CREATE NONCLUSTERED INDEX IX_Orders_Customer ON Orders(customer_id);` (for customer lookups).
