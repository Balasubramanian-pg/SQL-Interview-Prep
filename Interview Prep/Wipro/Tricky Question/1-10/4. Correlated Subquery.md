## 4. What is a **correlated subquery**? How does it differ from a regular subquery?

### **Correlated Subquery vs. Regular Subquery**

#### **1. Regular Subquery**
- **Definition**: A subquery that executes **independently** of the outer query. It runs once and returns a result used by the outer query.
- **Performance**: Efficient for static filtering.
- **Example**:
  ```sql
  -- Find employees earning more than the average salary
  SELECT name FROM employees
  WHERE salary > (SELECT AVG(salary) FROM employees);
  ```
  - The subquery `(SELECT AVG(salary) FROM employees)` runs **once** and returns a single value.

#### **2. Correlated Subquery**
- **Definition**: A subquery that **depends on the outer query**. It executes **once for each row** processed by the outer query.
- **Key Feature**: References a column from the outer query.
- **Performance**: Slower for large datasets (runs repeatedly).
- **Example**:
  ```sql
  -- Find employees earning more than their department's average salary
  SELECT e.name
  FROM employees e
  WHERE salary > (
      SELECT AVG(salary)
      FROM employees
      WHERE department_id = e.department_id  -- Depends on outer query's row
  );
  ```
  - The subquery runs **for each employee**, using the current rowâ€™s `department_id`.

### **Key Differences**

| Feature                | **Regular Subquery**               | **Correlated Subquery**                     |
|------------------------|------------------------------------|---------------------------------------------|
| **Dependency**         | Independent of outer query.       | Depends on outer query (references its columns). |
| **Execution**          | Runs **once**.                     | Runs **once per outer row**.                |
| **Performance**        | Faster (static result).            | Slower (dynamic, row-by-row).               |
| **Use Case**           | Filtering with static values.      | Row-specific comparisons (e.g., per-group averages). |

### **Key Callouts**

<ins>**Callout 1: Dependency**</ins>
- **Regular**: Standalone (e.g., `WHERE salary > (SELECT AVG(salary) FROM employees)`).
- **Correlated**: Linked to outer query (e.g., `WHERE department_id = e.department_id`).

<ins>**Callout 2: Performance Impact**</ins>
- Correlated subqueries can be **inefficient** for large tables. Consider joins or CTEs for optimization.

<ins>**Callout 3: Common Use Cases**</ins>
- **Correlated**: "Find rows where a column value relates to aggregated data from the same table."
  Example: "Employees earning more than their department average."

<ins>**Callout 4: Alternatives**</ins>
- Replace correlated subqueries with **joins** or **window functions** for better performance:
  ```sql
  -- Using a join (faster alternative)
  SELECT e.name
  FROM employees e
  JOIN (
      SELECT department_id, AVG(salary) AS avg_salary
      FROM employees
      GROUP BY department_id
  ) dept_avg ON e.department_id = dept_avg.department_id
  WHERE e.salary > dept_avg.avg_salary;
  ```

<ins>**Callout 5: EXISTS Clause**</ins>
- Correlated subqueries often use `EXISTS` for row existence checks:
  ```sql
  SELECT name FROM employees e
  WHERE EXISTS (
      SELECT 1 FROM bonuses WHERE employee_id = e.id  -- Correlated
  );
  ```
**When to Use Which?**
- Use **regular subqueries** for static conditions.
- Use **correlated subqueries** for row-specific logic (but optimize if performance is critical).
