## 5. Explain **normalization** vs **denormalization** and when to use each.

## **1. Normalization**
### **What is Normalization?**
- The process of **organizing data** to minimize redundancy and dependency.
- Achieved by dividing tables into smaller, related tables and defining relationships using **foreign keys**.
- Follows **normal forms** (1NF, 2NF, 3NF, BCNF, etc.).

### **Goals**
- **Eliminate redundancy**: Store data in one place.
- **Improve data integrity**: Changes only need to be made in one location.
- **Simplify queries**: Easier to maintain and update.

### **Example**
**Before Normalization:**
| OrderID | CustomerName | ProductName | ProductPrice |
|---------|--------------|-------------|--------------|
| 1       | Alice        | Laptop      | 1000         |
| 2       | Bob          | Phone       | 500          |

**After Normalization (3NF):**
- **Customers** table:
  | CustomerID | CustomerName |
  |------------|--------------|
  | 1          | Alice        |
  | 2          | Bob          |

- **Products** table:
  | ProductID | ProductName | ProductPrice |
  |-----------|-------------|--------------|
  | 1         | Laptop      | 1000         |
  | 2         | Phone       | 500          |

- **Orders** table:
  | OrderID | CustomerID | ProductID |
  |---------|------------|-----------|
  | 1       | 1          | 1         |
  | 2       | 2          | 2         |

### **Pros**
- **Less redundancy**: Data is stored once.
- **Easier updates**: Changes propagate consistently.
- **Better integrity**: Constraints and foreign keys enforce rules.

### **Cons**
- **Complex queries**: Requires joins to retrieve data.
- **Slower reads**: More joins = slower performance for read-heavy operations.

## **2. Denormalization**
### **What is Denormalization?**
- The process of **intentionally introducing redundancy** to improve read performance.
- Combines tables or duplicates data to reduce joins.

### **Goals**
- **Faster reads**: Fewer joins = quicker queries.
- **Simplified queries**: Easier for reporting and analytics.

### **Example**
**Denormalized Table:**
| OrderID | CustomerName | ProductName | ProductPrice |
|---------|--------------|-------------|--------------|
| 1       | Alice        | Laptop      | 1000         |
| 2       | Bob          | Phone       | 500          |

### **Pros**
- **Faster queries**: No joins needed for common operations.
- **Simpler code**: Easier to write and maintain for read-heavy apps.

### **Cons**
- **Redundancy**: Duplicate data wastes storage.
- **Update anomalies**: Changes must be made in multiple places.
- **Risk of inconsistency**: Data can become out of sync.

## **Normalization vs. Denormalization: When to Use Each?**

| Feature                | **Normalization**                          | **Denormalization**                        |
|------------------------|--------------------------------------------|---------------------------------------------|
| **Data Redundancy**    | Minimal (avoids duplicates).              | High (introduces duplicates).               |
| **Read Performance**   | Slower (requires joins).                  | Faster (fewer joins).                       |
| **Write Performance**  | Faster (single updates).                  | Slower (multiple updates).                  |
| **Data Integrity**     | High (consistent, no anomalies).           | Lower (risk of inconsistency).              |
| **Use Case**           | OLTP (transactional systems).              | OLAP (analytics, reporting).                |
| **Complexity**         | Higher (more tables, joins).               | Lower (simpler queries).                    |
### **Key Callouts**

<ins>**Callout 1: OLTP vs. OLAP**</ins>
- **Normalization**: Best for **OLTP** (Online Transaction Processing) systems (e.g., banking, e-commerce).
- **Denormalization**: Best for **OLAP** (Online Analytical Processing) systems (e.g., reporting, dashboards).

<ins>**Callout 2: Performance Trade-off**</ins>
- **Normalization**: Optimizes **write speed** and **data integrity**.
- **Denormalization**: Optimizes **read speed** at the cost of storage and consistency.

<ins>**Callout 3: Hybrid Approach**</ins>
- Many systems use a mix: normalized tables for transactions, denormalized tables/views for reporting.

<ins>**Callout 4: Alternatives**</ins>
- Use **indexes**, **materialized views**, or **caching** before denormalizing.

<ins>**Callout 5: Modern Databases**</ins>
- Some databases (e.g., PostgreSQL, Snowflake) support both normalized and denormalized structures (e.g., JSON columns).

**When to Use Which?**
- **Use Normalization** for:
  - Transactional systems (e.g., order processing, inventory).
  - Applications requiring high data integrity.

- **Use Denormalization** for:
  - Read-heavy applications (e.g., analytics, dashboards).
  - Scenarios where query speed is critical and slight staleness is acceptable.
    
**Example:**
- **Normalized**: An e-commerce database with separate tables for `users`, `orders`, and `products`.
- **Denormalized**: A reporting database with a single `sales_summary` table combining user, order, and product data.
