## 2. What is **ACID** in databases, and why is it important?

<img width="1762" height="992" alt="image" src="https://github.com/user-attachments/assets/118f146c-67db-45fd-bcc2-40b4e3e0a3de" />

**ACID** is a set of properties that ensure **reliable and consistent** transactions in database systems. It stands for:

- **Atomicity**
- **Consistency**
- **Isolation**
- **Durability**

These properties are crucial for maintaining **data integrity**, especially in systems where multiple users or processes access the database simultaneously.

## **1. Atomicity**
**Definition:** A transaction is treated as a single, indivisible unit- either **all** operations succeed, or **none** do.

**Why it matters:**
- Prevents partial updates (e.g., if a bank transfer fails halfway, money isn’t lost or duplicated).
- Uses **rollbacks** to undo changes if any part of the transaction fails.

**Example:**
Transferring $100 from Account A to Account B:
- Deduct $100 from A.
- Add $100 to B.
If either step fails, the entire transaction is rolled back.

## **2. Consistency**
**Definition:** A transaction brings the database from one valid state to another, enforcing all rules (e.g., constraints, triggers).

**Why it matters:**
- Ensures data follows predefined rules (e.g., no negative balances, required fields).
- Prevents corruption or invalid data.

**Example:**
A database rule states that an account balance cannot be negative. A transaction violating this rule is aborted.

## **3. Isolation**
**Definition:** Transactions run independently of each other, so intermediate states are invisible to other transactions.

**Why it matters:**
- Prevents **dirty reads**, **phantom reads**, or **non-repeatable reads**.
- Ensures concurrent transactions don’t interfere.

**Example:**
If User 1 is updating a record, User 2 either sees the old or final state—not the halfway update.

## **4. Durability**
**Definition:** Once a transaction is committed, it remains permanent, even in case of system failure (e.g., power outage, crash).

**Why it matters:**
- Guarantees data persistence.
- Uses **write-ahead logging (WAL)** or backups to recover committed transactions.

**Example:**
After a successful bank transfer, the change is saved to disk and survives a server crash.

## **Why is ACID Important?**
- **Reliability:** Ensures transactions are processed correctly, even in complex or high-concurrency environments.
- **Trust:** Critical for financial systems, e-commerce, and any application where data integrity is non-negotiable.
- **Predictability:** Developers can assume transactions will behave as expected, simplifying error handling.

### **Key Callouts**

<ins>**Callout 1: ACID vs. Performance**</ins>
- Strict ACID compliance can impact performance (e.g., locks in isolation).
- Some databases (e.g., NoSQL) relax ACID for speed or scalability.

<ins>**Callout 2: Real-World Use**</ins>
- **Banks, payment systems, and inventory management** rely on ACID to prevent errors.

<ins>**Callout 3: Trade-offs**</ins>
- **NoSQL databases** (e.g., MongoDB, Cassandra) often sacrifice ACID for flexibility or horizontal scaling.

<ins>**Callout 4: Implementation**</ins>
- Achieved via **locks, logs, and transaction managers** in databases like PostgreSQL, MySQL, and Oracle.

<ins>**Callout 5: BASE Model**</ins>
- Some systems use **BASE** (Basically Available, Soft state, Eventually consistent) instead of ACID for distributed systems.

**Example:**
```sql
BEGIN TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- Deduct from A
    UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- Add to B
COMMIT; -- ACID ensures this is atomic, consistent, isolated, and durable.
```
