## 19. How do **indexes** affect INSERT, UPDATE, and DELETE operations?

<img width="910" height="321" alt="word-image-339" src="https://github.com/user-attachments/assets/f26888b8-ec95-407f-a75f-16d6dbd2e686" />

Indexes significantly improve **read performance** (SELECT queries) by allowing the database to find data quickly, but they also impact **write operations** (INSERT, UPDATE, DELETE). Hereâ€™s how:
## **1. INSERT Operations**
- **Overhead**: Every time you insert a row, the database must update **all relevant indexes**.
- **Impact**:
  - Slower inserts, especially if the table has many indexes.
  - Indexes with high cardinality (e.g., unique values) or complex structures (e.g., composite indexes) add more overhead.
- **Example**: Inserting into a table with 5 indexes requires updating all 5 indexes, slowing down the operation.

## **2. UPDATE Operations**
- **Overhead**: If the updated column is part of an index, the database must:
  1. Remove the old value from the index.
  2. Insert the new value into the index.
- **Impact**:
  - Updates are slower if the column is indexed.
  - Non-indexed columns are unaffected.
- **Example**: Updating an `email` column (which has a unique index) requires rebuilding the index entry.

## **3. DELETE Operations**
- **Overhead**: When a row is deleted, the database must remove its entries from **all indexes**.
- **Impact**:
  - Slower deletes, especially for tables with many indexes.
  - Can cause index fragmentation over time, degrading performance.
- **Example**: Deleting a row from a table with 3 indexes requires cleaning up all 3 indexes.

## **Performance Trade-offs**

| Operation | Without Indexes | With Indexes                     |
|-----------|------------------|----------------------------------|
| **INSERT**| Fast             | Slower (index updates required) |
| **UPDATE**| Fast (if non-indexed) | Slower (if indexed columns are updated) |
| **DELETE**| Fast             | Slower (index cleanup required) |

![maxresdefault](https://github.com/user-attachments/assets/57e5429c-0ab2-46cc-9ddf-a278249f25b3)

### **Key Callouts**

<ins>**Callout 1: Index Overhead**</ins>
- Every index adds **write overhead**. More indexes = slower writes.

<ins>**Callout 2: Selective Indexing**</ins>
- Only index columns used in **frequent searches, joins, or WHERE clauses**.
- Avoid indexing columns that are rarely queried.

<ins>**Callout 3: Composite Indexes**</ins>
- Composite indexes (multiple columns) increase overhead but can speed up complex queries.

<ins>**Callout 4: Index Maintenance**</ins>
- Regularly **rebuild or reorganize** indexes to reduce fragmentation and improve performance.

<ins>**Callout 5: Balance**</ins>
- **Trade-off**: More indexes = faster reads but slower writes. Optimize based on your workload (read-heavy vs. write-heavy).

**Best Practices:**
- Use indexes for **frequently queried columns**.
- Avoid over-indexing **write-heavy tables**.
- Monitor index usage and remove unused indexes.
