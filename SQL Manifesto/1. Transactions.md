## Data Engineering Manifesto

### Rule 1: Transactions Are Sacred

Transactions are not an implementation detail. They are a moral contract between your system, your data, and every downstream consumer who trusts that data. When you change data, you are altering reality inside the system. That act demands discipline.

A transaction is the smallest unit of truth. Anything less is a lie waiting to surface.

### The Principle

All data-changing operations must be **explicitly transactional**.

This rule applies to:

* Inserts, updates, deletes
* Merge operations
* Batch loads
* Backfills and corrections
* Schema-altering data migrations that affect content

If data changes, it must live inside a transaction. No exceptions justified by speed, convenience, or optimism.

### The Non-Negotiables

Every transactional operation must obey the following:

* **Explicit control**

  * Use `BEGIN`, `COMMIT`, and `ROLLBACK` deliberately.
  * The transaction boundary must be visible in the code.
  * Anyone reading the script should know exactly when reality changes.

* **No implicit commits**

  * Do not rely on database defaults.
  * Do not trust client behavior.
  * Do not assume a tool “handles it for you”.
  * If the transaction is not explicit, it is not safe.

* **Partial success is failure**

  * If one statement fails, everything fails.
  * A job that writes 99 percent of rows is not “mostly correct”.
  * There is no such thing as acceptable inconsistency.

### Why This Rule Exists

Transactions protect the core guarantees of reliable systems:

* **Atomicity**

  * Either everything happens, or nothing happens.
  * There is no in-between state where data is half-true.

* **Consistency**

  * Business rules are enforced at all times.
  * Constraints are not temporarily violated.
  * Downstream systems never see broken logic.

Without transactions, you do not have data integrity. You have hope.

### What Happens When You Break This Rule

Breaking transactional discipline creates silent failures that are expensive and slow to detect:

* Orphaned records
* Double-counted facts
* Misaligned aggregates
* Reports that cannot be reconciled
* “One-time fixes” that become permanent scars

These issues rarely explode immediately. They rot quietly, then surface during audits, leadership reviews, or customer escalations.

At that point, the question is never “what went wrong?”
It is always “why did we allow this?”

### Design Mindset

When writing data-changing code, think like this:

* If this fails halfway, am I comfortable with the data state?
* If the system crashes right now, what survives?
* Can I safely rerun this without manual cleanup?
* Would I defend this logic in a postmortem?

If the answer to any of these is “I hope so”, the transaction is not done.

### Operational Standard

A transaction must:

* Be as small as possible
* Cover all dependent operations
* Fail fast
* Roll back cleanly
* Leave no ambiguity behind

Transactions are not about being careful.
They are about being **correct**.

### Closing Statement

Data is memory.
Transactions are integrity.

If you treat transactions as optional, your system will eventually forget the truth.
