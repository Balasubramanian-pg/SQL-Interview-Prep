## Data Engineering Manifesto

### Rule 9: Design for Scale, Not Today

Today’s data volume is a lie.
Tomorrow’s growth will expose every shortcut you took.

Systems rarely fail because of what they cannot do today. They fail because of what they silently assumed would never change.

### The Principle

**Assume data volume will grow by at least 10x without notice.**

Design is not about the current state. It is about the next unexpected state.

### No `SELECT *`

`SELECT *` is an abdication of responsibility.

* It couples logic to schema evolution
* It pulls unnecessary data
* It breaks silently when schemas change

Explicit column selection:

* Documents intent
* Reduces I/O
* Preserves compatibility
* Survives growth

If you cannot name the columns you need, you do not understand the data you are using.

### No Logic That Assumes “Small Tables”

Small tables do not stay small.

* Dimensions grow
* Lookup tables accumulate history
* Reference data gains versions

Logic that relies on full scans, nested loops, or repeated subqueries eventually collapses. Scale exposes hidden costs.

### No Hard-Coded Limits That Affect Correctness

Limits are for presentation, not truth.

* `LIMIT` without deterministic ordering lies
* Caps on row counts hide data loss
* Arbitrary thresholds distort metrics

If removing a limit changes the meaning of the result, the logic is wrong.

### Why Scale Breaks Naive Design

Growth reveals:

* Cardinality errors
* Missing constraints
* Poor join choices
* Data skew assumptions

These issues exist from day one. Scale merely turns them visible.

### Design Standard

Scalable SQL:

* Works the same at 1 million and 1 billion rows
* Degrades gradually, not catastrophically
* Does not rely on memory accidents
* Does not assume data shape stability

If the design only works because the data is “small”, it does not work.

### Code Review Test

Before approving SQL, ask:

* What happens when this table is 10x larger?
* Which step scales worst?
* Which assumption becomes false first?

If growth breaks correctness or performance, redesign now, not later.

### Closing Statement

Optimizing for today is comfortable.
Designing for scale is responsible.

Tomorrow will not wait for refactoring.

Say **next** when you are ready to continue.
