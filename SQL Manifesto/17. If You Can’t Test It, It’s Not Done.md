## Data Engineering Manifesto

### Rule 17: If You Can’t Test It, It’s Not Done

Correctness that cannot be proven is optimism.
Production systems do not run on optimism.

SQL is code. Code without tests is a hypothesis, not an asset.

### The Principle

**Every critical SQL asset must be testable.**

If behavior cannot be validated with known inputs and known outputs, the logic is unfinished.

### Known Input, Known Output

Tests define truth explicitly.

* Fixed input datasets
* Deterministic execution
* Expected outputs written down

If the expected result is unclear, the business rule is unclear.

### Edge Cases Are Part of the Contract

Edge cases are not optional.

* Nulls
* Boundary dates
* Zero counts
* Missing relationships
* Unexpected categories

If edge cases are not tested, they are guaranteed to fail in production.

### Failure Cases Must Be Validated

Failure behavior matters as much as success.

* Constraint violations
* Empty inputs
* Partial source availability
* Retry scenarios

If failure paths are untested, they are undefined behavior.

### Why Untested SQL Is Dangerous

Untested SQL:

* Breaks silently
* Regresses during refactors
* Produces inconsistent metrics
* Surprises during audits

The absence of tests turns every change into a gamble.

### Design Standard

A SQL asset is production-ready only if:

* Inputs are controlled and reproducible
* Outputs are deterministic and asserted
* Edge cases are documented and tested
* Failure modes are validated

If testing is “manual verification”, the system is not safe.

### Code Review Test

Before approving SQL, ask:

* What test proves this is correct?
* What test proves it fails safely?
* What test detects regression?

If no test exists, the work is not complete.

### Closing Statement

Working once is coincidence.
Working always is design.

If you cannot test it, it is not done.

This completes the manifesto.

