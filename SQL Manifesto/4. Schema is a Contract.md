## Data Engineering Manifesto

### Rule 4: Schema Is a Contract

A schema is not a convenience. It is a promise.
The moment a schema is published, it becomes an interface that other systems, reports, and people depend on.

Schemas are public APIs. Treating them like scratchpads turns downstream trust into technical debt.

### The Principle

**Schemas define contracts, not storage.**

Once a schema is exposed, every column, name, type, and constraint carries meaning. That meaning must remain stable unless the contract is intentionally renegotiated.

### No Silent Column Changes

A column name is not cosmetic.

* Renaming a column without versioning breaks consumers
* Reordering columns breaks brittle integrations
* Changing nullability alters assumptions

If a column must change, the change must be explicit, communicated, and versioned. Silence is not backward compatibility.

### No Type Weakening

Types encode intent.

* Integers do not become strings
* Dates do not become timestamps casually
* Booleans do not become enums by accident

Weakening a type removes guarantees and pushes ambiguity downstream. It shifts validation from the data layer to every consumer, multiplying risk.

Once a type is published, it is law.

### No Reused Columns With New Meanings

Reusing a column name for a different concept is data corruption disguised as efficiency.

* Old dashboards show new semantics
* Historical data becomes misleading
* Backfills become impossible to reason about

If the meaning changes, the column must change. New meaning requires a new name.

### Breaking Changes Are Real Changes

Breaking a schema is a breaking change.

There is no such thing as a “small” schema break. Every downstream failure traces back to this moment.

Breaking changes require:

* Versioned schemas
* Parallel support windows
* Clear deprecation timelines
* Explicit migration paths

Anything less is operational negligence.

### Why This Rule Exists

Schemas outlive code.

Queries change. Dashboards evolve. People rotate. Schemas remain. When meaning drifts, institutional knowledge decays faster than documentation can compensate.

Stable schemas preserve institutional memory.

### Design Standard

A schema change is acceptable only if:

* Backward compatibility is preserved, or
* A new version is introduced, or
* All consumers are migrated intentionally

If none of these are true, the change is not allowed.

### Code Review Test

Before approving a schema change, ask:

* Would an existing consumer break?
* Would historical queries change meaning?
* Would this require explanation in a postmortem?

If the answer is yes, the change is breaking and must be treated as such.

### Closing Statement

Code can be rewritten.
Data lives forever.

A schema is a promise. Break it only when you are prepared to own the consequences.
