## Data Engineering Manifesto

### Rule 3: Determinism Over Cleverness

Clever code is entertaining. Deterministic code is trustworthy.
In data systems, trust always wins.

SQL is not a suggestion engine. It is a contract. Given the same input, it must produce the same output every time, regardless of load, timing, or execution strategy. If the result can change without the data changing, the logic is broken.

### The Principle

SQL must be **deterministic by design**.

* Same input
* Same logic
* Same output
* Every run

Anything else is accidental behavior disguised as intelligence.

### The Explicit Assumption

**ASSUMPTION: Parallel execution exists.**

This assumption is necessary because all enterprise-grade databases execute queries concurrently. Query planners reorder operations. Engines parallelize scans, joins, and aggregations. Execution timing is not stable, and it is not controllable.

If your logic only works when execution is sequential, it does not work.

### No Reliance on Unordered Results

Unordered data has no natural order.

* A `SELECT` without `ORDER BY` has no guaranteed sequence
* Physical storage order is irrelevant
* Execution plans can change between runs

If the logic assumes “first row”, “last row”, or “current row” without an explicit ordering, the result is undefined.

Undefined behavior is not an edge case. It is a bug.

### No Ambiguous Joins

Every join must be intentional and unambiguous.

* Join keys must be unique or intentionally many-to-one
* Cardinality must be understood and enforced
* Accidental many-to-many joins are forbidden

If a join can multiply rows unexpectedly, the query is not deterministic. It may appear correct on small data and fail catastrophically at scale.

Correct joins are not clever. They are explicit.

### No Logic That Depends on Execution Timing

Time is not a stable dependency inside a query.

* Do not rely on evaluation order
* Do not assume subqueries execute before outer logic
* Do not depend on side effects or planner quirks

Parallel engines are free to evaluate expressions in any order that preserves relational correctness. If your logic assumes a specific sequence, the engine is allowed to break it.

And eventually, it will.

### Why Cleverness Fails at Scale

Clever SQL often relies on:

* Implicit ordering
* Accidental short-circuiting
* Planner behavior observed once and trusted forever

This works until:

* Data volume increases
* Statistics change
* Indexes are added or removed
* The engine version upgrades

Then the query still runs, but the truth changes.

### Determinism as a Design Standard

Deterministic SQL:

* Is boring to read
* Is explicit about intent
* Survives refactoring
* Survives optimization
* Survives scale

If removing a hint, index, or parallelism setting changes the result, the query was never correct.

### Code Review Test

A simple test defines determinism:

“If I run this query tomorrow, under load, on a larger dataset, will I get the same result?”

If the answer is “probably”, the logic is not finished.

### Closing Statement

Cleverness optimizes for admiration.
Determinism optimizes for truth.

In enterprise systems, truth is the only acceptable outcome.
