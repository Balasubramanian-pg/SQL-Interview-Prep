## Data Engineering Manifesto

### Rule 6: Idempotency Is Mandatory

Production systems do not get one clean run.
They get retries, restarts, replays, rollbacks, partial failures, and human panic.

Idempotency is how systems remain correct when reality is noisy.

### The Principle

**All SQL scripts and data-changing operations must be safe to run multiple times.**

Running the same script again must not:

* Duplicate data
* Corrupt state
* Drift metrics
* Change meaning

If execution count changes outcomes, the system is fragile.

### Why This Rule Exists

Failure is normal. Retries are inevitable.

* Jobs fail mid-run
* Pipelines restart automatically
* Backfills are rerun
* Disaster recovery replays history
* Humans press “run” twice

Idempotency turns all of this from danger into routine.

Without idempotency, recovery requires memory, coordination, and luck. None of these scale.

### Create With Intent, Not Hope

Use constructs that declare desired state, not actions.

* Prefer `CREATE OR REPLACE` over `CREATE`
* Prefer `MERGE` over blind inserts
* Prefer declarative rebuilds over incremental hacks

The goal is convergence. No matter how many times the script runs, the result should settle into the same correct state.

### Guard Every Insert

Inserts must defend against duplication.

* Use natural keys where they exist
* Use surrogate keys with enforced uniqueness
* Use hashes when business keys are complex
* Validate cardinality explicitly

An insert that assumes “this will only run once” is a future incident.

### Execution Count Must Be Irrelevant

Correctness must not depend on:

* How many times a job ran
* Whether a previous run partially succeeded
* Whether a retry started from the middle
* Whether a human intervened

If a script needs manual cleanup before rerun, it is not production-ready.

### Avoid Side Effects

Side effects accumulate silently.

* Incremental counters without guards
* Appending without deduplication
* Updates based on current state without anchors

Side effects turn retries into corruption. Deterministic outcomes require stable inputs and stable logic.

### Idempotency Enables Recovery

Idempotent design makes the following safe by default:

* Disaster recovery
* Full reprocessing
* Historical backfills
* Schema migrations
* Data corrections

If recovery requires special scripts or one-off logic, the system is already in debt.

### Design Standard

A script is idempotent if:

* It can be run twice with no change in result
* It can be run after partial failure safely
* It can be rerun days later without context
* It requires no manual intervention

If any of these fail, the design is incomplete.

### Code Review Test

Before approving any SQL asset, ask:

* What happens if this runs again?
* What happens if it fails halfway?
* What happens if it is replayed next month?

If the answer is “don’t do that”, the code is not ready.

### Closing Statement

Production is not a clean room.
It is a battlefield of retries and replays.

Idempotency is how correctness survives chaos.
