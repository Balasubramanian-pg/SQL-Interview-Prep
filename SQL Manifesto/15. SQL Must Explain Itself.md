## Data Engineering Manifesto

### Rule 15: SQL Must Explain Itself

Code is read far more often than it is written.
SQL that cannot be understood cannot be trusted.

Production SQL is not a puzzle. It is an artifact that must survive audits, handovers, incidents, and time.

### The Principle

**Readable SQL is a production requirement.**

If logic cannot be explained by the SQL itself, it does not belong in production.

### Clear Naming Is Non-Negotiable

Names encode intent.

* Tables describe what they store, not how they are built
* Columns describe meaning, not origin
* Aliases are readable, not clever

If a reader must decode abbreviations or tribal naming conventions, the design has already failed.

### Logical CTE Structure

CTEs are chapters, not clutter.

* One logical step per CTE
* Meaningful CTE names
* Ordered from raw data to final output

CTEs should tell a story. If the story is unclear, the SQL is unfinished.

### Comments Explain Why, Not What

SQL already shows what happens. Comments explain why it happens.

* Why a filter exists
* Why a join is left instead of inner
* Why a rule is implemented this way
* Why an edge case is handled

Comments that restate the code add noise. Comments that explain intent add resilience.

### Why Readability Matters Operationally

Unreadable SQL:

* Fails audits
* Slows incident response
* Breaks onboarding
* Encourages copy-paste errors

Readable SQL is self-documenting infrastructure.

### Design Standard

SQL is acceptable only if:

* A new engineer can understand it
* A future you can explain it
* An auditor can trace logic
* A reviewer can reason about correctness

If explanation requires oral history, the code is fragile.

### Code Review Test

Before approving SQL, ask:

* Can I explain this without running it?
* Is the intent obvious?
* Would this survive ownership transfer?

If the answer is no, rewrite it.

### Closing Statement

Machines execute SQL.
Humans maintain it.

SQL that cannot explain itself will eventually explain itself through failure.
