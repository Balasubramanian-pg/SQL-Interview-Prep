## Data Engineering Manifesto

### Rule 5: Constraints Over Trust

Trust is not a control mechanism.
Constraints are.

In a data system, every unchecked assumption eventually becomes corrupted data. Humans make mistakes. Applications change. Pipelines evolve. Constraints exist because trust does not scale.

### The Principle

**Rules must be enforced at the database level.**

If a rule matters, the database must enforce it.
If the database does not enforce it, the rule is optional in practice.

Application-only validation is insufficient by design.

### Why Trust Fails

Relying on applications to enforce correctness assumes:

* Every write path is known
* Every client behaves correctly
* Every future change preserves intent
* Every integration follows the same rules

These assumptions never hold in enterprise systems.

Databases outlive applications. Constraints preserve truth across time.

### Primary Keys Are Identity

A primary key is not just a technical requirement. It is identity.

* Every row must be uniquely identifiable
* Duplicate records are logical corruption
* Identity ambiguity destroys joins and metrics

If a table does not have a primary key, it is not a table. It is a file.

### Foreign Keys Are Meaning

Foreign keys encode relationships that the business depends on.

* Orphaned records are invalid states
* Broken relationships invalidate analytics
* Referential integrity is not optional documentation

If two tables are logically related but not enforced, the relationship is a rumor, not a fact.

### Check Constraints Are Business Rules

Check constraints protect domain logic at the lowest level.

* Valid ranges
* Allowed states
* Mutually exclusive conditions
* Invariants that must never break

If a value should never exist, the database must reject it. Allowing invalid data with the intention to “fix it later” guarantees it will persist.

### Not Null Constraints Are Guarantees

Null is not neutral. It is absence.

* Required attributes must be enforced
* Optionality must be explicit
* Meaningful data must exist when required

If a column is essential to interpretation, nullability is a violation of contract.

### Why Application-Only Validation Is Insufficient

Application logic is:

* Bypassed by other tools
* Rewritten over time
* Inconsistently implemented
* Invisible to downstream consumers

The database is the final gate. If invalid data passes through it, the system has already failed.

### Design Standard

A rule must be enforced in the database if:

* Violating it would break reports
* Violating it would mislead decisions
* Violating it would require cleanup
* Violating it would appear in a postmortem

If the answer is yes, the rule belongs in a constraint.

### Common Anti-Patterns to Reject

* “The app guarantees uniqueness”
* “We validate before insert”
* “This table is internal”
* “We will clean it up later”

These are not safeguards. They are deferred failures.

### Code Review Test

Before approving a table or change, ask:

* What invalid data is this allowing?
* Who is responsible for preventing it?
* What happens if that prevention fails?

If the database is not the answer, the design is incomplete.

### Closing Statement

Trust is a human value.
Constraints are an engineering requirement.

In data systems, correctness is enforced, not hoped for.
