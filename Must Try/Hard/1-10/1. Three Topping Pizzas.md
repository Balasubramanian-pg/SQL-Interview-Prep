# 3-Topping Pizza Combinations

> **Date**: 2025-07-30  
> **Difficulty**: Hard

## 1. Problem Statement
You’re a consultant for a major pizza chain that will be running a promotion where all 3-topping pizzas will be sold for a fixed price, and are trying to understand the costs involved.

> [!NOTE]
> The business context is a fixed-price promotion. Understanding the ingredient cost for each combination is crucial for profitability analysis and deciding if the promotion is viable.

Given a list of pizza toppings, consider all the possible 3-topping pizzas, and print out the total cost of those 3 toppings. Sort the results with the highest total cost on the top followed by pizza toppings in ascending order.

Break ties by listing the ingredients in alphabetical order, starting from the first ingredient, followed by the second and third.

> [!IMPORTANT]
> A critical requirement is the tie-breaking logic: if two pizza combinations have the same total cost, they must be ordered alphabetically by the full pizza name (e.g., 'Chicken,Extra Cheese,Sausage' comes before 'Extra Cheese,Pepperoni,Sausage').

**Notes:**
- Do not display pizzas where a topping is repeated. For example, ‘Pepperoni,Pepperoni,Onion Pizza’.
- Ingredients must be listed in alphabetical order. For example, 'Chicken,Onions,Sausage'. 'Onion,Sausage,Chicken' is not acceptable.

### 1.1. Input Table: `pizza_toppings`

|**Column Name**|**Type**|
|---|---|
|topping_name|varchar(255)|
|ingredient_cost|decimal(10,2)|

### 1.2. Example

#### 1.2.1. `pizza_toppings` Example Input:

|**topping_name**|**ingredient_cost**|
|---|---|
|Pepperoni|0.50|
|Sausage|0.70|
|Chicken|0.55|
|Extra Cheese|0.40|

#### 1.2.2. Example Output:

|**pizza**|**total_cost**|
|---|---|
|Chicken,Pepperoni,Sausage|1.75|
|Chicken,Extra Cheese,Sausage|1.65|
|Extra Cheese,Pepperoni,Sausage|1.60|
|Chicken,Extra Cheese,Pepperoni|1.45|

> [!NOTE]
> The dataset you are querying against may have different input & output - this is just an example to illustrate the required format and logic.

#### 1.2.3. Explanation

There are four different combinations of the three toppings. Cost of the pizza with toppings Chicken, Pepperoni and Sausage is $0.55 + $0.50 + $0.70 = $1.75.

Additionally, they are arranged alphabetically; in the dictionary, the chicken comes before pepperoni and pepperoni comes before sausage.

## 2. Solution Approaches
To solve this problem, we need to generate all possible combinations of 3 distinct pizza toppings, calculate their total cost, and then sort the results based on the total cost in descending order. If there are ties in the total cost, we sort the toppings in alphabetical order.

### 2.1. Solution 1: Using Self-Joins
This is the most direct and often most performant method for a fixed number of combinations.

```sql
WITH combinations AS (
    SELECT
        t1.topping_name AS topping1,
        t2.topping_name AS topping2,
        t3.topping_name AS topping3,
        t1.ingredient_cost + t2.ingredient_cost + t3.ingredient_cost AS total_cost
    FROM
        pizza_toppings t1
    CROSS JOIN
        pizza_toppings t2
    CROSS JOIN
        pizza_toppings t3
    WHERE
        t1.topping_name < t2.topping_name AND
        t2.topping_name < t3.topping_name
)
SELECT
    CONCAT(topping1, ',', topping2, ',', topping3) AS pizza,
    total_cost
FROM
    combinations
ORDER BY
    total_cost DESC,
    topping1 ASC,
    topping2 ASC,
    topping3 ASC;
```

#### 2.1.1. Explanation

> [!TIP]
> Using a Common Table Expression (CTE) like `combinations` helps to logically separate the combination generation from the final formatting and ordering, making the query easier to read and maintain.

1.  **Combinations CTE**:
    - We use a self-cross join three times to generate all possible pairings of three toppings from the same table.
    - The `WHERE` clause is the most important part of this solution. The condition `t1.topping_name < t2.topping_name AND t2.topping_name < t3.topping_name` cleverly handles two requirements at once:
        - It ensures all three toppings are **distinct** (a name cannot be less than itself).
        - It generates only **unique combinations** in a pre-sorted, alphabetical order (e.g., it will generate 'Chicken,Pepperoni,Sausage' but will prevent permutations like 'Pepperoni,Chicken,Sausage').

> [!WARNING]
> Be cautious with `CROSS JOIN`. It produces a Cartesian product, meaning the number of intermediate rows can grow exponentially. For a table with `N` toppings, a 3-way cross join produces `N*N*N` rows before the `WHERE` clause filters them. This can be very resource-intensive on large tables.

2.  **Main Query**:
    - We use `CONCAT` to combine the three topping names into the required 'pizza' string format.
    - The `ORDER BY` clause first sorts by `total_cost` in descending order. For any ties, it sorts by `topping1`, then `topping2`, then `topping3` in ascending order, fulfilling the tie-breaker rule.

### 2.2. Solution 2: Using a Recursive CTE
Another way to approach this is with a recursive CTE. This method is more complex for a fixed number of combinations but is more flexible if the number of toppings were a variable (e.g., finding all 4-topping or 5-topping pizzas).

> [!NOTE]
> The `RECURSIVE` keyword is standard in SQL but syntax can vary. For instance, SQL Server does not require the `RECURSIVE` keyword; a CTE is implicitly recursive if it references itself.

```sql
WITH RECURSIVE topping_combinations AS (
    -- Anchor Member (Base Case): Start with each individual topping.
    SELECT
        1 AS level,
        CAST(topping_name AS VARCHAR(1000)) AS pizza,
        topping_name AS last_topping,
        ingredient_cost AS total_cost
    FROM
        pizza_toppings

    UNION ALL

    -- Recursive Member: Add a new topping to existing combinations.
    SELECT
        tc.level + 1,
        CAST(tc.pizza || ',' || pt.topping_name AS VARCHAR(1000)),
        pt.topping_name,
        tc.total_cost + pt.ingredient_cost
    FROM
        topping_combinations tc
    JOIN
        pizza_toppings pt ON pt.topping_name > tc.last_topping
    WHERE
        tc.level < 3
)
SELECT
    pizza,
    total_cost
FROM
    topping_combinations
WHERE
    level = 3
ORDER BY
    total_cost DESC,
    pizza ASC;
```

#### 2.2.1. Explanation

> [!WARNING]
> While powerful, recursive queries can be harder to debug and may perform worse than simple joins for fixed-depth problems like this one. Always evaluate if the added complexity is necessary for your use case.

1.  **Base Case (Anchor Member)**:
    - The recursion starts by selecting each topping individually. This forms our initial set of 1-topping combinations. We initialize a `level` counter to 1 and track the `last_topping` added.

2.  **Recursive Case (Recursive Member)**:
    - This part references the CTE itself. It joins existing combinations (`tc`) with the `pizza_toppings` table (`pt`) again.
    - The `ON pt.topping_name > tc.last_topping` condition is key: it ensures that we only add toppings that are alphabetically after the last one added, which prevents duplicates and non-alphabetical combinations.
    - The `WHERE tc.level < 3` clause acts as a termination condition, stopping the recursion once 3-topping combinations have been built.

> [!TIP]
> This recursive structure is highly adaptable. If the business wanted to analyze 4-topping pizzas, you would only need to change the `WHERE` clause condition from `tc.level < 3` to `tc.level < 4` and the final filter to `level = 4`.

3.  **Main Query**:
    - After the recursion completes, we select only the rows `WHERE level = 3` to get our final 3-topping pizzas.
    - The results are ordered identically to the first solution: by `total_cost` descending, and then by the full `pizza` name ascending to break ties.
