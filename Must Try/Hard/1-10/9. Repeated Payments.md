# Identifying Repeated Payments

## 1. Problem Statement

### 1.1. Objective
Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure, or a retry error that causes a credit card to be charged twice.

Using the `transactions` table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other. Count the total number of such repeated payments.

> [!IMPORTANT]
> A transaction is considered a "repeat" only if it matches a preceding transaction on three key criteria: `merchant_id`, `credit_card_id`, and `amount`, and occurs within a 10-minute time window.

### 1.2. Assumptions
-   The first transaction of a potential series of repeated payments should **not** be counted as a repeated payment itself. For example, if two identical transactions occur 8 minutes apart, there is only **1** repeated payment (the second one).

> [!NOTE]
> This assumption is critical and directly influences the choice of a window function like `LAG()`, which is designed to look at the *previous* row in a sequence.

### 1.3. Input Table: `transactions`

|**Column Name**|**Type**|
|---|---|
|transaction_id|integer|
|merchant_id|integer|
|credit_card_id|integer|
|amount|integer|
|transaction_timestamp|datetime|

### 1.4. Example

#### 1.4.1. `transactions` Example Input:

|**transaction_id**|**merchant_id**|**credit_card_id**|**amount**|**transaction_timestamp**|
|---|---|---|---|---|
|1|101|1|100|09/25/2022 12:00:00|
|2|101|1|100|09/25/2022 12:08:00|
|3|101|1|100|09/25/2022 12:28:00|
|4|102|2|300|09/25/2022 12:00:00|
|6|102|2|400|09/25/2022 14:00:00|

#### 1.4.2. Example Output:
|payment_count|
|---|
|1|

#### 1.4.3. Explanation
Transaction 2 is a repeat of Transaction 1 because it occurred at the same merchant (101), with the same credit card (1), for the same amount (100), and happened only 8 minutes later. Transaction 3 is not a repeat of Transaction 2 because it occurred 20 minutes later, which is outside the 10-minute window. Transactions 4 and 6 are not repeats of each other because they have different amounts.

## 2. Conceptual Approach
The core of this problem is to compare each transaction with the one that immediately preceded it, but only if they are for the same merchant, card, and amount. This is a perfect use case for the `LAG()` window function.

1.  **Group Similar Transactions**: We first need to define groups of "like" transactions. A group consists of all transactions sharing the same `merchant_id`, `credit_card_id`, and `amount`.
2.  **Order Transactions Chronologically**: Within each of these groups, we must order the transactions by their `transaction_timestamp` to establish a clear sequence.
3.  **Find the Previous Timestamp**: For each transaction, we'll use `LAG()` to fetch the timestamp of the immediately preceding transaction within its group. The very first transaction in any group will have a `NULL` previous timestamp.
4.  **Filter for Repeats**: Finally, we filter this result set to keep only the rows that represent a repeated payment. A row is a repeat if:
    -   It has a non-`NULL` previous transaction time (i.e., it's not the first one in its group).
    -   Its own timestamp is within 10 minutes of its previous transaction's timestamp.
5.  **Count the Results**: The total count of these filtered rows is our answer.

> [!TIP]
> The `LAG()` function is purpose-built for this type of sequential analysis. It allows you to "peek" at a value from a previous row in an ordered partition of your data, all without resorting to complex and inefficient self-joins.

## 3. SQL Solution

```sql
WITH ranked_transactions AS (
  SELECT
    transaction_timestamp,
    LAG(transaction_timestamp) OVER (
      PARTITION BY merchant_id, credit_card_id, amount
      ORDER BY transaction_timestamp
    ) AS prev_transaction_time
  FROM transactions
)
SELECT
  COUNT(*) AS payment_count
FROM ranked_transactions
WHERE prev_transaction_time IS NOT NULL
  AND transaction_timestamp <= prev_transaction_time + INTERVAL '10 minutes';
```

## 4. Code Breakdown

### 4.1. CTE: `ranked_transactions`
This Common Table Expression is the engine of the solution. It prepares the data by finding the previous transaction time for each potential repeat.

-   `LAG(transaction_timestamp) OVER (...)`: This function retrieves the value of `transaction_timestamp` from the previous row.
-   `PARTITION BY merchant_id, credit_card_id, amount`: This is a crucial instruction. It tells the `LAG()` function to operate in separate "windows" or groups. The function will only look at previous rows that have the exact same merchant, card, and amount. When any of these values change, a new partition begins, and `LAG()` resets.

> [!IMPORTANT]
> The `PARTITION BY` clause is what ensures we are only comparing like-for-like transactions. Without it, the query would incorrectly compare a transaction for merchant 101 with a completely unrelated transaction for merchant 102.

-   `ORDER BY transaction_timestamp`: This defines the sequence within each partition. It sorts the transactions chronologically, ensuring that "previous" truly means the one that happened right before.

> [!NOTE]
> The `ORDER BY` clause inside the `OVER()` block is mandatory for `LAG()` to work logically. It establishes the row order from which `LAG()` can determine what the "previous" row is.

### 4.2. Final `SELECT` Statement
The main query filters the results from the CTE and performs the final count.

-   `WHERE prev_transaction_time IS NOT NULL`: This simple filter is key to satisfying the main assumption. The first transaction in any partition will have a `NULL` value for `prev_transaction_time` (since there's no row before it), so this condition effectively excludes all original transactions from being counted as repeats.
-   `AND transaction_timestamp <= prev_transaction_time + INTERVAL '10 minutes'`: This is the time-window logic. It checks if the current transaction's timestamp is less than or equal to the previous transaction's timestamp plus 10 minutes.

> [!WARNING]
> The syntax for date/time arithmetic, specifically `INTERVAL '10 minutes'`, is standard in SQL dialects like PostgreSQL. Other databases like SQL Server (`DATEADD(minute, 10, prev_transaction_time)`) or MySQL have different syntax. Be mindful of the specific SQL dialect you are using.

-   `COUNT(*) AS payment_count`: This simply counts all the rows that passed both filtering conditions, giving the final number of repeated payments.
