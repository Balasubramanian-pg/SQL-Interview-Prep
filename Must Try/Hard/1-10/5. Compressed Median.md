# Mean Items Per Order

## 1. Problem Statement

### 1.1. Objective
You're trying to find the mean number of items per order on Alibaba, rounded to 1 decimal place. The data is provided in a pre-aggregated format, with one table listing the distinct item counts per order and how many orders occurred for each count.

> [!NOTE]
> This problem is a classic example of calculating a **weighted average**. You cannot simply take the average of the `item_count` column because each item count has a different frequency (weight), represented by `order_occurrences`.

### 1.2. Input Table: `items_per_order`

|Column Name|Type|
|---|---|
|item_count|integer|
|order_occurrences|integer|

### 1.3. Example

#### 1.3.1. `items_per_order` Example Input:

|item_count|order_occurrences|
|---|---|
|1|500|
|2|1000|
|3|800|
|4|1000|

#### 1.3.2. Example Output:

|mean|
|---|
|2.7|

## 2. Conceptual Approach
The mean number of items per order is calculated using the formula for a weighted average:

`Mean = (Total Number of All Items) / (Total Number of All Orders)`

> [!IMPORTANT]
> A common mistake would be to calculate `AVG(item_count)`, which would give `(1+2+3+4)/4 = 2.5`. This is incorrect because it treats each `item_count` value as having equal importance, ignoring that there were far more orders with 2 items than with 1.

Using the example data, the calculation is as follows:

1.  **Calculate the Total Number of All Items:**
    -   `(1 item/order * 500 orders) + (2 items/order * 1000 orders) + (3 items/order * 800 orders) + (4 items/order * 1000 orders)`
    -   `500 + 2000 + 2400 + 4000 = 8900` total items.

2.  **Calculate the Total Number of All Orders:**
    -   `500 + 1000 + 800 + 1000 = 3300` total orders.

3.  **Calculate the Mean:**
    -   `8900 / 3300 â‰ˆ 2.6969...`
    -   Rounded to one decimal place, the mean is `2.7`.

> [!TIP]
> This mathematical logic translates directly into SQL using aggregate functions. The "Total Items" becomes the numerator, and "Total Orders" becomes the denominator.

## 3. SQL Solution
To get the mean number of items per order from the `items_per_order` table, you can use the following SQL query:

```sql
SELECT 
  ROUND(SUM(item_count * order_occurrences) * 1.0 / SUM(order_occurrences), 1) AS mean
FROM 
  items_per_order;
```
> [!NOTE]
> This query is highly efficient because it operates on a small, pre-aggregated table. It performs a single scan of the table to compute both sums.

## 4. Code Breakdown
Let's dissect the query to understand how each part contributes to the final result.

### 4.1. Numerator: `SUM(item_count * order_occurrences)`
This part calculates the total number of all items sold across all orders.
-   `item_count * order_occurrences`: For each row, this multiplication calculates the total number of items for that specific group. For the second row in the example, it's `2 * 1000 = 2000` items.
-   `SUM(...)`: This function then adds up these sub-totals from all rows to get the grand total number of items (`8900` in the example).

> [!TIP]
> This expression, `SUM(value * weight)`, is the standard SQL pattern for calculating the numerator of any weighted average.

### 4.2. Denominator: `SUM(order_occurrences)`
This part is simpler; it calculates the total number of orders.
-   `SUM(order_occurrences)`: This adds up all the values in the `order_occurrences` column, giving the grand total of all orders placed (`3300` in the example).

> [!CAUTION]
> Do not use `COUNT(*)` or `COUNT(order_occurrences)` here. `COUNT` would return `4` (the number of rows in the example table), which is not the total number of orders. You need `SUM` to get the true total.

### 4.3. The Division and Data Type Conversion: `* 1.0 / ...`
This is where the mean is calculated, with a critical step for ensuring accuracy.
-   The `/` operator performs the division of the total items by the total orders.
-   `* 1.0`: This is a crucial trick to force **floating-point division**.

> [!WARNING]
> In many SQL dialects (like SQL Server or PostgreSQL), dividing an integer by an integer results in another integer (e.g., `8900 / 3300` would result in `2`). The decimal part is truncated. Multiplying the numerator by a float like `1.0` promotes it to a floating-point number, ensuring the division retains the decimal places needed for rounding.

> [!TIP]
> An alternative to `* 1.0` is to explicitly `CAST` one of the numbers. For example: `CAST(SUM(item_count * order_occurrences) AS DECIMAL) / SUM(order_occurrences)`. The `* 1.0` method is just a common and concise shorthand.

### 4.4. Final Formatting: `ROUND(..., 1) AS mean`
This final part formats the output to meet the requirements.
-   `ROUND(..., 1)`: This function takes the calculated mean and rounds it to one decimal place.
-   `AS mean`: This is an alias that renames the resulting column to `mean`, as specified in the example output.

> [!IMPORTANT]
> The entire query is a single aggregation that operates over the whole table. Because we need one single value for the entire dataset, no `GROUP BY` clause is necessary.
