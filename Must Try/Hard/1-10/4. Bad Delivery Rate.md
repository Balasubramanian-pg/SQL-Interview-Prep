# Bad Experience Rate for New Customers

## 1. The Business Question
The objective of this query is to answer the following business question:

**"For customers who signed up in June 2022, what was the percentage of 'bad experiences' on orders they placed within their first 14 days?"**

> [!IMPORTANT]
> A 'bad experience' is specifically defined as any order where the `status` was not `'completed successfully'`. This includes cancellations, returns, transit issues, etc.

## 2. Assumed Table Schema
The query joins two tables, `customers` and `orders`. A plausible schema for these tables that supports the query logic is detailed below.

> [!NOTE]
> Since an exact schema was not provided, we are assuming a standard structure. The column names and data types are chosen to be representative of a typical e-commerce database.

```sql
-- Table: customers
-- Stores information about each customer.
CREATE TABLE customers (
    customer_id      INT PRIMARY KEY,
    customer_name    VARCHAR(255),
    signup_timestamp TIMESTAMP NOT NULL -- The exact date and time the customer registered
);

-- Table: orders
-- Stores a record for every order placed by a customer.
CREATE TABLE orders (
    order_id         INT PRIMARY KEY,
    customer_id      INT NOT NULL,
    status           VARCHAR(50) NOT NULL, -- e.g., 'completed successfully', 'cancelled', 'in transit'
    order_timestamp  TIMESTAMP NOT NULL,   -- The date and time the order was placed
    order_value      DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

> [!TIP]
> Indexes are crucial for the performance of this type of query, especially on large tables. An index on `customers(signup_timestamp)` and `orders(customer_id)` would significantly speed up the join and filtering operations.
>
> `CREATE INDEX idx_customers_signup ON customers (signup_timestamp);`
>
> `CREATE INDEX idx_orders_customer ON orders (customer_id);`

## 3. Solution Approaches

### 3.1. Method 1: Using a Common Table Expression (CTE)
This approach breaks the problem into two distinct, logical steps: first isolating the relevant data, and then performing the final calculation.

> [!NOTE]
> The CTE method is highly favored for its readability and maintainability. It allows a complex query to be written like a story, where each step builds upon the previous one.

```sql
WITH order_details AS (
    -- Step 1: Isolate all orders from customers who signed up in June 2022
    SELECT
        o.order_id,
        o.status,
        o.order_timestamp,
        c.signup_timestamp
    FROM
        orders AS o
    INNER JOIN
        customers AS c ON o.customer_id = c.customer_id
    WHERE
        EXTRACT(YEAR FROM c.signup_timestamp) = 2022
        AND EXTRACT(MONTH FROM c.signup_timestamp) = 6
)
-- Step 2: From that subset, calculate the failure rate for orders in the first 14 days
SELECT
    ROUND(
        100.0 *
        SUM(CASE WHEN status = 'completed successfully' THEN 0 ELSE 1 END) /
        COUNT(DISTINCT order_id),
        2
    ) AS bad_experience_pct
FROM
    order_details
WHERE
    DATE(order_timestamp) <= DATE(signup_timestamp) + INTERVAL '14 day';
```

#### 3.1.1. Explanation of the CTE Query

1.  **The `order_details` CTE**:
    -   It begins by performing an `INNER JOIN` to link every order to its corresponding customer.
    -   The `WHERE` clause then filters this joined dataset to retain only the records belonging to customers who signed up in June 2022.
    -   The result is a temporary table named `order_details` containing all orders placed by this specific customer cohort.

2.  **The Final Calculation**:
    -   The main query operates on the pre-filtered `order_details` CTE.
    -   It applies a second crucial filter: `WHERE DATE(order_timestamp) <= DATE(signup_timestamp) + INTERVAL '14 day'`. This narrows the dataset down to only those orders placed within the first 14 days of a customer's signup.
    -   The final percentage is calculated:
        -   **Numerator**: `SUM(CASE WHEN status = 'completed successfully' THEN 0 ELSE 1 END)` counts the number of "bad experience" orders.
        -   **Denominator**: `COUNT(DISTINCT order_id)` counts the total number of unique orders in this 14-day window.

> [!WARNING]
> Multiplying by `100.0` instead of `100` is a common and important practice in SQL. It forces the database to perform floating-point division, preventing integer truncation which would result in an incorrect percentage (often 0).

### 3.2. Method 2: Single Combined Query
This method achieves the same result without a CTE by combining all filtering and aggregation logic into a single query block.

> [!NOTE]
> While potentially less readable for complex logic, a single query can sometimes allow the database's query optimizer more flexibility to generate an efficient execution plan.

```sql
SELECT
    ROUND(
        100.0 *
        SUM(CASE WHEN o.status = 'completed successfully' THEN 0 ELSE 1 END) /
        COUNT(DISTINCT o.order_id),
        2
    ) AS bad_experience_pct
FROM
    orders AS o
INNER JOIN
    customers AS c ON o.customer_id = c.customer_id
WHERE
    c.signup_timestamp >= '2022-06-01'
    AND c.signup_timestamp < '2022-07-01'
    AND o.order_timestamp < c.signup_timestamp + INTERVAL '14 day';
```

#### 3.2.1. Explanation of the Alternative Query
1.  **Combined `WHERE` Clause**: All conditions are evaluated together.
2.  **SARGable Predicate**: The condition `c.signup_timestamp >= '2022-06-01' AND c.signup_timestamp < '2022-07-01'` is a more efficient way to filter for June 2022 signups compared to using the `EXTRACT` function.

> [!IMPORTANT]
> A condition is **SARGable** (Search ARGument Able) if it allows the database engine to use an index to find the data. Applying functions like `EXTRACT` or `DATE` to an indexed column (`c.signup_timestamp` in this case) often prevents the index from being used, forcing a full table scan. Direct range comparisons are almost always more performant.

## 4. Comparison of Methods

-   **CTE Method**: Superior for readability, debugging, and logical separation. It's easier to understand the multi-step process.
-   **Single Query Method**: Can be more performant due to the use of SARGable predicates and giving the query optimizer full visibility of all constraints at once.

> [!TIP]
> For ad-hoc analysis or complex reports, start with the CTE method for clarity. If the query becomes a bottleneck in a production environment, refactor it into a single query using SARGable predicates to optimize for performance.
