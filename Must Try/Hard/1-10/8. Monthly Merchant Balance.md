# Daily Cumulative Running Balance

## 1. The Business Question
The objective of this query is to answer the following business question:

**"What is the daily cumulative running balance for each month? The balance should be calculated based on the net of all deposits and withdrawals, and it should reset at the beginning of each new month."**

> [!NOTE]
> The title "monthly merchant balance" suggests a per-merchant calculation. However, the query as written calculates a single, aggregate balance for the entire system. To make it per-merchant, a `merchant_id` would need to be added to the `GROUP BY` and `PARTITION BY` clauses.

## 2. Assumed Table Schema
The query references a single table, `transactions`. A plausible schema for this financial table would be:

```sql
-- Table: transactions
-- Stores a record for every deposit or withdrawal transaction.
CREATE TABLE transactions (
    transaction_id   BIGINT PRIMARY KEY,
    merchant_id      INT,                      -- ID of the merchant (for a per-merchant version)
    transaction_date TIMESTAMP NOT NULL,       -- The exact date and time of the transaction
    type             VARCHAR(20) NOT NULL,     -- The type of transaction, e.g., 'deposit', 'withdrawal'
    amount           DECIMAL(12, 2) NOT NULL   -- The absolute value of the transaction amount
);
```
> [!TIP]
> An index on the `transaction_date` column is critical for the performance of this query, as all filtering and grouping operations are based on this column.
>
> `CREATE INDEX idx_transactions_date ON transactions (transaction_date);`

## 3. Solution Approaches

### 3.1. Method 1: Multi-Step CTEs for Clarity
This approach is excellent for its readability, breaking down the problem into three distinct, logical steps.

> [!NOTE]
> Using Common Table Expressions (CTEs) allows you to build a query sequentially. You can test each CTE independently, making it much easier to debug and verify complex logic.

```sql
-- Step 1: Assign a positive or negative sign to each transaction amount.
WITH signed_transactions AS (
    SELECT
        DATE(transaction_date) AS transaction_date,
        CASE
            WHEN type = 'deposit' THEN amount
            ELSE -amount
        END AS amount
    FROM
        transactions
),
-- Step 2: Aggregate the signed transactions to get the net balance change for each day.
daily_balance_details AS (
    SELECT
        transaction_date AS transaction_day,
        EXTRACT(MONTH FROM transaction_date) AS month,
        SUM(amount) AS daily_balance
    FROM
        signed_transactions
    GROUP BY
        transaction_date,
        EXTRACT(MONTH FROM transaction_date)
)
-- Step 3: Calculate the running total of the daily net changes, resetting each month.
SELECT
    transaction_day,
    SUM(daily_balance) OVER (PARTITION BY month ORDER BY transaction_day ASC) AS balance
FROM
    daily_balance_details
ORDER BY
    transaction_day ASC;
```

#### 3.1.1. Explanation

1.  **CTE 1: `signed_transactions`**
    This initial step prepares the raw data for aggregation.
    -   `CASE WHEN type = 'deposit' THEN amount ELSE -amount END`: This is the core transformation. It converts withdrawal amounts into negative numbers. This allows a simple `SUM()` in the next step to calculate the net change (deposits - withdrawals).
    -   `DATE(transaction_date)`: This function truncates the timestamp to a date, removing the time component. This is essential for grouping all transactions that occur on the same day.

2.  **CTE 2: `daily_balance_details`**
    This CTE calculates the *net financial movement* for each individual day.
    -   `GROUP BY transaction_date`: It groups all the signed transactions by the day they occurred.
    -   `SUM(amount) AS daily_balance`: This calculates the net result for each day.

3.  **Final `SELECT` Statement**
    This final step uses a window function to calculate the running total from the daily net changes.
    -   `SUM(daily_balance) OVER (...)`: This is the window function that performs the cumulative sum.
    -   `PARTITION BY month`: This is the most crucial part of the query. It instructs the `SUM` function to operate independently within each month. When the month changes, the running total **resets to zero** and starts accumulating again.
    -   `ORDER BY transaction_day ASC`: This clause within the `OVER()` block is mandatory for a running total. It sorts the data chronologically within each partition (month), ensuring the sum accumulates in the correct order.

> [!IMPORTANT]
> The combination of `PARTITION BY` and `ORDER BY` inside the `OVER()` clause is the fundamental pattern for calculating running totals that reset based on a specific group.

### 3.2. Method 2: Combined CTE for Conciseness
This method achieves the same result but is more compact by combining the first two logical steps into a single CTE.

```sql
-- Step 1: Directly calculate the daily net balance change in a single CTE.
WITH daily_net_change AS (
    SELECT
        DATE(transaction_date) AS transaction_day,
        EXTRACT(MONTH FROM transaction_date) AS month,
        SUM(
            CASE
                WHEN type = 'deposit' THEN amount
                ELSE -amount
            END
        ) AS daily_balance
    FROM
        transactions
    GROUP BY
        DATE(transaction_date),
        EXTRACT(MONTH FROM transaction_date)
)
-- Step 2: Calculate the running total of the daily net changes.
SELECT
    transaction_day,
    SUM(daily_balance) OVER (PARTITION BY month ORDER BY transaction_day ASC) AS balance
FROM
    daily_net_change
ORDER BY
    transaction_day ASC;
```
#### 3.2.1. Explanation

1.  **The `daily_net_change` CTE**:
    -   This single CTE performs the signing of the amounts and the daily aggregation simultaneously.
    -   The `SUM(CASE...END)` expression is a powerful pattern that applies the transformation logic *inside* the aggregate function. The database engine processes this in one pass over the grouped data.

> [!WARNING]
> While this combined approach is often slightly more performant (as it requires one less intermediate data materialization), ensure you are comfortable with the logic. For very complex transformations, separating them into multiple CTEs is usually better for maintainability.

2.  **The Final `SELECT` Statement**:
    -   This part is **identical** to the final step in Method 1. It takes the pre-calculated daily net changes and applies the same window function to compute the month-to-date running balance.

## 4. Comparison of Methods
-   **Method 1 (Multi-Step CTEs)**: Superior for readability and debugging. Each logical step is isolated, making the query self-documenting and easier to troubleshoot.
-   **Method 2 (Combined CTE)**: More concise and can be slightly more performant by reducing the number of intermediate steps.

> [!TIP]
> As a best practice, start with the multi-step CTE approach (Method 1) when first developing a complex query. Once the logic is confirmed to be correct, you can refactor it into the more concise form (Method 2) if performance is a critical concern.
