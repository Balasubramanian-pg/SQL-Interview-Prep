# SQL Challenge: Warehouse Storage Optimization

## 1. Problem Statement

### 1.1. Objective
Amazon wants to maximize the storage capacity of its 500,000 square-foot warehouse. The strategy involves prioritizing a specific batch of prime items, and then using any leftover space for non-prime items.

Write a query to find the maximum number of prime and non-prime batches that can be stored based on the following criteria:
-   Prioritize stocking the maximum number of prime batches.
-   After accommodating prime items, allocate any remaining space to non-prime batches.
-   Products must be stocked in complete "batches". A batch consists of one of each unique `item_category` for a given `item_type`.

Output the `item_type` with `prime_eligible` first, followed by `not_prime`, along with the maximum number of batches that can be stocked.

> [!IMPORTANT]
> A critical constraint is that the non-prime item count should **never be zero**. There must always be at least one batch of non-prime items in stock to meet customer demand.

### 1.2. Input Table: `inventory`

|Column Name|Type|
|---|---|
|item_id|integer|
|item_type|string|
|item_category|string|
|square_footage|decimal|

### 1.3. Example

#### 1.3.1. `inventory` Example Input:

|item_id|item_type|item_category|square_footage|
|---|---|---|---|
|1374|prime_eligible|mini refrigerator|68.00|
|4245|not_prime|standing lamp|26.40|
|2452|prime_eligible|television|85.00|
|3255|not_prime|side table|22.60|
|1672|prime_eligible|laptop|8.50|

#### 1.3.2. Example Output:

|item_type|item_count|
|---|---|
|prime_eligible|9285|
|not_prime|6|

> [!NOTE]
> The example output is generated from a different dataset than the example input provided. This is common in SQL challenges. Your goal is to build a query with the correct *logic* that will work for any input, rather than trying to make the example input produce the example output.

## 2. Conceptual Approach
The problem requires careful handling of the prioritization and constraints. The most robust way to satisfy the "non-prime count is never zero" rule is to reserve space for one non-prime batch *before* calculating how many prime batches can fit.

1.  **Calculate Batch Sizes:** First, determine the total square footage required for one complete prime batch and one complete non-prime batch. This is done by summing the `square_footage` for all items within each `item_type`.

2.  **Reserve Space for Non-Prime:** To guarantee the constraint, we "reserve" the space needed for one non-prime batch from the total warehouse area of 500,000 sq ft.

3.  **Calculate Maximum Prime Batches:** Using the remaining warehouse space (Total Space - 1 Non-Prime Batch), calculate the maximum number of *whole* prime batches that can fit. We use the `FLOOR()` function to discard any fractional part.

4.  **Calculate Remaining Space:** Determine the final leftover space after stocking the maximum prime batches in their designated area.

5.  **Calculate Additional Non-Prime Batches:** Use this final remaining space to calculate how many *additional* non-prime batches can be stored.

6.  **Determine Final Non-Prime Count:** The total number of non-prime batches is `1` (from the initial reservation) plus the number of additional batches calculated in the previous step.

7.  **Combine and Format:** Combine the results for prime and non-prime batches into a single output, ordered as required.

> [!TIP]
> This "reserve first" strategy simplifies the logic immensely. It directly encodes the business rule into the calculation, avoiding complex `CASE` statements or post-calculation adjustments to handle cases where there might have been no space left for non-prime items.

## 3. SQL Solution
The following query uses Common Table Expressions (CTEs) to implement the step-by-step logic described above.

```sql
WITH item_batch_sizes AS (
  -- Step 1: Calculate the size of one complete batch for each item type
  SELECT
    SUM(CASE WHEN item_type = 'prime_eligible' THEN square_footage ELSE 0 END) AS prime_sqft,
    SUM(CASE WHEN item_type = 'not_prime' THEN square_footage ELSE 0 END) AS non_prime_sqft
  FROM inventory
),
prime_batch_count AS (
  -- Step 2 & 3: Reserve space for one non-prime batch, then calculate max prime batches
  SELECT
    prime_sqft,
    non_prime_sqft,
    FLOOR((500000 - non_prime_sqft) / prime_sqft) AS prime_batches
  FROM item_batch_sizes
),
final_counts AS (
  -- Step 4, 5, 6: Calculate final counts for both item types
  SELECT
    'prime_eligible' AS item_type,
    prime_batches AS item_count
  FROM prime_batch_count
  
  UNION ALL
  
  SELECT
    'not_prime' AS item_type,
    -- The 1 represents the reserved batch, plus any additional that fit in the remaining space
    1 + FLOOR(
      (500000 - (prime_batches * prime_sqft)) / non_prime_sqft
    ) AS item_count
  FROM prime_batch_count
)
-- Step 7: Select and order the final results
SELECT 
  item_type, 
  item_count 
FROM final_counts
ORDER BY 
  CASE 
    WHEN item_type = 'prime_eligible' THEN 1 
    WHEN item_type = 'not_prime' THEN 2 
  END;

```

## 4. Code Breakdown

### 4.1. CTE: `item_batch_sizes`
This initial CTE calculates the fundamental building blocks of our problem: the square footage of a single prime batch and a single non-prime batch.

> [!CAUTION]
> Using a conditional `SUM` with `CASE` inside is a pivot-like technique that efficiently calculates both batch sizes in a single pass over the `inventory` table, resulting in one row with two columns (`prime_sqft`, `non_prime_sqft`).

### 4.2. CTE: `prime_batch_count`
This CTE performs the core prioritization logic.
-   `(500000 - non_prime_sqft)`: This expression implements the "reserve space" strategy. It calculates the total warehouse area available *after* setting aside enough room for exactly one non-prime batch.
-   `/ prime_sqft`: The available space is then divided by the size of a prime batch.
-   `FLOOR(...)`: This function is crucial as it ensures we only count the number of *complete* batches that can fit, discarding any fractions.

> [!IMPORTANT]
> By subtracting the `non_prime_sqft` *before* calculating the prime batches, we guarantee that the non-prime constraint is always met, regardless of how much space the prime batches ultimately consume.

### 4.3. CTE: `final_counts`
This CTE constructs the final two rows for our output using a `UNION ALL`.
-   **Prime Count:** The first `SELECT` statement simply retrieves the `prime_batches` value calculated in the previous step.
-   **Non-Prime Count:** The second `SELECT` calculates the total non-prime batches.
    -   `(prime_batches * prime_sqft)`: This calculates the total space consumed by the prime batches.
    -   `500000 - (...)`: Subtracting this from the total warehouse size gives us the *true remaining space*.
    -   `FLOOR(...) / non_prime_sqft`: We calculate how many non-prime batches fit into this true remainder.
    -   `1 + ...`: This adds the single batch we initially reserved space for, giving us the final total non-prime count.

> [!TIP]
> `UNION ALL` is used here because we are certain the two `SELECT` statements will produce distinct rows (`prime_eligible` and `not_prime`) and is slightly more performant than `UNION` because it doesn't check for duplicates.

### 4.4. Final `SELECT` and `ORDER BY`
The final statement selects from the `final_counts` CTE and applies an `ORDER BY` clause.

> [!WARNING]
> A standard `ORDER BY item_type` would sort alphabetically ('not_prime' then 'prime_eligible'). To enforce the specific output order, a `CASE` statement is used within the `ORDER BY` clause to assign a sort key (`1` for prime, `2` for non-prime).
