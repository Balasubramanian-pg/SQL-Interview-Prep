# Department vs. Company Average Salary

## 1. Problem Statement

### 1.1. Objective
You work as a data analyst for a company that tracks employee salaries over time. The company wants to understand how the average salary in each department compares to the company's overall average salary each month.

Write a query to compare the average salary of employees in each department to the company's average salary for **March 2024**. Return the comparison result as 'higher', 'lower', or 'same' for each department. Display the department ID, payment month (in MM-YYYY format), and the comparison result.

> [!IMPORTANT]
> The core task is to perform a two-level aggregation: first, calculate the average salary for each department, and second, calculate the single average salary for the entire company for the specified month. Then, compare these two values for each department.

### 1.2. Input Schemas

#### 1.2.1. `employee` Schema:

|column_name|type|description|
|---|---|---|
|employee_id|integer|The unique ID of the employee.|
|name|string|The full name of the employee.|
|department_id|integer|The department ID of the employee.|
|manager_id|integer|The manager ID of the employee.|

#### 1.2.2. `salary` Schema:

|column_name|type|description|
|---|---|---|
|salary_id|integer|A unique ID for each salary record.|
|employee_id|integer|The unique ID of the employee.|
|amount|integer|The salary of the employee.|
|payment_date|datetime|The date and time when the salary was paid to the employee.|

### 1.3. Example

#### 1.3.1. Example Output:

|department_id|payment_date|comparison|
|---|---|---|
|1|01-2024|lower|

> [!NOTE]
> The example output is for January 2024 to illustrate the required format. Your query should be adapted to solve for **March 2024**.

## 2. Solution Approaches

### 2.1. Method 1: Using a Subquery in a JOIN
This method calculates the overall company average in a separate subquery and then joins it back to the main query to make it available for comparison against each department's average.

```sql
SELECT
  e.department_id,
  TO_CHAR(s.payment_date, 'MM-YYYY') AS payment_date,
  CASE
    WHEN AVG(s.amount) > overall.avg_salary THEN 'higher'
    WHEN AVG(s.amount) < overall.avg_salary THEN 'lower'
    ELSE 'same'
  END AS comparison
FROM salary s
JOIN employee e
  ON s.employee_id = e.employee_id
JOIN (
    SELECT
      AVG(amount) AS avg_salary
    FROM salary
    WHERE DATE_TRUNC('month', payment_date) = DATE '2024-03-01'
) overall ON TRUE
WHERE
  DATE_TRUNC('month', s.payment_date) = DATE '2024-03-01'
GROUP BY
  e.department_id,
  TO_CHAR(s.payment_date, 'MM-YYYY'),
  overall.avg_salary;
```

#### 2.1.1. Explanation

1.  **Main Query (`FROM` and `WHERE`)**: The query starts by joining `salary` and `employee` tables. The `WHERE DATE_TRUNC('month', s.payment_date) = DATE '2024-03-01'` clause efficiently filters all records to include only salary payments made in March 2024.

> [!TIP]
> Using `DATE_TRUNC('month', date_column) = 'YYYY-MM-01'` is a common and effective way to filter records for a specific month in SQL databases like PostgreSQL.

2.  **Subquery (`JOIN ... overall ON TRUE`)**:
    -   A subquery `(SELECT AVG(amount) AS avg_salary ...)` is defined to calculate the single overall average salary for all employees in March 2024.
    -   This subquery returns a single row with a single column (`avg_salary`).
    -   `JOIN ... ON TRUE` (or `CROSS JOIN`) is a technique to join this single-row result to every row being processed by the outer query. This effectively makes the company's average salary available as a constant for comparison in each group.

> [!IMPORTANT]
> The `JOIN ... ON TRUE` is a clever way to append a globally calculated value (like a company-wide average) to each row of another result set, which is essential before grouping.

3.  **Aggregation (`GROUP BY`)**: The results are grouped by `department_id` and the formatted `payment_date`. The `overall.avg_salary` is included in the `GROUP BY` because it's a non-aggregated column in the `SELECT` list.

4.  **Comparison (`CASE` statement)**: For each department group, `AVG(s.amount)` calculates the department's average salary. The `CASE` statement then compares this value to `overall.avg_salary` to produce the 'higher', 'lower', or 'same' string.

### 2.2. Method 2: Using Common Table Expressions (CTEs)
This method breaks the logic into clearer, sequential steps, which is often preferred for readability and maintenance.

```sql
WITH march_salaries AS (
  SELECT
    s.employee_id,
    e.department_id,
    s.amount,
    TO_CHAR(s.payment_date, 'MM-YYYY') AS payment_date
  FROM salary s
  JOIN employee e ON s.employee_id = e.employee_id
  WHERE DATE_TRUNC('month', s.payment_date) = DATE '2024-03-01'
),
dept_avg AS (
  SELECT
    department_id,
    payment_date,
    AVG(amount) AS dept_avg_salary
  FROM march_salaries
  GROUP BY department_id, payment_date
),
company_avg AS (
  SELECT
    AVG(amount) AS company_avg_salary
  FROM march_salaries
)
SELECT
  d.department_id,
  d.payment_date,
  CASE
    WHEN d.dept_avg_salary > c.company_avg_salary THEN 'higher'
    WHEN d.dept_avg_salary < c.company_avg_salary THEN 'lower'
    ELSE 'same'
  END AS comparison
FROM dept_avg d
CROSS JOIN company_avg c;
```

#### 2.2.1. Explanation

> [!NOTE]
> CTEs allow you to build a query step-by-step. Each CTE can be thought of as a temporary, named table that you can reference in subsequent CTEs or the final query, which makes complex logic much easier to follow.

1.  **CTE 1 (`march_salaries`)**: This is the base data. It filters for March 2024 salaries and joins the `salary` and `employee` tables, just like in the first method. By isolating this logic, we can reuse this clean dataset in the next steps.

2.  **CTE 2 (`dept_avg`)**: This CTE consumes the `march_salaries` data and calculates the average salary for each department by grouping on `department_id`.

3.  **CTE 3 (`company_avg`)**: This CTE also consumes the `march_salaries` data but performs an overall aggregation (`AVG(amount)`) without a `GROUP BY` clause to get the single average salary for the entire company.

> [!WARNING]
> Notice that both the `dept_avg` and `company_avg` CTEs are built from the same `march_salaries` source. This ensures that both calculations are performed on the exact same underlying dataset, preventing any data discrepancies.

4.  **Final `SELECT`**:
    -   The final query performs a `CROSS JOIN` between `dept_avg` (which has multiple rows, one per department) and `company_avg` (which has only one row).
    -   This `CROSS JOIN` appends the single company average value to each department's row, setting up the data perfectly for the final comparison.
    -   The `CASE` statement then compares the two average values to generate the final output.

> [!TIP]
> The CTE approach is often considered cleaner and more self-documenting. If the logic were to get more complex (e.g., needing to calculate medians or other stats), adding more CTEs would be a straightforward way to extend the query without making it unreadable.
