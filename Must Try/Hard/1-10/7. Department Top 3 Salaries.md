# Top Three Salaries by Department

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find the employees who earn the top three salaries in each department. A key requirement is to correctly handle ties; if multiple employees share a salary, they should all receive the same rank.

## 2. Data Model

### 2.1. `Employee` Table
| Id | Name  | Salary | DepartmentId |
|:---|:------|:-------|:-------------|
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |

### 2.2. `Department` Table
| Id | Name  |
|:---|:------|
| 1  | IT    |
| 2  | Sales |

## 3. Understanding Ranking Functions
To solve this problem, we must choose the correct SQL window function for ranking. The choice significantly affects how ties are handled.

> [!IMPORTANT]
> - **`ROW_NUMBER()`**: Assigns a unique, consecutive number to each row. It gives different ranks to rows with identical values, which is incorrect for this problem.
> - **`RANK()`**: Assigns the same rank to rows with identical values but leaves a "gap" in the sequence for the next rank. (e.g., 1, 2, 2, 4).
> - **`DENSE_RANK()`**: Assigns the same rank to rows with identical values and does *not* leave a gap. (e.g., 1, 2, 2, 3). This is the correct function for finding the "top N distinct values".

| Salary | `ROW_NUMBER()` | `RANK()` | `DENSE_RANK()` |
|:-------|:---------------|:---------|:---------------|
| 90000  | 1              | 1        | 1              |
| 85000  | 2              | 2        | 2              |
| 85000  | 3              | 2        | 2              |
| 70000  | 4              | 4        | 3              |

For this problem, we need to find the top 3 *salary levels*. Therefore, `DENSE_RANK()` is the appropriate choice.

## 4. Incremental Query Construction
We will build the query step-by-step using a Common Table Expression (CTE) for clarity.

### 4.1. Step 1: Join Employee and Department Tables
First, we need to combine the tables to get the department name for each employee.
```sql
SELECT
    d.Name AS Department,
    e.Name AS Employee,
    e.Salary
FROM
    Employee e
JOIN
    Department d ON e.DepartmentId = d.Id;
```
### 4.2. Step 2: Rank Employees within Each Department
Next, we add the `DENSE_RANK()` window function to this joined data.
- `PARTITION BY d.Name`: This resets the rank for each new department.
- `ORDER BY Salary DESC`: This ranks employees from highest to lowest salary.

```sql
SELECT
    d.Name AS Department,
    e.Name AS Employee,
    e.Salary,
    DENSE_RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rk
FROM
    Employee e
JOIN
    Department d ON e.DepartmentId = d.Id;
```
**Intermediate Result (Ranked Data):**
| Department | Employee | Salary | rk |
|:-----------|:---------|:-------|:---|
| IT         | Max      | 90000  | 1  |
| IT         | Joe      | 85000  | 2  |
| IT         | Randy    | 85000  | 2  |
| IT         | Will     | 70000  | 3  |
| IT         | Janet    | 69000  | 4  |
| Sales      | Henry    | 80000  | 1  |
| Sales      | Sam      | 60000  | 2  |

> [!TIP]
> Notice how Joe and Randy in the IT department both receive rank `2` because they have the same salary. Will receives rank `3`, not `4`, because we used `DENSE_RANK()`.

### 4.3. Step 3: Filter for the Top 3 Ranks
Finally, we put the query from the previous step into a CTE (or a subquery) and filter the results to keep only rows where the rank is 3 or less.
```sql
WITH RankedEmployees AS (
    SELECT
        d.Name AS Department,
        e.Name AS Employee,
        e.Salary,
        DENSE_RANK() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS rk
    FROM
        Employee e
    JOIN
        Department d ON e.DepartmentId = d.Id
)
SELECT
    Department,
    Employee,
    Salary
FROM
    RankedEmployees
WHERE
    rk <= 3; -- or rk < 4
```
## 5. Final Solution
The complete, well-formatted query is as follows. A subquery is used here, which is functionally equivalent to the CTE approach.
```sql
SELECT
    a.Department,
    a.Employee,
    a.Salary
FROM (
    -- Subquery to rank employees within each department
    SELECT
        d.Name AS Department,
        e.Name AS Employee,
        e.Salary,
        DENSE_RANK() OVER(PARTITION BY d.Name ORDER BY Salary DESC) AS rk
    FROM
        Employee e
    JOIN
        Department d ON e.DepartmentId = d.Id
) a
WHERE
    a.rk <= 3;
```
## 6. Result Verification
### 6.1. Expected Output
| Department | Employee | Salary |
|:-----------|:---------|:-------|
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |

### 6.2. Explanation
*   **IT Department**: The top three salary levels are 90000 (rank 1), 85000 (rank 2), and 70000 (rank 3). Both Joe and Randy are included as they share the 2nd highest salary.
*   **Sales Department**: There are only two employees, so both are included as their salary ranks are 1 and 2, which are within the top three.
