# Median from a Frequency Table

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to calculate the median number of searches per user from a frequency table. The frequency table summarizes how many users performed a certain number of searches, which avoids querying raw event logs at a massive scale.

## 2. Data Model

### 2.1. `search_frequency` Table
A summary table where each row represents a bucket of users.
| searches  | num_users |
|:----------|:----------|
| 1         | 2         |
| 2         | 2         |
| 3         | 3         |
| 4         | 1         |

**Conceptual Expanded Data**: The table above is a compact representation of the full dataset `[1, 1, 2, 2, 3, 3, 3, 4]`. Our goal is to find the median of this conceptual list without actually generating it.

## 3. Core Concept: Finding a Median from Frequencies
To find the median from a frequency table, we cannot simply take the middle row. We must determine the position of the median in the conceptual expanded list and then find which `searches` value corresponds to that position. The key to this is using a **cumulative frequency** (or a running total of `num_users`).

> [!IMPORTANT]
> A cumulative frequency tells us, "How many users have made *up to* a certain number of searches?" By finding where the median position falls within these cumulative counts, we can identify the median value.

## 4. Incremental Query Construction
We will build the solution using multiple CTEs to break the problem into manageable steps.

### 4.1. Step 1: Calculate the Total Number of Users
First, we need the total number of users (`n`) to determine the median position(s).
```sql
-- This query will become a CTE
SELECT SUM(num_users) AS total_users
FROM search_frequency;
```

### 4.2. Step 2: Calculate the Cumulative Frequency
Next, we calculate the running total of users as we move up the `searches` count. This is a perfect use case for a window function.
```sql
-- This query will become a CTE
SELECT
    searches,
    SUM(num_users) OVER (ORDER BY searches) AS cumulative_users
FROM
    search_frequency;
```
**Intermediate Result (`cumulative_counts`):**
| searches | cumulative_users |
|:---------|:-----------------|
| 1        | 2                |
| 2        | 4                |
| 3        | 7                |
| 4        | 8                |

### 4.3. Step 3: Determine the Median Position(s)
Using the total user count, we find the position of the median.
*   **Odd `n`**: The median is at position `(n + 1) / 2`.
*   **Even `n`**: The median is the average of values at positions `n / 2` and `(n / 2) + 1`.

Our example has `n=8` (even), so we need the values at positions **4** and **5**.

### 4.4. Step 4: Find the Search Values at the Median Position(s)
This is the most critical step. We need to query our `cumulative_counts` CTE to find the `searches` value corresponding to our median positions.

> **Logic**: For a given position `p`, we need to find the **first** `searches` value where `cumulative_users >= p`.

*   **For position 4**: The first `searches` value where `cumulative_users >= 4` is **2**.
*   **For position 5**: The first `searches` value where `cumulative_users >= 5` is **3**.

So, our two median values are `2` and `3`.

### 4.5. Step 5: Calculate and Round the Final Median
The final step is to average the two median values we found: `(2 + 3) / 2.0 = 2.5`.

## 5. Final Solution
The complete query chains these steps together using CTEs.

```sql
-- CTE 1: Get the total number of users.
WITH user_totals AS (
  SELECT SUM(num_users) AS total_users
  FROM search_frequency
),
-- CTE 2: Calculate the cumulative (running total) of users.
cumulative_counts AS (
  SELECT
    searches,
    SUM(num_users) OVER (ORDER BY searches) AS cumulative_users
  FROM search_frequency
),
-- CTE 3: Determine the median position(s) based on the total user count.
median_positions AS (
  SELECT
    total_users / 2.0 AS median_pos1,
    (total_users / 2.0) + 1 AS median_pos2
  FROM user_totals
  WHERE total_users % 2 = 0 -- Logic for even count
  UNION ALL
  SELECT
    (total_users + 1) / 2.0 AS median_pos1,
    (total_users + 1) / 2.0 AS median_pos2
  FROM user_totals
  WHERE total_users % 2 = 1 -- Logic for odd count
),
-- CTE 4: Find the search values that correspond to the median positions.
median_values AS (
  SELECT
    -- Find the first search value where cumulative users >= median position 1
    (SELECT searches FROM cumulative_counts WHERE cumulative_users >= mp.median_pos1 ORDER BY searches LIMIT 1) AS median_val1,
    -- Find the first search value where cumulative users >= median position 2
    (SELECT searches FROM cumulative_counts WHERE cumulative_users >= mp.median_pos2 ORDER BY searches LIMIT 1) AS median_val2
  FROM median_positions mp
)
-- Final Step: Calculate the average of the median values and round the result.
SELECT
  ROUND((median_val1 + median_val2) / 2.0, 1) AS median
FROM median_values;
```
> [!TIP]
> This query structure, particularly the use of correlated subqueries in the `median_values` CTE, is a powerful and scalable pattern for calculating medians from frequency distributions without needing to generate the full dataset.
