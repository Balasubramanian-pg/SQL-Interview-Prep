# Second Item Sold vs. Favorite Brand

## 1. Objective
> [!NOTE]
> Write a SQL query that checks, for each user, if the brand of the second item they sold matches their favorite brand. If a user has sold fewer than two items, the result should be 'no'.

## 2. Data Model

### 2.1. `Users` Table
Stores user information, including their favorite brand.
| user_id | join_date  | favorite_brand |
|:--------|:-----------|:---------------|
| 1       | 2019-01-01 | Lenovo         |
| 2       | 2019-02-09 | Samsung        |

### 2.2. `Orders` Table
Contains transaction data, linking sellers to the items they sold.
| order_id | order_date | item_id | buyer_id | seller_id |
|:---------|:-----------|:--------|:---------|:----------|
| 1        | 2019-08-01 | 4       | 1        | 2         |
| 2        | 2019-08-02 | 2       | 1        | 3         |

### 2.3. `Items` Table
Maps item IDs to their brand names.
| item_id | item_brand |
|:--------|:-----------|
| 1       | Samsung    |
| 2       | Lenovo     |

## 3. Core Logic & Key Concepts
The problem requires several logical steps:
1.  Identify all sales made by each seller.
2.  Rank these sales chronologically to find the second sale.
3.  Join this sale data with user data to compare the second item's brand with the user's favorite brand.
4.  Handle users who have made fewer than two sales.

> [!IMPORTANT]
> The most critical part of this problem is correctly handling users who do not have a second sale. A `LEFT JOIN` combined with `COALESCE` is the standard and most robust way to manage this edge case, ensuring all users appear in the final output.

## 4. Incremental Query Construction
We will build the solution using a multi-CTE approach to keep the logic clear and modular.

### 4.1. Step 1: Rank All Sales for Each Seller
First, we need to join the `orders` and `items` tables to get the brand for each sale. Then, we use a window function to rank the sales for each seller based on the order date.

```sql
-- This query will become our first CTE
SELECT
    o.seller_id,
    i.item_brand,
    -- Rank sales chronologically for each seller. The first sale is 1, second is 2, etc.
    RANK() OVER(PARTITION BY o.seller_id ORDER BY o.order_date) AS sale_rank
FROM
    orders o
JOIN
    items i ON o.item_id = i.item_id;
```
**Intermediate Result (`seller_orders`):**
| seller_id | item_brand | sale_rank |
|:----------|:-----------|:----------|
| 2         | HP         | 1         |
| 2         | Samsung    | 2         |
| 3         | Lenovo     | 1         |
| 3         | LG         | 2         |
| 4         | Samsung    | 1         |
| 4         | Lenovo     | 2         |

### 4.2. Step 2: Isolate Second Sales and Compare with Favorite Brand
Now, we can join the `users` table with our ranked sales data. We specifically look for records where `sale_rank = 2`.

> [!TIP]
> A `LEFT JOIN` from `users` to `seller_orders` is used here. This ensures that even users who *don't* have a second sale (like user 1) are still included in this intermediate step, although their `item_brand` will be `NULL`.

```sql
-- This query will become our second CTE
SELECT
    u.user_id,
    -- Compare the favorite brand with the item brand of the second sale.
    CASE
        WHEN u.favorite_brand = so.item_brand THEN 'yes'
        ELSE 'no'
    END AS second_item_fav_brand
FROM
    users u
LEFT JOIN
    seller_orders so ON u.user_id = so.seller_id AND so.sale_rank = 2;
```
**Intermediate Result (`second_sales`):**
| user_id | second_item_fav_brand |
|:--------|:----------------------|
| 1       | NULL                  |
| 2       | yes                   |
| 3       | yes                   |
| 4       | no                    |

### 4.3. Step 3: Handle Users with Fewer Than Two Sales
The intermediate result shows `NULL` for user 1 because they had no second sale. The final step is to convert these `NULL` values to 'no' as required. We do this by joining back to the `users` table one last time to ensure all users are present, and then using `COALESCE`.

> [!CAUTION]
> `COALESCE(value, 'no')` is a robust function that returns the first non-NULL value in its argument list. In this case, if `second_item_fav_brand` is `NULL`, it will return 'no'.

## 5. Final Solution
The complete query combines all these steps into a clean, readable structure.
```sql
-- CTE 1: Ranks all sales for each seller chronologically.
WITH seller_orders AS (
    SELECT
        o.seller_id,
        o.order_date,
        i.item_brand,
        RANK() OVER(PARTITION BY o.seller_id ORDER BY o.order_date) AS sale_rank
    FROM orders o
    JOIN items i ON o.item_id = i.item_id
),
-- CTE 2: For each user, compares their favorite brand to the brand of their second sale (if it exists).
second_sales AS (
    SELECT
        u.user_id,
        CASE WHEN u.favorite_brand = so.item_brand THEN 'yes'
             ELSE 'no'
        END AS second_item_fav_brand
    FROM users u
    LEFT JOIN seller_orders so ON u.user_id = so.seller_id AND so.sale_rank = 2
)
-- Final Query: Ensures all users are present and converts NULLs to 'no'.
SELECT
    u.user_id AS seller_id,
    COALESCE(ss.second_item_fav_brand, 'no') AS "2nd_item_fav_brand"
FROM users u
LEFT JOIN second_sales ss ON u.user_id = ss.user_id
ORDER BY u.user_id;
```

## 6. Result Analysis

### 6.1. Final Output
| seller_id | 2nd_item_fav_brand |
|:----------|:-------------------|
| 1         | no                 |
| 2         | yes                |
| 3         | yes                |
| 4         | no                 |

### 6.2. Explanation
*   **User 1**: Did not make any sales, so they have no second sale. The `COALESCE` function correctly assigns them 'no'.
*   **User 2**: Their second sale was a 'Samsung' item, which matches their favorite brand 'Samsung'. The result is 'yes'.
*   **User 3**: Their second sale was an 'LG' item, which matches their favorite brand 'LG'. The result is 'yes'.
*   **User 4**: Their second sale was a 'Lenovo' item, but their favorite brand is 'HP'. Since they do not match, the result is 'no'.

