# Email Confirmation Rate

## 1. The Business Question
The objective of this query is to calculate a key performance indicator for user signups:

**"What is the email confirmation rate? The rate is defined as the percentage of unique emails that received a 'Confirmed' action, out of all unique emails that were sent a signup request."**

> [!IMPORTANT]
> The confirmation rate is a ratio: `(Number of Confirmed Signups) / (Total Number of Signup Emails Sent)`. This requires counting two different subsets of the same initial population.

## 2. Assumed Table Schema
The query joins two tables, `emails` and `texts`, suggesting a user action flow where an email is sent, and a confirmation might happen via text. A plausible schema would be:

```sql
-- Table: emails
-- Stores a record for every signup email sent to a user.
CREATE TABLE emails (
    email_id     INT PRIMARY KEY,
    user_id      INT NOT NULL,
    email_address VARCHAR(255) NOT NULL,
    signup_date  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table: texts
-- Stores a record of user actions related to a signup, received via text.
CREATE TABLE texts (
    text_id        INT PRIMARY KEY,
    email_id       INT NOT NULL,           -- Foreign key linking back to the emails table
    signup_action  VARCHAR(50) NOT NULL,   -- The action taken, e.g., 'Confirmed', 'Pending'
    action_date    TIMESTAMP,
    FOREIGN KEY (email_id) REFERENCES emails(email_id)
);
```
> [!NOTE]
> The relationship is established via a `LEFT JOIN` from `emails` to `texts`. This ensures that every email sent is included in our analysis, even those that received no text-based action.

> [!TIP]
> For this query to perform well on large tables, an index on `texts(email_id)` is crucial to speed up the join operation.

## 3. Solution Approaches

### 3.1. Method 1: CTE with Subquery in `SELECT`
This method first prepares a unified dataset and then uses separate subqueries to calculate the numerator and denominator. While functional, it is generally less efficient.

```sql
-- Step 1: Join email and text data to link signups with their confirmation status.
WITH signup_info AS (
    SELECT
        e.email_id,
        t.signup_action
    FROM
        emails AS e
    LEFT JOIN
        texts AS t ON e.email_id = t.email_id
)
-- Step 2: Calculate the rate using subqueries on the CTE.
SELECT
    ROUND(
        (SELECT COUNT(DISTINCT email_id) FROM signup_info WHERE signup_action = 'Confirmed')::NUMERIC
        /
        (SELECT COUNT(DISTINCT email_id) FROM signup_info)::NUMERIC,
        2
    ) AS confirm_rate;
```

#### 3.1.1. Explanation

1.  **The `signup_info` CTE**:
    -   This step uses a `LEFT JOIN` to ensure that **every single email** from the `emails` table is included.
    -   If an email has a corresponding confirmation text, the `signup_action` will be 'Confirmed'. If not, `signup_action` will be `NULL`.

2.  **The Final `SELECT` Statement**:
    -   **Numerator**: A subquery `(SELECT COUNT(...) WHERE signup_action = 'Confirmed')` scans the CTE to count the number of unique emails that were confirmed.
    -   **Denominator**: A second subquery `(SELECT COUNT(...) FROM signup_info)` scans the CTE again to count the total number of unique emails sent.

> [!WARNING]
> This approach is generally inefficient because the database may need to scan the intermediate `signup_info` result set twice—once for each subquery. For large datasets, this can lead to poor performance.

> [!CAUTION]
> The `::NUMERIC` cast is a PostgreSQL-specific syntax for ensuring floating-point division. In other SQL dialects, you might use `CAST( ... AS NUMERIC)` or multiply by `1.0`. Without this, integer division would likely result in `0`.

### 3.2. Method 2: Conditional Aggregation (Recommended)
This is the standard, more readable, and highly efficient way to calculate a rate in a single pass over the data.

> [!NOTE]
> This pattern is one of the most important to learn in SQL for analytics. It avoids multiple scans of the data and expresses the logic for a rate calculation very cleanly.

```sql
WITH signup_info AS (
    SELECT
        e.email_id,
        t.signup_action
    FROM
        emails AS e
    LEFT JOIN
        texts AS t ON e.email_id = t.email_id
)
SELECT
    ROUND(
        100.0 * AVG(CASE WHEN signup_action = 'Confirmed' THEN 1.0 ELSE 0.0 END),
        2
    ) AS confirm_rate_pct
FROM
    signup_info;
```

#### 3.2.1. Explanation

1.  **The `signup_info` CTE**: This part is identical to the first method. It prepares the data by joining the two tables.

2.  **The Final `SELECT` Statement**: This is where the efficiency and elegance come from.
    -   `CASE WHEN signup_action = 'Confirmed' THEN 1.0 ELSE 0.0 END`: This `CASE` statement acts as a transformer. It converts each row into a numeric "flag"—`1.0` if the email was confirmed and `0.0` if it was not (or if `signup_action` is `NULL`).
    -   `AVG(...)`: This is a powerful trick. The average of a column containing only `1`s and `0`s is mathematically equivalent to the proportion of `1`s.

> [!IMPORTANT]
> The `AVG()` of a binary (0/1) flag is the most standard, high-performance pattern for calculating rates and percentages in SQL. For example, `AVG(1, 1, 1, 0)` is `(1+1+1+0)/4 = 0.75`, which is the confirmation rate of 75%.

> [!TIP]
> We multiply by `100.0` to convert the ratio (e.g., 0.75) into a percentage (e.g., 75.0) and then `ROUND` the result. The use of `100.0` also helps ensure floating-point arithmetic across different SQL dialects.
