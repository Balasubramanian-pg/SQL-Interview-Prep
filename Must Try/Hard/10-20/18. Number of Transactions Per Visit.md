# Transaction and Visit Count Report

## 1. Objective
> [!NOTE]
> Write a SQL query to generate a report showing the distribution of transaction counts per visit. A key requirement is that the report must include rows for all possible transaction counts from 0 up to the maximum number of transactions observed in a single visit, even if certain counts never occurred.

## 2. Data Model

### 2.1. `Visits` Table
Records each instance of a user visiting the platform.
| user_id | visit_date |
|:--------|:-----------|
| 1       | 2020-01-01 |
| 2       | 2020-01-02 |
...and so on.

### 2.2. `Transactions` Table
Records each transaction made by a user.
| user_id | transaction_date | amount |
|:--------|:-----------------|:-------|
| 1       | 2020-01-02       | 120    |
| 2       | 2020-01-03       | 22     |
...and so on.

## 3. Core Logic & Key Concepts
This problem has two main challenges that guide the solution's structure:
1.  **Counting Visits with Zero Transactions**: We need to ensure that visits where a user made no purchases are counted. This is solved by using a `LEFT JOIN` from the `Visits` table to the `Transactions` table.
2.  **Generating a Complete Range of Counts**: The final report must include rows for transaction counts that might not exist in the data (e.g., a row for `transactions_count = 2` even if no visit had exactly two transactions). This requires generating a complete series of numbers from 0 up to the maximum observed count.

> [!IMPORTANT]
> A **Recursive Common Table Expression (CTE)** is the standard and most powerful SQL feature for generating a sequence of numbers (a "tally table") on the fly. It works by defining a starting value (the anchor member) and then repeatedly adding to it (the recursive member) until a termination condition is met.

## 4. Incremental Query Construction
We will use a multi-CTE approach to break down the problem into logical, manageable steps.

### 4.1. Step 1: Calculate Transactions per Visit
First, we must determine how many transactions occurred during each unique visit.
```sql
-- This query will become our first CTE
SELECT
    v.user_id,
    v.visit_date,
    COUNT(t.transaction_date) AS transaction_count
FROM
    Visits v
LEFT JOIN
    Transactions t ON v.user_id = t.user_id AND v.visit_date = t.transaction_date
GROUP BY
    v.user_id, v.visit_date;
```
> [!TIP]
> The `LEFT JOIN` is crucial here. It ensures that every row from the `Visits` table is kept. For visits with no matching transactions, `t.transaction_date` will be `NULL`. `COUNT(t.transaction_date)` correctly counts non-NULL values, resulting in `0` for these visits.

### 4.2. Step 2: Summarize Visit Counts by Transaction Count
Next, we aggregate the results from Step 1 to find out how many visits had 0 transactions, how many had 1, and so on.
```sql
-- This query will become our second CTE
SELECT
    transaction_count,
    COUNT(*) AS visits_count
FROM
    visit_transactions -- Assumes the query from Step 1 is in this CTE
GROUP BY
    transaction_count;
```
**Intermediate Result (`transaction_counts`):**
| transaction_count | visits_count |
|:------------------|:-------------|
| 0                 | 4            |
| 1                 | 5            |
| 3                 | 1            |
> [!CAUTION]
> Notice that this result is incomplete. The row for `transaction_count = 2` is missing because no visit had exactly two transactions. The next steps will fix this.

### 4.3. Step 3: Generate a Complete Series of Numbers
Here, we use a recursive CTE to create a table containing all integers from 0 up to the maximum transaction count found in our data.
```sql
-- This query will become our recursive CTE
WITH RECURSIVE all_counts (transactions_count) AS (
    -- Anchor Member: Start the series at 0
    SELECT 0
    UNION ALL
    -- Recursive Member: Add 1 in each step until the max is reached
    SELECT transactions_count + 1
    FROM all_counts
    WHERE transactions_count < (SELECT MAX(transaction_count) FROM visit_transactions)
)
SELECT * FROM all_counts;
```
**Intermediate Result (`all_counts`):**
| transactions_count |
|:-------------------|
| 0                  |
| 1                  |
| 2                  |
| 3                  |

### 4.4. Step 4: Join the Full Number Series with Actual Counts
Finally, we perform a `LEFT JOIN` from our complete number series (`all_counts`) to our actual summarized counts (`transaction_counts`). This ensures that every number in the series has a row in the final output. We use `COALESCE` to replace any `NULL` `visits_count` values with `0`.

## 5. Final Solution
The complete query combines all these steps.

```sql
-- CTE 1: Calculate the number of transactions for each visit.
WITH visit_transactions AS (
    SELECT
        v.user_id,
        v.visit_date,
        COUNT(t.transaction_date) AS transaction_count
    FROM Visits v
    LEFT JOIN Transactions t ON v.user_id = t.user_id AND v.visit_date = t.transaction_date
    GROUP BY v.user_id, v.visit_date
),
-- CTE 2: Count how many visits had each transaction count.
transaction_counts AS (
    SELECT
        transaction_count,
        COUNT(*) AS visits_count
    FROM visit_transactions
    GROUP BY transaction_count
),
-- CTE 3 (Recursive): Generate a complete series of numbers from 0 to the max transaction count.
RECURSIVE all_counts (transactions_count) AS (
    SELECT 0
    UNION ALL
    SELECT transactions_count + 1
    FROM all_counts
    WHERE transactions_count < (SELECT MAX(transaction_count) FROM visit_transactions)
)
-- Final Query: Join the complete series with the actual counts.
SELECT
    ac.transactions_count,
    COALESCE(tc.visits_count, 0) AS visits_count
FROM all_counts ac
LEFT JOIN transaction_counts tc ON ac.transactions_count = tc.transaction_count
ORDER BY ac.transactions_count;
```

## 6. Result Analysis

### 6.1. Final Output
| transactions_count | visits_count |
|:-------------------|:-------------|
| 0                  | 4            |
| 1                  | 5            |
| 2                  | 0            |
| 3                  | 1            |

### 6.2. Explanation
*   **0 Transactions (4 Visits)**: These are the visits from the `Visits` table that had no corresponding entry in the `Transactions` table for the same user and date.
*   **1 Transaction (5 Visits)**: Five unique visits resulted in exactly one transaction each.
*   **2 Transactions (0 Visits)**: This row exists because our recursive CTE generated the number `2`. The `LEFT JOIN` found no match in our `transaction_counts` data, so `COALESCE` correctly filled in `0`.
*   **3 Transactions (1 Visit)**: The visit by user `9` on `2020-01-25` had three associated transactions.

