# Identifying Compensation Outliers

## 1. The Business Question
The objective of this query is to identify compensation outliers within the company. Specifically, it seeks to answer:

**"Which employees are compensation outliers within their own job title? An 'outlier' is defined as any employee whose salary is more than double the average salary for their title ('Overpaid') or less than half the average salary for their title ('Underpaid')."**

> [!IMPORTANT]
> The comparison is not against a company-wide average, but against the average salary of peers with the *same job title*. This requires a group-wise calculation.

## 2. Assumed Table Schema
The query references a single table, `employee_pay`. A plausible schema would be:

```sql
-- Table: employee_pay
-- Stores salary and job title information for each employee.
CREATE TABLE employee_pay (
    employee_id  INT PRIMARY KEY,
    first_name   VARCHAR(100),
    last_name    VARCHAR(100),
    title        VARCHAR(255) NOT NULL, -- The employee's job title, e.g., 'Software Engineer'
    salary       DECIMAL(12, 2) NOT NULL -- The employee's annual salary
);
```

> [!TIP]
> An index on the `title` column is critical for the performance of this query, as all grouping and comparison logic is based on this column.
>
> `CREATE INDEX idx_employee_title ON employee_pay (title);`

## 3. Solution Approaches

### 3.1. Method 1: CTE with a Correlated Subquery
This approach iterates through each employee and, for each one, runs a separate subquery to calculate the average salary for their specific job title.

```sql
WITH employee_status AS (
    SELECT
        e1.employee_id,
        e1.salary,
        e1.title,
        CASE
            WHEN e1.salary > 2 * (SELECT AVG(e2.salary) FROM employee_pay AS e2 WHERE e1.title = e2.title)
                THEN 'Overpaid'
            WHEN e1.salary < 0.5 * (SELECT AVG(e2.salary) FROM employee_pay AS e2 WHERE e1.title = e2.title)
                THEN 'Underpaid'
            ELSE 'Near Average'
        END AS status
    FROM
        employee_pay AS e1
)
SELECT
    employee_id,
    salary,
    status
FROM
    employee_status
WHERE
    status IN ('Underpaid', 'Overpaid');
```

#### 3.1.1. Explanation

1.  **The `employee_status` CTE**:
    -   This CTE iterates through every employee (`e1`). For each row, it executes a `CASE` statement.
    -   **The Correlated Subquery**: The subquery `(SELECT AVG(e2.salary) ...)` is the core of the logic. It is "correlated" because its `WHERE e1.title = e2.title` clause depends on the `title` from the outer query's current row (`e1`). This subquery is re-executed for every single employee.

> [!WARNING]
> This method is **very inefficient** and should be avoided on large datasets. If the table has `N` rows, the subquery (which performs an aggregation) will be executed `2 * N` times. This leads to `O(N^2)` complexity in the worst case and will not scale.

2.  **The Final `SELECT`**:
    -   This part is straightforward. It reads from the CTE's results and filters to keep only the rows that were flagged as outliers ('Overpaid' or 'Underpaid').

### 3.2. Method 2: Using a Window Function (Recommended)
A far more efficient and modern approach is to use a window function to calculate the average salary for each title in a single pass over the data.

> [!NOTE]
> Window functions are the industry-standard, high-performance solution for this type of "compare-a-row-to-its-group" analysis. They calculate all the required group-level aggregates in one go.

```sql
WITH title_avg_salary AS (
    -- Step 1: Calculate the average salary for each title in one pass
    SELECT
        employee_id,
        salary,
        title,
        AVG(salary) OVER (PARTITION BY title) AS avg_salary_for_title
    FROM
        employee_pay
)
-- Step 2: Use the pre-calculated average to find outliers
SELECT
    employee_id,
    salary,
    CASE
        WHEN salary > 2 * avg_salary_for_title THEN 'Overpaid'
        WHEN salary < 0.5 * avg_salary_for_title THEN 'Underpaid'
    END AS status
FROM
    title_avg_salary
WHERE
    salary > 2 * avg_salary_for_title
    OR salary < 0.5 * avg_salary_for_title;
```

#### 3.2.1. Explanation

1.  **The `title_avg_salary` CTE**:
    -   This is where the magic happens. The query performs a single, efficient scan of the `employee_pay` table.
    -   `AVG(salary) OVER (PARTITION BY title)`: This is the window function.
        -   `PARTITION BY title`: This clause logically divides the data into groups based on job title (e.g., all 'Software Engineers' in one group, all 'Data Analysts' in another).
        -   `AVG(salary) OVER (...)`: For each row, this function calculates the average salary of all other rows *within that row's partition*.
    -   The result is that every employee row is now annotated with the average salary for their specific job title.

> [!IMPORTANT]
> The key difference is that the average for each title is calculated only **once** and then "stamped" onto every relevant employee row, rather than being recalculated for every single employee. This is dramatically more efficient.

2.  **The Final `SELECT`**:
    -   This query operates on the CTE, which now contains both the employee's individual `salary` and the relevant `avg_salary_for_title`.
    -   The `WHERE` clause can now directly and quickly compare these two values to filter the result set down to only the outliers.
    -   The `CASE` statement in the `SELECT` clause then assigns the appropriate 'Overpaid' or 'Underpaid' label. We don't need an `ELSE` condition because the `WHERE` clause has already removed all the 'Near Average' employees.

> [!TIP]
> Notice the condition is duplicated in the `WHERE` clause and the `CASE` statement. This is a common pattern for filtering first and then labeling the filtered results. Some SQL dialects allow you to reference column aliases in the `WHERE` clause, but it is not universally supported, making this explicit approach more portable.
