# 2nd Ride Delay for "In-the-Moment" Users

## 1. Problem Statement

### 1.1. Objective
Some riders create their Uber account the same day they book their first ride. The rider engagement team calls these “in-the-moment” users.

Uber wants to know the average delay (in days) between the day of user sign-up and the day of their 2nd ride for this specific cohort of users. The final answer should be rounded to 2 decimal places.

**users** Table:

![](https://miro.medium.com/v2/resize:fit:580/1*rJ1MJF7eySkni7TUfCD0UA.png)

**rides** Table:

![](https://miro.medium.com/v2/resize:fit:545/1*hfD6BgFmwkrVakaYVnhkeA.png)



The output will be as follows.

Press enter or click to view image in full size

![](https://miro.medium.com/v2/resize:fit:875/1*WPTjTKzCnRF2G0pauVkUJQ.png)

### 1.2. Input Schemas

#### 1.2.1. `users` Table:

|**Column Name**|**Type**|
|---|---|
|user_id|integer|
|registration_date|date|

#### 1.2.2. `rides` Table:

|**Column Name**|**Type**|
|---|---|
|ride_id|integer|
|user_id|integer|
|ride_date|date|

## 2. Conceptual Approach
To solve this problem, we need to follow a multi-step process to first identify the correct group of users, then process their ride history to find the 2nd ride, and finally calculate the average delay.

1.  **Identify "In-the-Moment" Users**: The first step is to create a list of users who fit the definition. We can achieve this by joining the `users` and `rides` tables and filtering for users where their `registration_date` is the same as their first `ride_date`.

```sql
WITH moment_users AS (
  -- Step 1: Identify all users who took their first ride on their registration day.
  SELECT DISTINCT
    u.user_id
  FROM users AS u
  JOIN rides AS r
    ON u.user_id = r.user_id
    AND u.registration_date = r.ride_date
)
```

> [!IMPORTANT]
> The definition of an "in-the-moment" user is key: their first ride must occur on the same day they registered. This initial filtering step is crucial for ensuring our analysis is performed on the correct user cohort.

2.  **Enumerate All Rides for the Cohort**: Once we have our list of target users, we need to analyze all their rides to find the 1st and 2nd ones. We can use the `ROW_NUMBER()` window function to assign a sequential number to each ride for every user, ordered by date. This will allow us to easily identify the 2nd ride.

```sql
rides_cte AS (
  -- Step 2: For this cohort, get all their rides and number them chronologically.
  -- Also, get the date of the previous ride using LAG().
  SELECT
    r.user_id,
    r.ride_date,
    ROW_NUMBER() OVER (
      PARTITION BY mu.user_id
      ORDER BY r.ride_date
    )
```

3.  **Access Previous Ride Date**: To calculate the delay between the 1st and 2nd ride, we need both dates available on the same row. The `LAG()` window function is perfect for this; it allows us to fetch the `ride_date` from the previous ride and place it on the current ride's row.

> [!TIP]
> Window functions like `ROW_NUMBER()` and `LAG()` are extremely powerful for this type of sequential analysis. They allow you to perform complex calculations across related rows without resorting to inefficient self-joins.

```sql
AS ride_nr,
    LAG(r.ride_date) OVER (
      PARTITION BY mu.user_id
      ORDER BY r.ride_date
    ) AS lag_ride_date
  FROM moment_users AS mu
  LEFT JOIN rides AS r
    ON mu.user_id = r.user_id
)
```

4.  **Calculate and Average the Delay**: With the ride number and previous ride date prepared, we can filter for only the 2nd rides (`ride_nr = 2`). For these rows, we calculate the difference between the `ride_date` (the 2nd ride's date) and the `lag_ride_date` (the 1st ride's date). Finally, we take the average of these differences and round it to two decimal places.

```sql
SELECT
  ROUND(AVG(ride_date - lag_ride_date), 2) AS average_delay
FROM rides_cte
WHERE ride_nr = 2;
```

## 3. SQL Solution

```sql
WITH moment_users AS (
  -- Step 1: Identify all users who took their first ride on their registration day.
  SELECT DISTINCT
    u.user_id
  FROM users AS u
  JOIN rides AS r
    ON u.user_id = r.user_id
    AND u.registration_date = r.ride_date
),
rides_cte AS (
  -- Step 2: For this cohort, get all their rides and number them chronologically.
  -- Also, get the date of the previous ride using LAG().
  SELECT
    r.user_id,
    r.ride_date,
    ROW_NUMBER() OVER (
      PARTITION BY mu.user_id
      ORDER BY r.ride_date
    ) AS ride_nr,
    LAG(r.ride_date) OVER (
      PARTITION BY mu.user_id
      ORDER BY r.ride_date
    ) AS lag_ride_date
  FROM moment_users AS mu
  LEFT JOIN rides AS r
    ON mu.user_id = r.user_id
)
-- Step 3: Filter for the 2nd ride and calculate the average delay.
SELECT
  ROUND(AVG(ride_date - lag_ride_date), 2) AS average_delay
FROM rides_cte
WHERE ride_nr = 2;
```

## 4. Code Breakdown

### 4.1. CTE 1: `moment_users`
This Common Table Expression isolates the specific group of users we need to analyze.
-   It performs an `INNER JOIN` between `users` and `rides` where the `user_id` and the dates (`registration_date` and `ride_date`) match.
-   `DISTINCT` is used to ensure we get a unique list of `user_id`s, as a user might have taken multiple rides on their registration day.

> [!CAUTION]
> The join condition `u.registration_date = r.ride_date` is the filter that defines our cohort. If a user's first ride was a day after they signed up, they would be excluded from this CTE and the entire analysis.

### 4.2. CTE 2: `rides_cte`
This CTE takes the identified `moment_users` and processes their entire ride history.
-   `ROW_NUMBER() OVER (PARTITION BY mu.user_id ORDER BY r.ride_date)`: This function assigns a rank to each ride. `PARTITION BY mu.user_id` is crucial—it tells the function to restart the numbering for each user. `ORDER BY r.ride_date` ensures the rides are numbered chronologically.
-   `LAG(r.ride_date) OVER (...)`: This function fetches the `ride_date` from the previous row within the same user partition. For the first ride (`ride_nr = 1`), `lag_ride_date` will be `NULL`. For the second ride (`ride_nr = 2`), `lag_ride_date` will contain the date of the first ride.

> [!NOTE]
> The `PARTITION BY` and `ORDER BY` clauses in both window functions are identical. This consistency is essential for the logic to work correctly, as it ensures the row numbering and the lagged dates are based on the same sequence.

### 4.3. Final `SELECT` Statement
This is where the final calculation happens.
-   `WHERE ride_nr = 2`: This filter is the most important part of the final step. It narrows down the `rides_cte` to only the rows that represent a user's second ride.

> [!IMPORTANT]
> Because of this filter, the `lag_ride_date` column for every remaining row will conveniently hold the date of that user's *first* ride, setting up the perfect scenario for our calculation.

-   `ride_date - lag_ride_date`: This performs date arithmetic to find the number of days between the 2nd ride and the 1st ride for each user.

> [!WARNING]
> The ability to directly subtract dates and get an integer number of days is common in databases like PostgreSQL. In other SQL dialects (like SQL Server), you might need to use a function like `DATEDIFF(day, lag_ride_date, ride_date)`.

-   `AVG(...)`: This aggregates the delays calculated for all users into a single average value.
-   `ROUND(..., 2)`: This function formats the final result to two decimal places as required by the problem statement.

## Alternative Solution 

```sql
WITH moment_users AS (
 SELECT DISTINCT u.user_id
 FROM users u
 JOIN rides r
  ON u.user_id = r.user_id
  AND u.registration_date = r.ride_date
)
SELECT ROUND(AVG(r2.ride_date - r1.ride_date), 2) AS average_delay
FROM moment_users mu
JOIN rides r1 ON mu.user_id = r1.user_id
JOIN rides r2 ON mu.user_id = r2.user_id AND r2.ride_date > r1.ride_date
WHERE NOT EXISTS (
 SELECT 1 FROM rides r3 
 WHERE r3.user_id = mu.user_id
  AND r3.ride_date BETWEEN r1.ride_date AND r2.ride_date
 AND r3.ride_date != r1.ride_date AND r3.ride_date != r2.ride_date
);
```
