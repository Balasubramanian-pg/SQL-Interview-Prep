# Cumulative Purchase Quantity by Product Type

## 1. The Business Question
The objective of this query is to track the sales momentum of different product categories over time. The specific business question is:

**"For each product type, what is the cumulative (running total) quantity purchased over time? Show a list of every transaction, and for each one, display the total quantity purchased for that product's type up to and including that order's date."**

> [!IMPORTANT]
> A running total is a calculation that shows the cumulative sum of a value as you progress through an ordered set of data. In this case, the total "resets" for each new `product_type`.

## 2. Assumed Table Schema
The query references a single table, `total_trans`. This table likely acts as a daily summary or a raw transaction log. A plausible schema would be:

```sql
-- Table: total_trans
-- Stores a record of product transactions, possibly aggregated daily.
CREATE TABLE total_trans (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    order_date     DATE NOT NULL,             -- The date of the transaction
    product_type   VARCHAR(100) NOT NULL,     -- The category or type of product
    quantity       INT NOT NULL               -- The number of units sold
);
```

> [!TIP]
> For this type of query, performance can be significantly improved by creating a composite index on the columns used for partitioning and ordering.
>
> `CREATE INDEX idx_product_date ON total_trans (product_type, order_date);`

## 3. Solution Approaches

### 3.1. Method 1: Correlated Subquery
This method calculates the running total by executing an inner query for every single row processed by the outer query. While it works, it is generally inefficient on large datasets.

```sql
SELECT
    t1.order_date,
    t1.product_type,
    (
        SELECT
            SUM(quantity)
        FROM
            total_trans AS t2
        WHERE
            t2.order_date <= t1.order_date
            AND t2.product_type = t1.product_type
    ) AS cum_purchased
FROM
    total_trans AS t1
ORDER BY
    t1.product_type, t1.order_date;
```

#### 3.1.1. Explanation

1.  **Outer Query**: The main query `SELECT ... FROM total_trans AS t1` iterates through each row of the table, one by one.

2.  **Correlated Subquery**: For **each row** of `t1`, the subquery `(SELECT SUM(quantity) ...)` is executed.
    -   `WHERE t2.product_type = t1.product_type`: This is the "correlation." It ensures the subquery only sums quantities for the **same product type** as the current row in the outer query (`t1`).
    -   `AND t2.order_date <= t1.order_date`: This is the "cumulative" logic. It restricts the sum to include only rows that have a date on or before the current row's date.

> [!WARNING]
> This method has a significant performance issue. If the `total_trans` table has `N` rows, the inner subquery will be executed `N` times. This can lead to very long query times on large tables and is generally not a scalable solution.

### 3.2. Method 2: Using a Window Function (Recommended)
The modern, standard, and far more efficient way to calculate running totals is with **window functions**.

> [!NOTE]
> Window functions are a powerful feature in modern SQL designed specifically for these types of calculations. They perform the entire operation in a single pass over the data, making them dramatically more performant than correlated subqueries.

```sql
SELECT
    order_date,
    product_type,
    SUM(quantity) OVER (
        PARTITION BY product_type
        ORDER BY order_date
    ) AS cum_purchased
FROM
    total_trans
ORDER BY
    product_type, order_date;
```

#### 3.2.1. Explanation
This query produces the exact same result but in a much more efficient way.

1.  **`SUM(quantity) OVER (...)`**: This is the window function. It calculates a `SUM` over a specific "window" of rows related to the current row, rather than re-querying the whole table each time.

2.  **`PARTITION BY product_type`**:
    -   This clause acts like a `GROUP BY` for the window function. It divides the data into logical partitions, or groups. In this case, all rows for 'Electronics' go into one partition, all rows for 'Apparel' go into another, and so on.
    -   The `SUM` calculation will be contained within these partitions, meaning the running total will **reset** for each new `product_type`.

> [!IMPORTANT]
> The `PARTITION BY` clause is what makes the running total specific to each product type. Without it, the query would calculate a single running total across all products combined.

3.  **`ORDER BY order_date`**:
    -   This clause sorts the rows **within each partition** chronologically.
    -   This ordering is crucial, as it tells the `SUM` function how to accumulate the total. The function will sum the `quantity` from the first row of the partition up to and including the **current row**.

> [- How it Works: The database engine makes a single pass over the data. For each row, it considers the row's partition (`product_type`) and its position in the sorted order (`order_date`). It then sums the `quantity` for all rows in that same partition that come on or before the current row's date, producing the running total in one efficient operation.

> [!TIP]
> This `SUM() OVER (PARTITION BY ... ORDER BY ...)` pattern is the go-to method for calculating any kind of running total in modern SQL. It is not only more performant but also more readable and expressive once you are familiar with the syntax.
