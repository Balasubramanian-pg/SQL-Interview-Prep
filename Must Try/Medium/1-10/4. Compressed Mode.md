# Finding the Mode of Order Occurrences

## 1. Problem Statement

### 1.1. Objective
You're given a table containing the item count for each order on Alibaba, along with the frequency of orders that have the same item count. Write a query to retrieve the mode of the order occurrences.

Additionally, if there are multiple item counts with the same mode (i.e., the same highest frequency), the results should be sorted in ascending order.

> [!IMPORTANT]
> In this context, the "mode" is the `item_count` that corresponds to the highest `order_occurrences` value. We are looking for the most frequently occurring *type* of order.

### 1.2. Clarifications
-   `item_count`: Represents the number of items sold in each order.
-   `order_occurrences`: Represents the frequency of orders with the corresponding number of items sold per order.
-   For example, if there are 800 orders with 3 items sold in each order, the record would have an `item_count` of 3 and an `order_occurrences` of 800.

### 1.3. Input Table: `items_per_order`

|Column Name|Type|
|---|---|
|item_count|integer|
|order_occurrences|integer|

### 1.4. Example

#### 1.4.1. `items_per_order` Example Input:

|item_count|order_occurrences|
|---|---|
|1|500|
|2|1000|
|3|800|

#### 1.4.2. Example Output:

|mode|
|---|
|2|

#### 1.4.3. Explanation
Based on the example output, the `order_occurrences` value of 1000 is the highest frequency among all entries. This corresponds to an `item_count` of 2, making it the mode.

## 2. Conceptual Approach
To solve this, we need to find the mode, which is the `item_count` associated with the highest frequency (`order_occurrences`).

1.  **Find the Maximum Frequency**: First, we must identify the highest value present in the `order_occurrences` column.
2.  **Filter for the Mode(s)**: Next, we retrieve all rows from the table where the `order_occurrences` value matches this maximum frequency.
3.  **Return the Item Count(s)**: From these filtered rows, we select the `item_count`.
4.  **Sort for Ties**: Finally, we sort the resulting `item_count` values in ascending order to handle any cases where multiple item counts share the same highest frequency.

> [!NOTE]
> This problem can be solved in a few ways in SQL, most commonly with a subquery or, in more modern SQL dialects, with a window function for ranking.

## 3. SQL Solution Approaches

### 3.1. Method 1: Using a Subquery
This is a classic and highly compatible approach that works across almost all SQL databases.

```sql
SELECT
  item_count AS mode
FROM items_per_order
WHERE order_occurrences = (
  SELECT MAX(order_occurrences)
  FROM items_per_order
)
ORDER BY item_count ASC;
```

#### 3.1.1. Code Breakdown

1.  **The Subquery**:
    -   `(SELECT MAX(order_occurrences) FROM items_per_order)`: This part of the query is executed first. It scans the `order_occurrences` column and returns a single value: the highest frequency found in the table (in the example, `1000`).

> [!TIP]
> This is a non-correlated subquery because it can be run independently of the outer query. The database engine typically calculates its result once and then uses that value for the main query's filter.

2.  **The Main Query**:
    -   `WHERE order_occurrences = ...`: The main query then filters the `items_per_order` table, keeping only the rows where the `order_occurrences` is equal to the maximum value returned by the subquery.
    -   `SELECT item_count AS mode`: From the filtered rows, it selects the `item_count` and renames it to `mode`.
    -   `ORDER BY item_count ASC`: This final clause ensures that if multiple rows are returned (a tie for the mode), the resulting item counts are sorted in ascending order as required.

> [!CAUTION]
> Using `=` is safe here because `MAX()` is guaranteed to return only a single value. If the subquery could return multiple rows, it would be safer to use the `IN` operator (e.g., `WHERE order_occurrences IN (...)`).

### 3.2. Method 2: Using a `RANK()` Window Function
This is a more modern and often more flexible approach for "greatest-n-per-group" problems.

> [!NOTE]
> Window functions like `RANK()` are incredibly powerful for creating rankings or categories without needing subqueries or self-joins. They can often be more readable and performant for complex ranking scenarios.

```sql
WITH ranked_items AS (
    SELECT
        item_count,
        RANK() OVER (ORDER BY order_occurrences DESC) AS rank_num
    FROM items_per_order
)
SELECT
  item_count AS mode
FROM ranked_items
WHERE rank_num = 1
ORDER BY item_count ASC;
```

#### 3.2.1. Code Breakdown
1.  **The `ranked_items` CTE**:
    -   This Common Table Expression processes the `items_per_order` table and assigns a rank to each row.
    -   `RANK() OVER (ORDER BY order_occurrences DESC)`: This is the window function. It ranks each row based on the `order_occurrences` in descending order. The row(s) with the highest `order_occurrences` will receive a rank of `1`.

> [!IMPORTANT]
> The `RANK()` function is the perfect choice here because it handles ties by giving the same rank to rows with the same value. If two item counts had an `order_occurrences` of 1000, they would both get `rank_num = 1`. This is exactly the behavior we need to find all modes.

> [!WARNING]
> If you were to use `ROW_NUMBER()` instead of `RANK()`, it would assign a different rank to tied values (e.g., 1 and 2), which would be incorrect for this problem as it would arbitrarily exclude one of the modes.

2.  **The Final `SELECT` Statement**:
    -   `FROM ranked_items`: The query selects from our pre-ranked data.
    -   `WHERE rank_num = 1`: This simple filter keeps only the row(s) that have the highest frequency.
    -   `ORDER BY item_count ASC`: As in the first method, this sorts the final list of modes in ascending order.
