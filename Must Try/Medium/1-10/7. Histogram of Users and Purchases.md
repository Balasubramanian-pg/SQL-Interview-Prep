# User's Most Recent Purchase

## 1. Problem Statement

### 1.1. Objective
Assume you're given a table on Walmart user transactions. Based on their most recent transaction date, write a query that retrieves the users along with the number of products they bought.

Output the user's most recent transaction date, user ID, and the number of products, sorted in chronological order by the transaction date.

> [!IMPORTANT]
> The query must focus exclusively on the transactions that occurred on each user's single most recent day of activity. All prior transactions for that user should be ignored in the final count.

### 1.2. Input Table: `user_transactions`

|Column Name|Type|
|---|---|
|product_id|integer|
|user_id|integer|
|spend|decimal|
|transaction_date|timestamp|

### 1.3. Example

#### 1.3.1. `user_transactions` Example Input:

|product_id|user_id|spend|transaction_date|
|---|---|---|---|
|3673|123|68.90|07/08/2022 12:00:00|
|9623|123|274.10|07/08/2022 12:00:00|
|1467|115|19.90|07/08/2022 12:00:00|
|2513|159|25.00|07/08/2022 12:00:00|
|1452|159|74.50|07/10/2022 12:00:00|

#### 1.3.2. Example Output:

|transaction_date|user_id|purchase_count|
|---|---|---|
|07/08/2022 12:00:00|115|1|
|07/08/2022 12:00:00|123|2|
|07/10/2022 12:00:00|159|1|

## 2. Conceptual Approach
The problem requires a two-stage process: first, we must identify the specific date of each user's last transaction, and second, we use that information to filter the original transaction data before counting the products.

1.  **Isolate the Latest Transaction Date for Each User**: The first step is to create a reference list or temporary table that maps each `user_id` to their single most recent `transaction_date`. This is achieved by grouping all transactions by `user_id` and finding the `MAX(transaction_date)`.

2.  **Filter the Main Table**: With the "latest date" information for each user, we can now go back to the original `user_transactions` table. We will join it with our reference list to pull only the transaction rows that match *both* the `user_id` and their specific latest `transaction_date`.

3.  **Aggregate and Count**: Once we have the filtered set of transactions (containing only the most recent ones for each user), we can perform the final aggregation. We group by `user_id` and `transaction_date` and count the number of products.

4.  **Order the Results**: The final output is sorted chronologically by `transaction_date`.

> [!NOTE]
> This "find max-per-group then join back" is a fundamental and very common pattern in SQL. It is used to answer many "latest", "earliest", "most expensive", etc., questions on a per-entity basis (e.g., per user, per product).

## 3. SQL Solution (CTE Approach)

```sql
WITH user_max_dates AS (
  -- Step 1: Find the most recent transaction date for each user.
  SELECT
    user_id,
    MAX(transaction_date) AS max_transaction_date
  FROM user_transactions
  GROUP BY user_id
)
-- Step 2 & 3: Join back to the original table to get transactions on that date and count them.
SELECT
  ut.transaction_date,
  ut.user_id,
  COUNT(ut.product_id) AS purchase_count
FROM user_transactions AS ut
INNER JOIN user_max_dates AS umd
  ON ut.user_id = umd.user_id
  AND ut.transaction_date = umd.max_transaction_date
GROUP BY
  ut.transaction_date,
  ut.user_id
ORDER BY
  ut.transaction_date;
```

> [!TIP]
> Using a Common Table Expression (CTE) like `user_max_dates` makes this multi-step logic very clear and readable. It separates the "date finding" logic from the final "counting" logic.

## 4. Code Breakdown

### 4.1. CTE: `user_max_dates`
This initial block is dedicated to one task: finding the last transaction date for every user.
-   `GROUP BY user_id`: This ensures that the `MAX()` function is applied independently to each user's set of transactions.
-   `MAX(transaction_date)`: This aggregate function finds the latest timestamp for each user group.
-   The result of this CTE is a simple mapping table: `(user_id, max_transaction_date)`.

> [!IMPORTANT]
> This CTE's sole purpose is to identify the *date* of the latest transaction. It does not contain any product information. That information is retrieved in the next step.

### 4.2. Main `SELECT` Statement
This part of the query uses the CTE to filter and then aggregate the raw transaction data.
-   `INNER JOIN user_max_dates AS umd`: We join the full transaction table back to our CTE.
-   `ON ut.user_id = umd.user_id AND ut.transaction_date = umd.max_transaction_date`: This multi-part `ON` clause is the most critical part of the query. It ensures that a row from `user_transactions` is kept only if it matches a user from the CTE *and* its transaction date is that user's specific maximum date.

> [!WARNING]
> A common mistake is to only join on `user_id`. This would incorrectly associate *all* of a user's transactions with their max date. The second join condition on the date itself is what performs the crucial filtering.

-   `GROUP BY ut.transaction_date, ut.user_id`: After filtering, we group the remaining rows. Since we've already filtered for a single date per user, this grouping prepares the data for counting.
-   `COUNT(ut.product_id) AS purchase_count`: This counts the number of products for each user on their most recent transaction date.
-   `ORDER BY ut.transaction_date`: Sorts the final output chronologically.

> [!CAUTION]
> While `COUNT(ut.product_id)` is explicit, `COUNT(*)` would also work correctly here because the `INNER JOIN` has already filtered the rows to only those we wish to count.

## 5. Alternative Solution (Window Function)
This problem can also be solved efficiently using a window function like `RANK()`.

```sql
WITH ranked_transactions AS (
  SELECT
    user_id,
    product_id,
    transaction_date,
    RANK() OVER (
      PARTITION BY user_id
      ORDER BY transaction_date DESC
    ) AS rank_num
  FROM user_transactions
)
SELECT
  transaction_date,
  user_id,
  COUNT(product_id) AS purchase_count
FROM ranked_transactions
WHERE rank_num = 1
GROUP BY
  transaction_date,
  user_id
ORDER BY
  transaction_date;
```
> [!NOTE]
> The window function approach ranks all transactions for each user in descending order of date. By filtering for `rank_num = 1`, we effectively isolate all transactions that occurred on the most recent date. `RANK()` is used instead of `ROW_NUMBER()` to correctly handle cases where a user might have transactions at the same latest timestamp.
