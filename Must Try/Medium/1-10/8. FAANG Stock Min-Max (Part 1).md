# Highest and Lowest Monthly Stock Prices

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find the highest and lowest opening stock prices for each ticker symbol, along with the specific month and year ('Mon-YYYY') in which these prices occurred.

## 2. Data Model

### 2.1. `stock_prices` Table
Contains historical daily performance data for various stocks.
| Column Name | Type     | Description                                               |
|:------------|:---------|:----------------------------------------------------------|
| date        | datetime | The specified date (mm/dd/yyyy) of the stock data.        |
| ticker      | varchar  | The stock ticker symbol (e.g., AAPL).                     |
| open        | decimal  | The opening price of the stock at the start of the day.   |
| high        | decimal  | The highest price reached by the stock during the day.    |
| low         | decimal  | The lowest price reached by the stock during the day.     |
| close       | decimal  | The closing price of the stock at the end of the day.     |

## 3. Incremental Query Construction
The solution requires finding two independent pieces of information for each ticker (the highest open and the lowest open) and then combining them. A multi-CTE approach is ideal for this.

### 3.1. Step 1: Rank All Prices Within Each Ticker
First, we need to process the raw data to rank every opening price for each stock in two ways: from highest to lowest and from lowest to highest. This will allow us to easily identify the #1 rank in both categories.

> [!TIP]
> The `TO_CHAR(date, 'Mon-YYYY')` function (PostgreSQL/Oracle syntax) is used to format the `date` into the required 'Month-Year' string. The equivalent in SQL Server is `FORMAT(date, 'MMM-yyyy')` and in MySQL is `DATE_FORMAT(date, '%b-%Y')`.

```sql
-- This query will form our first CTE
SELECT
    ticker,
    TO_CHAR(date, 'Mon-YYYY') AS month_year,
    open,
    -- Rank prices from highest to lowest for each ticker
    ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY open DESC) AS highest_rank,
    -- Rank prices from lowest to highest for each ticker
    ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY open ASC) AS lowest_rank
FROM
    stock_prices;
```
> [!IMPORTANT]
> - `PARTITION BY ticker` is crucial. It tells the `ROW_NUMBER()` function to restart its counting for each new ticker symbol.
> - We create two separate rankings in the same step for efficiency. `highest_rank` will have `1` for the highest open price, and `lowest_rank` will have `1` for the lowest open price.

### 3.2. Step 2: Isolate the Highest and Lowest Price Records
Using the ranked data from Step 1, we can now easily filter for the rows with rank `1`. We will do this in two separate CTEs to keep the logic clean.

#### 3.2.1. Finding the Highest Open Price Record
We filter the ranked data for rows where `highest_rank = 1`.

```sql
-- This query will form the second CTE
SELECT
    ticker,
    month_year AS highest_mth,
    open AS highest_open
FROM
    monthly_data -- Assumes the query from Step 1 is in a CTE named monthly_data
WHERE
    highest_rank = 1;
```

#### 3.2.2. Finding the Lowest Open Price Record
Similarly, we filter for rows where `lowest_rank = 1`.
```sql
-- This query will form the third CTE
SELECT
    ticker,
    month_year AS lowest_mth,
    open AS lowest_open
FROM
    monthly_data -- Assumes the query from Step 1 is in a CTE named monthly_data
WHERE
    lowest_rank = 1;
```

### 3.3. Step 3: Combine the Highest and Lowest Results
We now have two tables: one with the highest price info per ticker, and one with the lowest. We can join them on `ticker` to get the desired final output.

```sql
SELECT
    h.ticker,
    h.highest_mth,
    h.highest_open,
    l.lowest_mth,
    l.lowest_open
FROM
    highest_open h -- Assumes the CTE from 3.2.1
INNER JOIN
    lowest_open l ON h.ticker = l.ticker; -- Assumes the CTE from 3.2.2
```

## 4. Final Solution
The complete query combines all steps using Common Table Expressions (CTEs) for readability and modularity.

```sql
WITH monthly_data AS (
  -- Step 1: Format date and rank all open prices for each ticker
  SELECT
    ticker,
    TO_CHAR(date, 'Mon-YYYY') AS month_year,
    open,
    ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY open DESC) AS highest_rank,
    ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY open ASC) AS lowest_rank
  FROM stock_prices
),
highest_open AS (
  -- Step 2a: Isolate the single record with the highest open price per ticker
  SELECT
    ticker,
    month_year AS highest_mth,
    open AS highest_open
  FROM monthly_data
  WHERE highest_rank = 1
),
lowest_open AS (
  -- Step 2b: Isolate the single record with the lowest open price per ticker
  SELECT
    ticker,
    month_year AS lowest_mth,
    open AS lowest_open
  FROM monthly_data
  WHERE lowest_rank = 1
)
-- Step 3: Join the highest and lowest price data together
SELECT
  h.ticker,
  h.highest_mth,
  h.highest_open,
  l.lowest_mth,
  l.lowest_open
FROM highest_open h
INNER JOIN lowest_open l ON h.ticker = l.ticker
ORDER BY h.ticker;
```

## 5. Result Verification

### 5.1. Example Output
| ticker | highest_mth | highest_open | lowest_mth | lowest_open |
|:-------|:------------|:-------------|:-----------|:------------|
| AAPL   | May-2023    | 176.76       | Jan-2023   | 142.28      |

### 5.2. Explanation
For the ticker `AAPL`, the query correctly identified that its highest opening price of `$176.76` occurred in `May-2023` and its lowest opening price of `$142.28` occurred in `Jan-2023`. The results are presented in a single, consolidated row as required.
