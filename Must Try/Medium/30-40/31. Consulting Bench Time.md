# 31.Calculating Consultant Bench Time

## 1. The Business Question
The objective of this query is to determine the amount of time consultants spend "on the bench," which is a common metric in professional services and consulting firms. The specific business question is:

**"Assuming a 365-day year, how many days was each consultant 'on the bench' (i.e., not actively staffed on a consulting engagement)? Provide a list of each consultant's employee ID and their total calculated bench days."**

> [!NOTE]
> "Bench time" is a key performance indicator. It represents the number of workable days an employee is not assigned to a billable client project. Minimizing bench time is a primary goal for optimizing resource utilization.

## 2. Assumed Table Schema
The query involves two tables, `staffing` and `consulting_engagements`. A plausible schema would be:

```sql
-- Table: staffing
-- Maps employees to specific jobs or roles.
CREATE TABLE staffing (
    staffing_id   INT PRIMARY KEY,
    employee_id   INT NOT NULL,
    job_id        INT NOT NULL,
    is_consultant BOOLEAN NOT NULL -- A flag to identify if the role is a consultant role
);

-- Table: consulting_engagements
-- Stores details about each specific client project or engagement.
CREATE TABLE consulting_engagements (
    job_id          INT PRIMARY KEY,
    engagement_name VARCHAR(255) NOT NULL,
    start_date      DATE NOT NULL, -- The start date of the project
    end_date        DATE NOT NULL  -- The end date of the project
);
```
> [!IMPORTANT]
> The `is_consultant` flag is critical. It allows us to isolate the analysis to only the relevant employee cohort and exclude internal or non-billable roles from the calculation.

## 3. Solution Approaches

### 3.1. Method 1: Using a Common Table Expression (CTE)
This approach breaks the problem into two logical steps, which enhances readability and makes the query easier to debug.

```sql
-- Step 1: Calculate the duration of each individual consulting assignment.
WITH consulting_days_tbl AS (
    SELECT
        s.employee_id,
        (ce.end_date - ce.start_date) + 1 AS non_bench_days
    FROM
        staffing AS s
    INNER JOIN
        consulting_engagements AS ce ON s.job_id = ce.job_id
    WHERE
        s.is_consultant = TRUE
)
-- Step 2: Sum up all assignment days for each employee and subtract from a full year.
SELECT
    employee_id,
    365 - SUM(non_bench_days) AS bench_days
FROM
    consulting_days_tbl
GROUP BY
    employee_id;
```

#### 3.1.1. Explanation

1.  **The `consulting_days_tbl` CTE**:
    -   This CTE first calculates the duration of every single project assignment for all consultants.
    -   An `INNER JOIN` links an `employee_id` from the `staffing` table to the project `start_date` and `end_date` in the `consulting_engagements` table.
    -   `(ce.end_date - ce.start_date) + 1`: This expression calculates the duration of the engagement.

> [!TIP]
> The `+ 1` is crucial for making the date calculation **inclusive**. For a project that starts and ends on the same day, `end_date - start_date` would be 0. Adding 1 correctly counts this as 1 day of work.

2.  **The Final Query**:
    -   This part of the query aggregates the results from the CTE.
    -   `GROUP BY employee_id`: It groups all the project durations for each individual consultant.
    -   `365 - SUM(non_bench_days)`: For each employee, it first `SUM`s up the days they spent on all their projects (`non_bench_days`) and then subtracts this total from 365 to get the final `bench_days`.

> [!NOTE]
> The CTE approach is highly readable because it logically separates the "calculate individual durations" step from the "aggregate per employee" step. This makes the query self-documenting.

### 3.2. Method 2: Direct Aggregation without CTE
For a query this straightforward, you can achieve the same result without a CTE by combining the logic into a single query block.

```sql
SELECT
    s.employee_id,
    365 - SUM((ce.end_date - ce.start_date) + 1) AS bench_days
FROM
    staffing AS s
INNER JOIN
    consulting_engagements AS ce ON s.job_id = ce.job_id
WHERE
    s.is_consultant = TRUE
GROUP BY
    s.employee_id;
```

#### 3.2.1. Explanation
This query performs the same logical steps but in a more condensed form.
1.  It first joins the tables and filters for consultants.
2.  It then immediately groups the resulting rows by `employee_id`.
3.  The `SUM((ce.end_date - ce.start_date) + 1)` expression is applied directly to each group. It calculates the duration for each project within the group and sums them up in a single operation.
4.  This total sum is then subtracted from `365` to get the final `bench_days`.

> [!CAUTION]
> While this method is more compact, nesting the calculation inside the `SUM` function can sometimes be slightly less readable for those new to the query. Both methods are functionally identical and will likely be optimized to a similar execution plan by modern database engines.

## 4. Key Assumptions & Limitations

> [!WARNING]
> Both methods rely on a hardcoded `365` days for the year. This logic is flawed as it does not account for **leap years**. A more robust real-world solution would need to handle this, perhaps by dynamically determining the number of days in the year being analyzed.

> [!IMPORTANT]
> The query calculates bench time over an unspecified total period. In a real-world scenario, you would almost always include a filter for a specific time frame (e.g., a single calendar year) to make the analysis meaningful, like `WHERE EXTRACT(YEAR FROM ce.start_date) = 2023`. Without this, projects spanning multiple years could complicate the interpretation.
