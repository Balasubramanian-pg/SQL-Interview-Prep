# 30.Department vs. Company Average Salary Comparison

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query that, for each month, compares a department's average salary against the entire company's average salary. The output will classify the department's average as 'higher', 'lower', or 'same'.

## 2. Data Model

### 2.1. `salary` Table
Contains salary payment records for each employee.
| id | employee_id | amount | pay_date   |
|:---|:------------|:-------|:-----------|
| 1  | 1           | 9000   | 2017-03-31 |
| 2  | 2           | 6000   | 2017-03-31 |
| 3  | 3           | 10000  | 2017-03-31 |

### 2.2. `employee` Table
Maps employees to their respective departments.
| employee_id | department_id |
|:------------|:--------------|
| 1           | 1             |
| 2           | 2             |
| 3           | 2             |

## 3. Incremental Query Construction
We will build the query step-by-step to understand the logic. The core of this solution relies on window functions, which allow us to perform calculations across sets of rows while keeping the individual rows.

### 3.1. Step 1: Combine Salary and Department Data
First, we need to associate each salary payment with a department. We achieve this by joining the `salary` and `employee` tables.

```sql
SELECT
    s.employee_id,
    e.department_id,
    s.amount,
    s.pay_date
FROM
    salary s
JOIN
    employee e ON s.employee_id = e.employee_id;
```
> [!TIP]
> If the joining column has the same name in both tables (like `employee_id` here), you can use the more concise `USING` clause: `... FROM salary s JOIN employee e USING (employee_id)`.

### 3.2. Step 2: Calculate Monthly Averages with Window Functions
Now, for each salary record, we want to know two things: the average salary for its department *in that month*, and the average salary for the whole company *in that month*.

> [!IMPORTANT]
> A window function `(OVER (PARTITION BY ...))` calculates a value for each row based on a "window" of related rows. This is different from `GROUP BY`, which collapses rows into a single summary row.

```sql
SELECT
    DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,
    e.department_id,
    s.amount,
    -- Window 1: Department's average salary for the month
    AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m'), e.department_id) AS dept_avg,
    -- Window 2: Company's average salary for the month
    AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m')) AS comp_avg
FROM
    salary s
JOIN
    employee e USING (employee_id);
```
**Intermediate Result (for March 2017):**
| pay_month | department_id | amount | dept_avg | comp_avg    |
|:----------|:--------------|:-------|:---------|:------------|
| 2017-03   | 1             | 9000   | 9000.00  | 8333.33     |
| 2017-03   | 2             | 6000   | 8000.00  | 8333.33     |
| 2017-03   | 2             | 10000  | 8000.00  | 8333.33     |

> [!CAUTION]
> It is crucial to partition by the full year and month (`YYYY-MM`). Partitioning by `MONTH(pay_date)` alone would incorrectly group data from the same month across different years (e.g., March 2017 and March 2018 would be mixed).

### 3.3. Step 3: Put Logic into a CTE and Compare Averages
The previous query generates the correct averages but repeats them for every employee. To clean this up and perform the final comparison, we'll place the query into a Common Table Expression (CTE) and then select distinct results from it.

```sql
WITH MonthlyAverages AS (
    SELECT
        DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,
        e.department_id,
        AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m'), e.department_id) AS dept_avg,
        AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m')) AS comp_avg
    FROM
        salary s
    JOIN
        employee e USING (employee_id)
)
SELECT DISTINCT
    pay_month,
    department_id,
    CASE
        WHEN dept_avg > comp_avg THEN 'higher'
        WHEN dept_avg < comp_avg THEN 'lower'
        ELSE 'same'
    END AS comparison
FROM
    MonthlyAverages;
```
> [!NOTE]
> We use `SELECT DISTINCT` because the CTE `MonthlyAverages` has one row for each employee payment. Since the `dept_avg` and `comp_avg` are the same for all employees in the same department and month, we only need one of these identical rows for our final output.

## 4. Final Solution
The final step is to add ordering for a clean, predictable output.

```sql
-- Create a CTE to calculate department and company average salaries per month
WITH MonthlyAverages AS (
    SELECT
        DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,
        e.department_id,
        -- Department average salary for the month
        AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m'), e.department_id) AS dept_avg,
        -- Company-wide average salary for the month
        AVG(s.amount) OVER(PARTITION BY DATE_FORMAT(pay_date, '%Y-%m')) AS comp_avg
    FROM
        salary s
    JOIN
        employee e USING (employee_id)
)
-- Select unique pay_month/department_id and compare their averages
SELECT DISTINCT
    pay_month,
    department_id,
    CASE
        WHEN dept_avg > comp_avg THEN 'higher'
        WHEN dept_avg < comp_avg THEN 'lower'
        ELSE 'same'
    END AS comparison
FROM
    MonthlyAverages
ORDER BY
    pay_month DESC, department_id;
```

## 5. Key Concepts
*   **Common Table Expression (CTE)**: The `WITH` clause creates a temporary, named result set (`MonthlyAverages`) that makes the main query cleaner and more readable.
*   **Window Functions**: `AVG() OVER (PARTITION BY ...)` calculates an average across a specified set of rows (a "partition") without collapsing them.
*   **`DATE_FORMAT()`**: A function (MySQL syntax) to extract and format date parts into a `YYYY-MM` string. Equivalents are `TO_CHAR(pay_date, 'YYYY-MM')` in PostgreSQL/Oracle or `FORMAT(pay_date, 'yyyy-MM')` in SQL Server.
*   **`CASE` Statement**: Used to implement conditional logic to return the 'higher', 'lower', or 'same' string based on the comparison of the two averages.
