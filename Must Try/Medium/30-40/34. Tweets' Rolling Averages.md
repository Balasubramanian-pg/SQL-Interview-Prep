# 34.Three-Day Rolling Tweet Average

## 1. Problem Statement

### 1.1. Objective
Given a table of tweet data over a specified time period, calculate the 3-day rolling average of tweets for each user. Output the user ID, tweet date, and rolling averages rounded to 2 decimal places.

### 1.2. Notes
-   A rolling average, also known as a moving average or running mean, is a time-series technique that examines trends in data over a specified period of time.
-   In this case, we want to determine how the tweet count for each user changes over a 3-day period.

> [!IMPORTANT]
> The "3-day rolling average" for any given day is the average of the tweet counts for that day and the two preceding days. This is a "sliding window" calculation.

### 1.3. Input Table: `tweets`

|Column Name|Type|
|---|---|
|user_id|integer|
|tweet_date|timestamp|
|tweet_count|integer|

### 1.4. Example

#### 1.4.1. `tweets` Example Input:

|user_id|tweet_date|tweet_count|
|---|---|---|
|111|06/01/2022 00:00:00|2|
|111|06/02/2022 00:00:00|1|
|111|06/03/2022 00:00:00|3|
|111|06/04/2022 00:00:00|4|
|111|06/05/2022 00:00:00|5|

#### 1.4.2. Example Output:

|user_id|tweet_date|rolling_avg_3d|
|---|---|---|
|111|06/01/2022 00:00:00|2.00|
|111|06/02/2022 00:00:00|1.50|
|111|06/03/2022 00:00:00|2.00|
|111|06/04/2022 00:00:00|2.67|
|111|06/05/2022 00:00:00|4.00|

## 2. Conceptual Approach
To calculate a rolling average, we need to define a "window" of rows for each record and then compute the average within that window. This is a perfect use case for SQL's window functions.

The logic for each row is to:
1.  Identify the user to ensure we are only averaging their own tweets.
2.  Look at the current day's tweet count.
3.  Look at the previous day's tweet count (if it exists).
4.  Look at the tweet count from two days ago (if it exists).
5.  Calculate the average of these values.

> [!NOTE]
> Window functions are the standard and most efficient way to perform rolling or running calculations in SQL. They avoid the need for complex and slow self-joins.

## 3. SQL Solution

```sql
SELECT
  user_id,
  tweet_date,
  ROUND(
    AVG(tweet_count) OVER (
      PARTITION BY user_id
      ORDER BY tweet_date
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ),
    2
  ) AS rolling_avg_3d
FROM tweets
ORDER BY user_id, tweet_date;
```

## 4. Code Breakdown

### 4.1. `AVG(tweet_count) OVER (...)`
This is the core of the query. It specifies that we want to calculate an average of the `tweet_count` column over a specific "window" of rows. The `OVER` clause defines that window.

### 4.2. `PARTITION BY user_id`
-   This is a crucial instruction that divides the data into separate groups, or partitions, for each `user_id`.
-   The window function will operate independently on each partition. This ensures that the rolling average for user `111` is calculated using only user `111`'s tweets, and it will reset for the next user.

> [!IMPORTANT]
> Without `PARTITION BY user_id`, the query would calculate a single rolling average across all users combined, which would be incorrect.

### 4.3. `ORDER BY tweet_date`
-   This clause sorts the rows within each partition chronologically.
-   This ordering is mandatory for any rolling or running calculation, as it defines the sequence of the data and tells the database what "preceding" means.

> [!CAUTION]
> The `ORDER BY` clause inside the `OVER()` block is what enables the concept of a "sliding window." The final `ORDER BY` at the end of the query is just for presentation.

### 4.4. `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`
-   This is the **window frame clause**, and it defines the exact size of the sliding window for each row.
-   It tells the `AVG()` function to include the current row and the two rows that come immediately before it in the ordered partition.
-   For the very first row in a partition, the window only includes that row. For the second row, it includes that row and the one before it. The window size grows until it reaches the maximum size of 3 rows.

> [!TIP]
> This frame is easily adaptable. For a 7-day rolling average, you would change this clause to `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`.

## 5. Tracing the Example
Let's trace the calculation for user 111 to see how the window slides:

1.  **Date: 06/01, Count: 2**
    -   Window: `(2)` (current row only; no preceding rows exist)
    -   Average: `2 / 1 = 2.00`

2.  **Date: 06/02, Count: 1**
    -   Window: `(2, 1)` (current row and 1 preceding row)
    -   Average: `(2 + 1) / 2 = 1.50`

> [!NOTE]
> For the first few rows in any partition, the window will be smaller than the specified "3 days" because there are not enough preceding rows. This is the correct and expected behavior for a rolling average.

3.  **Date: 06/03, Count: 3**
    -   Window: `(2, 1, 3)` (current row and 2 preceding rows)
    -   Average: `(2 + 1 + 3) / 3 = 2.00`

4.  **Date: 06/04, Count: 4**
    -   Window: `(1, 3, 4)` (the window has now "slid" forward one day)
    -   Average: `(1 + 3 + 4) / 3 = 2.67`

5.  **Date: 06/05, Count: 5**
    -   Window: `(3, 4, 5)`
    -   Average: `(3 + 4 + 5) / 3 = 4.00`

> [!TIP]
> This problem uses `ROWS BETWEEN`, which looks at physical row positions. An alternative is `RANGE BETWEEN`, which looks at values in the `ORDER BY` column. For daily data with no gaps, they behave similarly. However, `ROWS` is often more explicit and predictable for this type of problem.

