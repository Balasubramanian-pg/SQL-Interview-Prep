# 36.Country-Level Invalid Search Percentage

## 1. The Business Question
The objective of this query is to aggregate search quality metrics from a category level up to a country level. The specific business question is:

**"What is the overall invalid search result percentage for each country? The raw data provides search volumes and invalid rates per category, so we need to aggregate these to find the unified country-level percentage."**

> [!IMPORTANT]
> This is a **weighted average** problem. You cannot simply take the `AVG(invalid_result_pct)` for a country. A category with 1,000,000 searches should have a much greater impact on the country's overall percentage than a category with only 100 searches.

## 2. Assumed Table Schema
The query references a single table, `search_category`, which contains pre-aggregated data. A plausible schema would be:

```sql
-- Table: search_category
-- Stores aggregated search metrics for different categories within each country.
CREATE TABLE search_category (
    country            VARCHAR(100) NOT NULL,
    search_category  VARCHAR(255) NOT NULL,
    num_search         BIGINT,                 -- Total number of searches for this category
    invalid_result_pct DECIMAL(5, 2)           -- The percentage of invalid results for this category
);
```

> [!TIP]
> Since the primary aggregation is by country, an index on the `country` column would be beneficial for performance on large datasets.
>
> `CREATE INDEX idx_search_country ON search_category (country);`

## 3. Solution Approaches

### 3.1. Method 1: Using a Common Table Expression (CTE)
This approach is very readable and logical because it breaks the problem into two distinct steps: first, calculating the raw component counts, and second, calculating the final percentage from those counts.

```sql
-- Step 1: Calculate the total number of searches and the total number of invalid searches for each country.
WITH search_details AS (
    SELECT
        country,
        SUM(num_search) AS total_search,
        SUM(num_search * (invalid_result_pct / 100.0)) AS invalid_searches
    FROM
        search_category
    WHERE
        num_search IS NOT NULL
        AND invalid_result_pct IS NOT NULL
    GROUP BY
        country
)
-- Step 2: Use the aggregated numbers to calculate the final country-level percentage.
SELECT
    country,
    total_search,
    ROUND((invalid_searches / total_search) * 100.0, 2) AS invalid_result_pct
FROM
    search_details;
```

#### 3.1.1. Explanation

1.  **The `search_details` CTE**:
    -   This CTE's purpose is to "reconstitute" the raw counts needed for a proper weighted average.
    -   `WHERE ... IS NOT NULL`: This is good practice to filter out any rows with missing data that could lead to calculation errors.
    -   `GROUP BY country`: This ensures the `SUM` functions aggregate all categories belonging to a single country.
    -   `SUM(num_search)`: This calculates the denominator—the total number of searches in the country.
    -   `SUM(num_search * (invalid_result_pct / 100.0))`: This is the most critical part. It calculates the numerator—the total *raw count* of invalid searches. For each category, `num_search * (invalid_result_pct / 100.0)` converts the percentage back into a raw number (e.g., 1000 searches * 5% = 50 invalid searches). The `SUM` then adds these raw numbers up across all categories in the country.

> [!CAUTION]
> Using `100.0` instead of `100` is important for ensuring floating-point division, which is necessary for calculations involving percentages.

2.  **The Final `SELECT` Statement**:
    -   This query runs on the aggregated data from the CTE.
    -   `ROUND((invalid_searches / total_search) * 100.0, 2)`: This is the final weighted average calculation. It takes the total invalid searches, divides by the total searches, converts the resulting ratio back to a percentage, and rounds it.

> [!NOTE]
> The CTE approach is highly readable because it separates the logic. You can easily test the CTE's query by itself to validate the intermediate `total_search` and `invalid_searches` counts before proceeding.

### 3.2. Method 2: Single Aggregation Query
You can achieve the same result without a CTE by performing all calculations in a single, more compact query block.

```sql
SELECT
    country,
    SUM(num_search) AS total_search,
    ROUND(
        SUM(num_search * (invalid_result_pct / 100.0)) -- Numerator: Total invalid searches
        / SUM(num_search)                              -- Denominator: Total searches
        * 100.0,
        2
    ) AS invalid_result_pct
FROM
    search_category
WHERE
    num_search IS NOT NULL
    AND invalid_result_pct IS NOT NULL
GROUP BY
    country;
```

#### 3.2.1. Explanation
This method performs the same logic but combines the calculation of the components and the final percentage into a single step.

1.  **`FROM ... WHERE ... GROUP BY ...`**: The filtering and grouping are identical to the first method.
2.  **The `ROUND(...)` Expression**: This single, large expression calculates the final weighted percentage directly within the `SELECT` clause.
    -   The numerator is the `SUM` of the reconstituted invalid search counts.
    -   The denominator is the `SUM` of the total search counts.
    -   The division, multiplication, and rounding are all performed in one go.

> [!IMPORTANT]
> Mathematically, the formula `SUM(value * weight) / SUM(weight)` is the standard definition of a weighted average. In this problem, `num_search` is the "weight," and `invalid_result_pct` is the "value." The query perfectly implements this formula.

## 4. Comparison of Methods
-   **CTE Method**: Often preferred for clarity and debugging. It breaks the problem into logical, testable steps.
-   **Single Query Method**: More concise. For this specific problem, performance will likely be identical, so the choice is primarily about readability and coding style.

> [!TIP]
> For more complex calculations involving multiple weighted averages or additional steps, the CTE method becomes increasingly superior for maintaining readable and manageable code.

