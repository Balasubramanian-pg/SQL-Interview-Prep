# Mutual Two-Way Relationships

## 1. The Business Question
The objective of this query is to identify and quantify reciprocal relationships within a payment system. The specific business question is:

**"How many unique, two-way (or mutual) money transfer relationships exist in our data? A two-way relationship is defined as one where User A has paid User B, and User B has also paid User A at some point."**

> [!IMPORTANT]
> A "relationship" is between two unique users (e.g., User 1 and User 2). We are counting the number of these unique pairs, not the number of transactions.

## 2. Assumed Table Schema
The query references a single table, `payments`. A plausible schema for this table would be:

```sql
-- Table: payments
-- Stores a record for every money transfer between two users.
CREATE TABLE payments (
    payment_id    INT PRIMARY KEY,
    payer_id      INT NOT NULL,           -- The ID of the user sending the money
    recipient_id  INT NOT NULL,           -- The ID of the user receiving the money
    amount        DECIMAL(10, 2) NOT NULL
);
```

> [!TIP]
> To significantly improve performance for this type of query, a composite index on the `(payer_id, recipient_id)` pair is highly recommended. This allows the database to quickly look up payment relationships.
>
> `CREATE INDEX idx_payments_pair ON payments (payer_id, recipient_id);`

## 3. Solution Approaches

### 3.1. Method 1: Using `INTERSECT`
This is a very clever and concise way to solve this problem by leveraging SQL's set operators.

> [!NOTE]
> The `INTERSECT` operator takes the results of two queries and returns only the rows that appear in **both** result sets. It's a powerful tool for finding commonalities.

```sql
-- Step 1: Find all pairs of users (A, B) where A paid B and B paid A.
WITH two_way_rel AS (
    -- This gets all (payer, recipient) pairs that exist.
    SELECT
        payer_id,
        recipient_id
    FROM
        payments

    INTERSECT

    -- This gets all (recipient, payer) pairs.
    SELECT
        recipient_id,
        payer_id
    FROM
        payments
)
-- Step 2: Count the resulting pairs and divide by two to get unique relationships.
SELECT
    COUNT(*) / 2 AS unique_relationships
FROM
    two_way_rel;
```

#### 3.1.1. Explanation

1.  **The `two_way_rel` CTE**:
    -   The query above the `INTERSECT` operator selects all direct payment pairs, e.g., `(1, 2)` if user 1 paid user 2.
    -   The query below the `INTERSECT` operator selects all *inverse* pairs, e.g., `(2, 1)` if user 2 paid user 1.
    -   `INTERSECT` finds the overlap. For a mutual relationship to exist between user 1 and 2, the pair `(1, 2)` must exist in the top set, and the pair `(2, 1)` must exist in the bottom set. When they intersect, it means a mutual relationship exists.
    -   Crucially, the `two_way_rel` result set will contain **both** `(1, 2)` and `(2, 1)` for a single mutual relationship.

2.  **The Final `SELECT` Statement**:
    -   `COUNT(*) / 2`: Since each mutual relationship is represented by two rows in the CTE (e.g., `(1, 2)` and `(2, 1)`), simply counting the rows would double the true number of relationships. Dividing the total count by 2 corrects for this double-counting.

> [!WARNING]
> This "divide by 2" trick is a simple way to de-duplicate, but it relies on the fact that every relationship will be perfectly mirrored. The self-join method with a `WHERE` condition is often considered a safer pattern for de-duplication.

### 3.2. Method 2: Using a `SELF-JOIN` (Recommended)
A more common and explicit way to solve this type of "find the mirror image" problem is with a self-join.

> [!TIP]
> A self-join is when you join a table to itself. It's a fundamental pattern for comparing rows within the same table, such as finding employees who have the same manager or, in this case, transactions that are inverses of each other.

```sql
SELECT
    COUNT(*) AS unique_relationships
FROM
    payments AS p1
INNER JOIN
    payments AS p2
    ON p1.payer_id = p2.recipient_id
    AND p1.recipient_id = p2.payer_id
WHERE
    p1.payer_id < p1.recipient_id;
```

#### 3.2.1. Explanation

1.  **The `SELF-JOIN`**:
    -   `FROM payments AS p1 INNER JOIN payments AS p2 ON ...`: We are treating the `payments` table as two separate, virtual tables, `p1` and `p2`.
    -   The `ON` clause is the core logic. It looks for a transaction in `p1` (e.g., user `A` paid user `B`) and tries to find its exact "mirror" transaction in `p2` (where user `B` paid user `A`).

2.  **The `WHERE` Clause**:
    -   `WHERE p1.payer_id < p1.recipient_id`: This is a clever and crucial trick to avoid double-counting.
    -   Without this condition, the join would find the pair for `(A -> B)` and `(B -> A)`, and also for `(B -> A)` and `(A -> B)`, resulting in two rows for the same relationship.
    -   By enforcing that we only consider rows where the `payer_id` is smaller than the `recipient_id`, we ensure that for any given relationship (e.g., between users 1 and 2), we only count it **once** (when we process the `1 -> 2` transaction) and ignore the other direction.

> [!IMPORTANT]
> This `id1 < id2` pattern is the standard, robust way to de-duplicate pairs of items in SQL, whether they are users, products, or any other entity.

3.  **The `COUNT(*)`**:
    -   Since the `WHERE` clause has already handled the de-duplication of relationships, we can now simply count the remaining rows to get our final answer.

## 4. Comparison of Methods
-   **`INTERSECT` Method**: Elegant and concise, but the "divide by 2" logic can feel less explicit.
-   **`SELF-JOIN` Method**: More verbose, but the `WHERE id1 < id2` pattern is a very standard and robust technique for de-duplication that is widely understood and applicable to many problems. It is generally the preferred and more scalable solution.
