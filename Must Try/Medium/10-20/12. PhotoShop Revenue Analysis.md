# Revenue from Photoshop Users on Other Products

## 1. The Business Question
The objective of this query is to analyze the spending habits of a specific customer segment. The business question is:

**"For customers who have purchased Photoshop, what is the total revenue generated from their purchases of *other* Adobe products (i.e., everything except Photoshop)? List the total revenue for each of these customers."**

> [!IMPORTANT]
> This query requires a two-part logic: first, identifying a cohort of users (those who bought Photoshop), and second, analyzing a different subset of their behavior (their spending on non-Photoshop products).

## 2. Assumed Table Schema
The query references a single table, `adobe_transactions`. A plausible schema for this table would be:

```sql
-- Table: adobe_transactions
-- Stores a record for every product purchase made by a customer.
CREATE TABLE adobe_transactions (
    transaction_id   INT PRIMARY KEY,
    customer_id      INT NOT NULL,           -- The ID of the customer
    product          VARCHAR(100) NOT NULL,  -- The name of the product purchased
    revenue          DECIMAL(10, 2) NOT NULL -- The revenue from this transaction
);
```

> [!TIP]
> To optimize this query, a composite index on `(customer_id, product)` would be highly effective, as it would speed up both the subquery's search for Photoshop customers and the main query's grouping and filtering.
>
> `CREATE INDEX idx_adobe_customer_product ON adobe_transactions (customer_id, product);`

## 3. Solution Approaches

### 3.1. Method 1: Subquery with `IN`
This is a clear and direct way to express the logic, where the subquery first identifies the target customers, and the main query then analyzes them.

```sql
SELECT
    customer_id,
    SUM(revenue) AS revenue
FROM
    adobe_transactions
WHERE
    product != 'Photoshop'
    AND customer_id IN (
        SELECT DISTINCT
            customer_id
        FROM
            adobe_transactions
        WHERE
            product = 'Photoshop'
    )
GROUP BY
    customer_id;
```

#### 3.1.1. Explanation

1.  **The Subquery**:
    -   `SELECT DISTINCT customer_id FROM adobe_transactions WHERE product = 'Photoshop'`: This inner query is executed first. It scans the table to find every transaction for 'Photoshop' and compiles a unique list of `customer_id`s. This list represents our target cohort: "Photoshop customers."

> [!NOTE]
> Modern database optimizers are very good at handling `IN` clauses with subqueries. They often rewrite them internally into more efficient joins.

2.  **The Main Query**:
    -   `WHERE customer_id IN (...)`: The main query then filters the `adobe_transactions` table, keeping only the rows where the `customer_id` is present in the list generated by the subquery.
    -   `AND product != 'Photoshop'`: A second filter is applied to exclude all Photoshop transactions from the calculation.
    -   The combination of these two filters leaves us with all non-Photoshop transactions made by customers who have, at some point, also bought Photoshop.
    -   `GROUP BY customer_id`: This aggregates the filtered rows by customer.
    -   `SUM(revenue)`: This calculates the total revenue from their non-Photoshop purchases.

### 3.2. Method 2: Conditional Aggregation with `HAVING` (Recommended)
An alternative and often more performant approach is to use conditional aggregation in a single query block, avoiding an explicit subquery.

> [!TIP]
> This method processes all customers in a single pass. The `GROUP BY` creates a summary for every customer, the `HAVING` clause filters these summaries to find the target cohort, and the `SELECT` clause calculates the final result for that cohort.

```sql
SELECT
    customer_id,
    SUM(CASE WHEN product != 'Photoshop' THEN revenue ELSE 0 END) AS revenue
FROM
    adobe_transactions
GROUP BY
    customer_id
HAVING
    -- This condition filters for groups (customers) that have at least one Photoshop purchase.
    COUNT(CASE WHEN product = 'Photoshop' THEN 1 END) > 0;
```

#### 3.2.1. Explanation

1.  **`GROUP BY customer_id`**: This is the first crucial step. It creates a summary group for **every single customer** in the table. The following `HAVING` and `SELECT` clauses will operate on these groups.

2.  **The `HAVING` Clause**:
    -   The `HAVING` clause is like a `WHERE` clause for groups. It filters the results *after* the `GROUP BY` has been applied.
    -   `COUNT(CASE WHEN product = 'Photoshop' THEN 1 END)`: This is a conditional count. For each customer's group, it counts how many of their transactions were for 'Photoshop'.
    -   `... > 0`: The condition keeps only the customer groups that have one or more Photoshop purchases. This effectively replaces the `IN (SELECT ...)` subquery from the first method.

> [!IMPORTANT]
> The `HAVING` clause is the key to identifying our customer cohort in this method. It lets us check a condition on the entire group of a customer's transactions.

3.  **The `SELECT` Clause**:
    -   This is executed on the groups that passed the `HAVING` filter (our Photoshop customers).
    -   `SUM(CASE WHEN product != 'Photoshop' THEN revenue ELSE 0 END)`: This is a **conditional sum**. It iterates through all transactions in the customer's group.
        -   If a transaction is *not* for Photoshop, its `revenue` is included in the sum.
        -   If it *is* for Photoshop, `0` is added, effectively ignoring it in the total.
    -   This correctly calculates the total revenue from all non-Photoshop products.

> [!WARNING]
> This conditional aggregation method can be more efficient as it typically requires only one scan over the table. It's a powerful pattern for solving problems that require you to check for one condition while aggregating on another.
