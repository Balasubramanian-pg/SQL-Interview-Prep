# Finding the Second Highest Salary

## 1. Problem Statement

### 1.1. Objective
Imagine you're an HR analyst at a tech company tasked with analyzing employee salaries. Your manager is keen on understanding the pay distribution and asks you to determine the second highest salary among all employees.

### 1.2. Constraint
-   It's possible that multiple employees may share the same second highest salary. In case of such a tie, the salary value should be displayed only once.

> [!IMPORTANT]
> The query should return a single value representing the second highest salary. If no second highest salary exists (e.g., all employees earn the same amount, or there is only one employee), the query should ideally return `NULL` or an empty result set.

### 1.3. Input Schema: `employee`

|column_name|type|description|
|---|---|---|
|employee_id|integer|The unique ID of the employee.|
|name|string|The name of the employee.|
|salary|integer|The salary of the employee.|
|department_id|integer|The department ID of the employee.|
|manager_id|integer|The manager ID of the employee.|

### 1.4. Example

#### 1.4.1. `employee` Example Input:

|employee_id|name|salary|department_id|manager_id|
|---|---|---|---|---|
|1|Emma Thompson|3800|1|6|
|2|Daniel Rodriguez|2230|1|7|
|3|Olivia Smith|2000|1|8|

#### 1.4.2. Example Output:

|second_highest_salary|
|---|
|2230|

## 2. Conceptual Approach
The core logic to find the second highest salary is to identify the maximum salary that is strictly less than the absolute maximum salary in the entire table.

1.  **Find the Maximum Salary**: First, determine the single highest salary across all employees.
2.  **Filter Below Maximum**: Create a subset of salaries that are all less than this absolute maximum.
3.  **Find the Maximum of the Subset**: The highest salary within this new subset is the second highest salary overall.

> [!NOTE]
> This approach naturally handles duplicates. Whether one or ten employees share the highest salary, the value is the same. The logic remains focused on finding the next distinct salary value down.

## 3. SQL Solution Approaches

### 3.1. Method 1: Subquery with `MAX()` (Most Compatible)
This method directly implements the conceptual approach and is compatible with nearly all SQL dialects.

```sql
SELECT
  MAX(salary) AS second_highest_salary
FROM employee
WHERE salary < (
  SELECT MAX(salary)
  FROM employee
);
```

#### 3.1.1. Explanation
1.  **Inner Subquery**: The subquery `(SELECT MAX(salary) FROM employee)` is executed first. It finds the single highest salary value in the table (e.g., `3800`).
2.  **Outer Query**: The main query then selects the `MAX(salary)` from a filtered set of rows.
3.  **`WHERE` Clause**: The condition `WHERE salary < ...` filters the table to include only employees whose salary is strictly less than the absolute maximum found by the subquery.
4.  The `MAX()` in the outer query then finds the highest salary from this filtered group, which is, by definition, the second highest salary overall.

> [!TIP]
> This approach is very robust. If no second highest salary exists (i.e., all employees have the same salary), the `WHERE` clause will not match any rows, and the `MAX()` function will correctly return `NULL`.

> [!CAUTION]
> This query relies on there being a distinct second highest value. It works perfectly for this problem but can be less flexible than window functions if you needed to find the 3rd or 4th highest salary.

### 3.2. Method 2: Using `DENSE_RANK()` Window Function
This is a modern and flexible approach for any Nth-highest problem.

```sql
WITH ranked_salaries AS (
  SELECT
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) as salary_rank
  FROM employee
)
SELECT DISTINCT
  salary AS second_highest_salary
FROM ranked_salaries
WHERE salary_rank = 2;
```
#### 3.2.1. Explanation
1.  **`ranked_salaries` CTE**: A window function is used to rank all salaries in descending order.
2.  `DENSE_RANK()`: This function is crucial. It assigns ranks to rows, and if there's a tie in salary, tied rows get the same rank, and no rank numbers are skipped. This is perfect for finding the Nth value.
3.  **Final `SELECT`**: The main query simply filters the CTE for rows where the rank is `2`.

> [!IMPORTANT]
> `DENSE_RANK()` is the correct choice here over `RANK()` or `ROW_NUMBER()`. `RANK()` would skip ranks after a tie (e.g., 1, 1, 3), and `ROW_NUMBER()` would arbitrarily assign different ranks to tied values. `DENSE_RANK()` ensures the second distinct value is always rank 2.

> [!NOTE]
> This method is easily adaptable. To find the 5th highest salary, you would just change the condition to `WHERE salary_rank = 5`.

### 3.3. Method 3: Using `OFFSET` and `FETCH`/`LIMIT`
This approach is concise and intuitive for simple top-N queries.

```sql
SELECT
    (SELECT DISTINCT salary
     FROM employee
     ORDER BY salary DESC
     LIMIT 1 OFFSET 1) AS second_highest_salary;
```

#### 3.3.1. Explanation
1.  `SELECT DISTINCT salary`: First, we get a unique list of all salaries.
2.  `ORDER BY salary DESC`: This list is sorted from highest to lowest.
3.  `OFFSET 1`: This clause skips the first row (the highest salary).
4.  `LIMIT 1`: This clause then selects the very next row, which is the second highest salary.

> [!WARNING]
> The `LIMIT ... OFFSET ...` syntax is common in PostgreSQL and MySQL. Other databases like SQL Server use a different syntax (`OFFSET 1 ROWS FETCH NEXT 1 ROWS ONLY`). This makes the `MAX()` subquery or window function approaches more portable.
