# Consecutive Days with High Visitor Count

## 1. Objective
> [!NOTE]
> Write a SQL query to find all records from a stadium's visitor log that are part of a sequence of **three or more consecutive days** where each day had **100 or more visitors**.

## 2. Data Model

### 2.1. `stadium` Table
Contains daily visitor counts for a stadium.
| id  | visit_date | people |
|:----|:-----------|:-------|
| 1   | 2017-01-01 | 10     |
| 2   | 2017-01-02 | 109    |
| 3   | 2017-01-03 | 150    |
| 4   | 2017-01-04 | 99     |
| 5   | 2017-01-05 | 145    |
| 6   | 2017-01-06 | 1455   |
| 7   | 2017-01-07 | 199    |
| 8   | 2017-01-08 | 188    |

## 3. Core Concept: The "Gaps and Islands" Problem
This type of problem, where we need to identify consecutive sequences of rows, is known as a "gaps and islands" problem. A clever way to solve this is by creating a grouping key that remains constant for all rows within a consecutive sequence but changes when a sequence is broken.

We can create this key using the formula: `id - ROW_NUMBER() OVER (ORDER BY id)`.

> [!IMPORTANT]
> **How the `id - ROW_NUMBER()` Trick Works:**
> - Assume `id` is a perfectly sequential integer (1, 2, 3, ...).
> - `ROW_NUMBER()` also generates a perfectly sequential integer (1, 2, 3, ...).
> - For consecutive rows, the difference between `id` and `ROW_NUMBER()` will be a constant value.
> - When there's a "gap" (a non-consecutive `id`), the difference will change, thus creating a new group. This allows us to group the "islands" of consecutive rows.

## 4. Incremental Query Construction
We will use multiple Common Table Expressions (CTEs) to build the solution logically.

### 4.1. Step 1: Filter for Popular Days
First, we only care about days where the visitor count was 100 or more.

```sql
SELECT
    id,
    visit_date,
    people
FROM
    stadium
WHERE
    people >= 100;
```
**Intermediate Result:**
| id  | visit_date | people |
|:----|:-----------|:-------|
| 2   | 2017-01-02 | 109    |
| 3   | 2017-01-03 | 150    |
| 5   | 2017-01-05 | 145    |
| 6   | 2017-01-06 | 1455   |
| 7   | 2017-01-07 | 199    |
| 8   | 2017-01-08 | 188    |

### 4.2. Step 2: Create a Grouping Key for Consecutive Days
Now, we apply the `id - ROW_NUMBER()` trick to the filtered data. This will assign a unique group ID to each consecutive sequence.

```sql
-- This will be our first CTE
SELECT
    id,
    visit_date,
    people,
    ROW_NUMBER() OVER(ORDER BY id) AS grp
FROM
    stadium
WHERE
    people >= 100;
```
**Intermediate Result (`popular_days` CTE):**
| id  | visit_date | people | `ROW_NUMBER()` | (`grp`) |
|:----|:-----------|:-------|:---------------|:----------------------------|
| 2   | 2017-01-02 | 109    | 1              | 1                           |
| 3   | 2017-01-03 | 150    | 2              | 1                           |
| 5   | 2017-01-05 | 145    | 3              | 2                           |
| 6   | 2017-01-06 | 1455   | 4              | 2                           |
| 7   | 2017-01-07 | 199    | 5              | 2                           |
| 8   | 2017-01-08 | 188    | 6              | 2                           |

> [!TIP]
> Notice how the `grp` value is `1` for the first sequence (id 2, 3) and `2` for the second sequence (id 5, 6, 7, 8). The gap at `id = 4` caused the group key to change.

### 4.3. Step 3: Find Groups with 3 or More Days
With our grouping key (`grp`), we can now count the number of days in each group and keep only the groups with a count of 3 or more.

```sql
-- This will be our second CTE
SELECT
    grp
FROM
    popular_days -- Assumes the query from Step 2 is in this CTE
GROUP BY
    grp
HAVING
    COUNT(*) >= 3;
```
**Intermediate Result (`consecutive_groups` CTE):**
| grp |
|:----|
| 2   |

Only group `2` qualifies, as it has 4 members. Group `1` is filtered out because it only has 2 members.

### 4.4. Step 4: Join Back to Get the Final Records
Finally, we select all records from our initial CTE (`popular_days`) where the `grp` value is in the list of qualifying groups we just found.

## 5. Final Solution
The complete query combines these steps for a clean, readable solution.
```sql
-- CTE 1: Filter for popular days and create a grouping key for consecutive sequences.
WITH popular_days AS (
    SELECT
        id,
        visit_date,
        people,
        id - ROW_NUMBER() OVER(ORDER BY id) AS grp
    FROM stadium
    WHERE people >= 100
),
-- CTE 2: Identify which of the groups have 3 or more consecutive days.
consecutive_groups AS (
    SELECT
        grp
    FROM popular_days
    GROUP BY grp
    HAVING COUNT(*) >= 3
)
-- Final Select: Retrieve all original rows that belong to the qualifying groups.
SELECT
    pd.id,
    pd.visit_date,
    pd.people
FROM
    popular_days pd
JOIN
    consecutive_groups cg ON pd.grp = cg.grp
ORDER BY
    pd.visit_date;
```
<img width="835" height="481" alt="image" src="https://github.com/user-attachments/assets/2a81304e-6dcf-4639-af58-0517aefa27d5" />

## 6. Result Analysis

### 6.1. Final Output
| id  | visit_date | people |
|:----|:-----------|:-------|
| 5   | 2017-01-05 | 145    |
| 6   | 2017-01-06 | 1455   |
| 7   | 2017-01-07 | 199    |
| 8   | 2017-01-08 | 188    |

### 6.2. Explanation
*   The days with `id` 2 and 3 had over 100 visitors and were consecutive. However, this sequence was only 2 days long, so it was excluded by the `HAVING COUNT(*) >= 3` clause.
*   The days with `id` 5, 6, 7, and 8 all had over 100 visitors and were consecutive. This sequence was 4 days long, meeting the criteria of "3 or more". Therefore, all four of these records are included in the final output.




