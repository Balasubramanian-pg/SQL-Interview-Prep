# User Activation Rate

## 1. Problem Statement

### 1.1. Objective
>[!NOTE]
> New TikTok users sign up with their emails. They confirm their signup by replying to a text confirmation to activate their accounts. Users may receive multiple text messages for account confirmation until they have confirmed their new account.

A senior analyst is interested to know the activation rate of specified users in the `emails` table. Write a query to find the activation rate. Round the result to 2 decimal places.

### 1.2. Definitions
-   **`emails` table**: Contains the information of user signup details. This table represents the total population of users for this analysis.
-   **`texts` table**: Contains the users' activation information. A user is considered "activated" if they have at least one record with a `signup_action` of 'Confirmed'.

### 1.3. Assumptions
-   The analysis is interested in the activation rate **only for the users present in the `emails` table**.
-   A user in the `emails` table may not have any corresponding records in the `texts` table, and vice-versa.

> [!IMPORTANT]
> The first assumption is critical. The `emails` table defines our denominator (the total number of users we are measuring). We are not analyzing users who may exist in `texts` but not in `emails`.

## 2. Input Schemas

### 2.1. `emails` Table:

|**Column Name**|**Type**|
|---|---|
|email_id|integer|
|user_id|integer|
|signup_date|datetime|

#### 2.1.1. `emails` Example Input:

|**email_id**|**user_id**|**signup_date**|
|---|---|---|
|125|7771|06/14/2022 00:00:00|
|236|6950|07/01/2022 00:00:00|
|433|1052|07/09/2022 00:00:00|

### 2.2. `texts` Table:

|**Column Name**|**Type**|
|---|---|
|text_id|integer|
|email_id|integer|
|signup_action|varchar|

#### 2.2.1. `texts` Example Input:

|**text_id**|**email_id**|**signup_action**|
|---|---|---|
|6878|125|Confirmed|
|6920|236|Not Confirmed|
|6994|236|Confirmed|

## 3. Example Output & Explanation

### 3.1. Example Output:

|confirm_rate|
|---|
|0.67|

### 3.2. Explanation
From the example data, there are 3 unique users in the `emails` table. We need to check their activation status:
-   **User with `email_id` 125**: Has a 'Confirmed' record in `texts`. **Activated**.
-   **User with `email_id` 236**: Has both 'Not Confirmed' and 'Confirmed' records. Since they have at least one 'Confirmed' record, they are **Activated**.
-   **User with `email_id` 433**: Has no corresponding records in the `texts` table. **Not Activated**.

Out of 3 total users, 2 are activated. The activation rate is `2 / 3 = 0.666...`, which rounds to `0.67`.

> [!NOTE]
> A user only needs to confirm once to be considered activated. Multiple confirmations for the same user do not change their activated status.

## 4. Conceptual Approach
To calculate the activation rate, we need to find the ratio of activated users to the total number of users.

1.  **Start with the User Population**: The `emails` table is our source of truth for the total number of users to be analyzed.
2.  **Link Activation Data**: Use a `LEFT JOIN` from the `emails` table to the `texts` table. This is crucial because it ensures all users from `emails` are included, even if they have no activation attempts in `texts`.
3.  **Count Activated Users (Numerator)**: Use a conditional `COUNT` to count the number of unique users who have at least one record with `signup_action = 'Confirmed'`.
4.  **Count Total Users (Denominator)**: Count the total number of unique users from the `emails` table.
5.  **Calculate the Rate**: Divide the numerator by the denominator and round the result.

> [!TIP]
> This "rate calculation" pattern is very common. The key is almost always to use a `LEFT JOIN` from your primary population table (the source of your denominator) to the event table (the source of your numerator).

## 5. SQL Solution

```sql
SELECT
  ROUND(
    COUNT(DISTINCT CASE WHEN t.signup_action = 'Confirmed' THEN e.email_id END) * 1.0
    / COUNT(DISTINCT e.email_id),
    2
  ) AS confirm_rate
FROM emails AS e
LEFT JOIN texts AS t
  ON e.email_id = t.email_id;
```

## 6. Code Breakdown

### 6.1. The `LEFT JOIN`
-   `FROM emails AS e LEFT JOIN texts AS t ON e.email_id = t.email_id`: This is the most critical part of the query.
-   An `INNER JOIN` would be incorrect, as it would drop any users from the `emails` table who never had a corresponding text message, thus incorrectly reducing our denominator and skewing the activation rate upwards.

> [!IMPORTANT]
> The `LEFT JOIN` ensures that our denominator, the total count of users, accurately reflects every user who signed up, which is the correct definition of the user pool for this analysis.

### 6.2. The Numerator: `COUNT(DISTINCT CASE WHEN ...)`
-   `COUNT(DISTINCT CASE WHEN t.signup_action = 'Confirmed' THEN e.email_id END)`: This is a conditional count that serves as our numerator.
-   `CASE WHEN t.signup_action = 'Confirmed' THEN e.email_id END`: This expression returns the `email_id` if the user confirmed, and `NULL` otherwise.
-   The `COUNT(DISTINCT ...)` function then counts the number of non-`NULL` `email_id`s. `DISTINCT` is important because a user might have multiple 'Confirmed' texts, but we only want to count them once as an activated user.

> [!NOTE]
> This is a very efficient and standard SQL pattern for counting a subset of a population based on a condition.

### 6.3. The Denominator: `COUNT(DISTINCT e.email_id)`
-   This expression serves as our denominator. It counts all unique `email_id`s from the `emails` table (`e`).
-   Because of the `LEFT JOIN`, this correctly represents the total number of users we started with, regardless of their confirmation status.

> [!TIP]
> When using a `LEFT JOIN`, it's a good practice to explicitly count the primary key or a unique identifier from the *left* table (in this case `e.email_id`) for your denominator to avoid any ambiguity.

### 6.4. The Calculation and Formatting
-   `* 1.0`: This is a crucial step to ensure **floating-point division**. In many SQL dialects, dividing an integer by an integer results in a truncated integer (e.g., `2 / 3 = 0`). Multiplying by a float (`1.0`) promotes the numerator to a float, ensuring the division yields a decimal result.
-   `ROUND(..., 2)`: This function takes the final decimal ratio and rounds it to two decimal places, as required by the problem statement.

> [!CAUTION]
> Forgetting to handle integer division is one of the most common errors in SQL rate calculations. Always ensure one of your operands is a float or decimal type before dividing.

