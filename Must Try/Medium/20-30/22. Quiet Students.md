# Identifying "Quiet" Students

## 1. Objective
> [!NOTE]
> Write a SQL query to identify "quiet" students. A "quiet" student is defined as someone who has participated in at least one exam but has **never** scored either the highest or the lowest score in **any** of the exams they took.

## 2. Data Model

### 2.1. `Student` Table
Contains the list of all students.
| student_id | student_name |
|:-----------|:-------------|
| 1          | Daniel       |
| 2          | Jade         |
...and so on.

### 2.2. `Exam` Table
Contains exam results for students.
| exam_id | student_id | score |
|:--------|:-----------|:------|
| 10      | 1          | 70    |
| 10      | 2          | 80    |
...and so on.

## 3. Core Logic: The "Anti-Join" Approach
The most effective way to solve this is to first identify the opposite of what we want: the students who were **not** quiet. We can call these "extreme scorers." An extreme scorer is any student who scored the highest or lowest in at least one exam.

Once we have a definitive list of all extreme scorers, we can simply find the students who are not on that list.

> [!IMPORTANT]
> The logical flow is:
> 1.  Find the highest and lowest score for *each exam*.
> 2.  Create a "blacklist" of all students whose score matched one of those extremes.
> 3.  Select all students who took at least one exam but do not appear on the blacklist.

## 4. Incremental Query Construction
We will use a Common Table Expression (CTE) to build this logic step-by-step.

### 4.1. Step 1: Find the Highest and Lowest Score for Each Exam
We can use window functions to attach the min and max score for an exam to every student's record for that same exam.
```sql
SELECT
    exam_id,
    student_id,
    score,
    -- Find the minimum score within this exam's partition
    MIN(score) OVER(PARTITION BY exam_id) AS min_score,
    -- Find the maximum score within this exam's partition
    MAX(score) OVER(PARTITION BY exam_id) AS max_score
FROM
    exam;
```
**Intermediate Result:**
| exam_id | student_id | score | min_score | max_score |
|:--------|:-----------|:------|:----------|:----------|
| 10      | 1          | 70    | 70        | 90        |
| 10      | 2          | 80    | 70        | 90        |
| 10      | 3          | 90    | 70        | 90        |
| 20      | 1          | 80    | 80        | 80        |
...and so on.

### 4.2. Step 2: Create a List of "Extreme Scorer" IDs
Now, we can filter the above result to create our blacklist: a list of `student_id`s for anyone whose `score` was equal to the `min_score` or `max_score` for that exam.
```sql
-- This query will become our CTE
SELECT
    student_id
FROM (
    SELECT
        student_id,
        score,
        MIN(score) OVER(PARTITION BY exam_id) AS min_score,
        MAX(score) OVER(PARTITION BY exam_id) AS max_score
    FROM exam
) AS exam_with_extremes
WHERE
    score = min_score OR score = max_score;
```
**Intermediate Result (`t1` in the final query):** A list of student IDs who are NOT quiet. This list will contain duplicates, which is fine.
| student_id |
|:-----------|
| 1          |
| 3          |
| 1          |
| 1          |
| 3          |
| 4          |
...and so on.

### 4.3. Step 3: Find Students Not on the Blacklist
The final step is to select students who took an exam but whose ID is not in our blacklist from Step 2.
> [!TIP]
> The condition `student_id != ALL(subquery)` is a powerful way to say "find students whose ID is not equal to any of the values returned by the subquery." It is functionally similar to `student_id NOT IN (subquery)`.

```sql
SELECT DISTINCT
    s.student_id,
    s.student_name
FROM
    exam e
JOIN
    student s ON e.student_id = s.student_id
WHERE
    e.student_id != ALL (SELECT student_id FROM ExtremeScorers); -- Assumes CTE is named ExtremeScorers
```
> [!CAUTION]
> Joining `exam` with `student` is crucial. It accomplishes two things: it retrieves the `student_name` and, more importantly, it implicitly filters out students who never took an exam (like Student 5, 'Will'), as they will have no matching record in the `exam` table.

## 5. Final Solution
The complete query combines these steps into a clean, readable structure.
```sql
-- CTE to create a "blacklist" of all students who have ever scored a min or max.
WITH ExtremeScorers AS (
    SELECT student_id
    FROM (
        SELECT
            student_id,
            score,
            MIN(score) OVER(PARTITION BY exam_id) AS min_score,
            MAX(score) OVER(PARTITION BY exam_id) AS max_score
        FROM exam
    ) a
    WHERE score = min_score OR score = max_score
)
-- Main query to find students not on the blacklist.
SELECT DISTINCT
    s.student_id,
    s.student_name
FROM
    exam e
JOIN
    student s USING (student_id)
WHERE
    e.student_id != ALL (SELECT student_id FROM ExtremeScorers)
ORDER BY
    s.student_id;
```

## 6. Result Analysis

### 6.1. Final Output
| student_id | student_name |
|:-----------|:-------------|
| 2          | Jade         |

### 6.2. Explanation
*   **Student 1 (Daniel)**: Is an extreme scorer. Scored lowest (`70`) in Exam 10 and lowest (`60`) in Exam 40. **Excluded.**
*   **Student 2 (Jade)**: Is a quiet student. Scored `80` in Exam 10 (min was 70, max was 90) and `70` in Exam 40 (min was 60, max was 80). Never scored an extreme. **Included.**
*   **Student 3 (Stella)**: Is an extreme scorer. Scored highest (`90`) in Exam 10. **Excluded.**
*   **Student 4 (Jonathan)**: Is an extreme scorer. Scored highest (`90`) in Exam 30. **Excluded.**
*   **Student 5 (Will)**: Never took an exam, so is filtered out by the `JOIN` between the `exam` and `student` tables. **Excluded.**
