# Identifying Shopping Sprees

## 1. Problem Statement

### 1.1. Objective
In an effort to identify high-value customers, Amazon has asked for your help to obtain data about users who go on shopping sprees.

List the user IDs of users who have gone on at least one shopping spree, sorted in ascending order.

### 1.2. Definition
-   A **shopping spree** occurs when a user makes purchases on **3 or more consecutive days**.

> [!IMPORTANT]
> The core of this problem is to identify sequences of consecutive dates for each user. This is a classic "Gaps and Islands" problem in SQL, where we need to group continuous blocks of data (islands) that are separated by breaks (gaps).

### 1.3. Input Table: `transactions`

|**Column Name**|**Type**|
|---|---|
|user_id|integer|
|amount|float|
|transaction_date|timestamp|

### 1.4. Example

#### 1.4.1. `transactions` Example Input:

|user_id|amount|transaction_date|
|---|---|---|
|1|9.99|08/01/2022 10:00:00|
|1|55|08/17/2022 10:00:00|
|2|149.5|08/05/2022 10:00:00|
|2|4.89|08/06/2022 10:00:00|
|2|34|08/07/2022 10:00:00|

#### 1.4.2. Example Output:

|user_id|
|---|
|2|

#### 1.4.3. Explanation
In this example, `user_id` 2 is the only one who has gone on a shopping spree because they made purchases on three consecutive days: Aug 5th, 6th, and 7th.

## 2. Conceptual Approach
This problem requires a multi-step approach to first clean the data, then identify consecutive date sequences, and finally filter for users who meet the shopping spree criteria.

1.  **De-duplicate Daily Transactions**: A user might make multiple purchases on the same day. For this problem, we only care that *a* purchase was made on a given day. So, the first step is to get a distinct list of `(user_id, transaction_date)` pairs.
2.  **Identify Consecutive Groups**: This is the trickiest part. We need a way to group dates that are consecutive. A common and powerful technique is to subtract a sequence number from each date. If the dates are consecutive, this subtraction will result in the same "grouping date" for all of them.
3.  **Count Days in Each Group**: Once the consecutive dates are grouped, we can count the number of days in each group.
4.  **Filter for Shopping Sprees**: Finally, we filter these groups to keep only those with a count of 3 or more days and return the unique `user_id`s from this final set.

> [!TIP]
> The "date minus row number" technique is a standard pattern for solving Gaps and Islands problems involving dates. It works because as the date increments by one day, the row number also increments by one, keeping the difference between them constant for a consecutive sequence.

## 3. SQL Solution (Multi-CTE Approach)

```sql
WITH daily_transactions AS (
  -- Step 1: Get distinct transaction dates for each user.
  SELECT DISTINCT
    user_id,
    DATE(transaction_date) AS transaction_date
  FROM transactions
),
consecutive_groups AS (
  -- Step 2: Identify consecutive date groups.
  SELECT
    user_id,
    transaction_date,
    DATE_SUB(transaction_date, INTERVAL ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY transaction_date) DAY) AS group_date
  FROM daily_transactions
),
consecutive_counts AS (
  -- Step 3: Count the number of days in each consecutive group.
  SELECT
    user_id,
    group_date,
    COUNT(*) AS consecutive_days
  FROM consecutive_groups
  GROUP BY user_id, group_date
)
-- Step 4: Filter for users who have at least one shopping spree.
SELECT DISTINCT
  user_id
FROM consecutive_counts
WHERE consecutive_days >= 3
ORDER BY user_id;
```

## 4. Code Breakdown

### 4.1. CTE 1: `daily_transactions`
-   This CTE cleans the data. `SELECT DISTINCT user_id, DATE(transaction_date)` ensures that we only consider one transaction per user per day, which is the correct basis for our "consecutive days" logic.

> [!NOTE]
> The `DATE()` function (or `CAST(... AS DATE)` in other SQL dialects) is used to truncate the timestamp to just the date part, so all transactions on the same day are treated as one.

### 4.2. CTE 2: `consecutive_groups`
-   This is the core of the Gaps and Islands solution.
-   `ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY transaction_date)`: This window function assigns a sequential number (1, 2, 3...) to each transaction day for a given user.
-   `DATE_SUB(transaction_date, INTERVAL ... DAY)`: This subtracts the row number (as days) from the transaction date.

> [!WARNING]
> The date subtraction syntax (`DATE_SUB` or `date - INTERVAL '...'`) varies between SQL dialects. The logic, however, remains the same.

**How it works (example for user 2):**
-   Aug 5th, row_number=1 -> `group_date` = Aug 5 - 1 day = **Aug 4**
-   Aug 6th, row_number=2 -> `group_date` = Aug 6 - 2 days = **Aug 4**
-   Aug 7th, row_number=3 -> `group_date` = Aug 7 - 3 days = **Aug 4**
As you can see, all three consecutive dates are now tagged with the same `group_date`, effectively putting them in the same group.

### 4.3. CTE 3: `consecutive_counts`
-   This CTE is a straightforward aggregation.
-   `GROUP BY user_id, group_date`: It groups the rows by the `group_date` we just created.
-   `COUNT(*) AS consecutive_days`: It counts the number of rows (i.e., days) in each consecutive sequence. For user 2, this count will be `3`.

### 4.4. Final `SELECT` Statement
-   This query operates on the final summary CTE.
-   `WHERE consecutive_days >= 3`: This is the final filter that identifies the shopping sprees.
-   `SELECT DISTINCT user_id`: We use `DISTINCT` because a user might have multiple separate shopping sprees, but the question only asks for the list of users who have had *at least one*.
-   `ORDER BY user_id`: Sorts the final list of user IDs.

> [!IMPORTANT]
> A single query can be written to combine the last two steps, but using separate CTEs makes the logic much clearer and easier to debug, which is often preferred in complex analytical queries.
