# Identifying Supercloud Customers

## 1. Objective
> [!NOTE]
> Write a SQL query to identify "Supercloud" customers. A Supercloud customer is defined as a customer who has purchased at least one product from **every single product category** available.

## 2. Data Model

### 2.1. `customer_contracts` Table
Contains transaction data for customers.
| customer_id | product_id | amount |
|:------------|:-----------|:-------|
| 1           | 1          | 1000   |
| 1           | 3          | 2000   |
| 1           | 5          | 1500   |

### 2.2. `products` Table
Contains details about each product, including its category.
| product_id | product_category | product_name         |
|:-----------|:-----------------|:---------------------|
| 1          | Analytics        | Azure Databricks     |
| 2          | Analytics        | Azure Stream Analytics |
| 4          | Containers       | Azure Kubernetes Service |

## 3. Core Logic: The "Universal Quantification" Problem
This is a classic "for all" or "universal quantification" type of SQL problem. We need to find customers for whom it is true that "for all product categories, there exists a purchase."

A standard and robust way to solve this is to:
1.  Determine the **total number of distinct product categories** that exist. Let's call this `TotalCategories`.
2.  For each customer, determine the **number of distinct product categories they have purchased from**. Let's call this `CustomerCategories`.
3.  A customer is a Supercloud customer if and only if `CustomerCategories = TotalCategories`.

## 4. Incremental Query Construction
We will use Common Table Expressions (CTEs) to build this logic step-by-step.

### 4.1. Step 1: Count the Total Number of Product Categories
First, we need a single, authoritative number representing the total count of distinct categories in the `products` table.
```sql
-- This will be our first CTE
SELECT COUNT(DISTINCT product_category) AS total_categories
FROM products;
```
For the example data, this query would return `3` (Analytics, Containers, Compute).

### 4.2. Step 2: Count the Distinct Categories for Each Customer
Next, we need to find out how many distinct categories each customer has engaged with. This requires joining `customer_contracts` and `products`, then grouping by `customer_id`.
```sql
-- This will be our second CTE
SELECT
    c.customer_id,
    COUNT(DISTINCT p.product_category) AS categories_purchased
FROM
    customer_contracts c
JOIN
    products p ON c.product_id = p.product_id
GROUP BY
    c.customer_id;
```
**Intermediate Result (`customer_categories`):**
| customer_id | categories_purchased |
|:------------|:---------------------|
| 1           | 3                    |
| 2           | 2                    |
> [!TIP]
> Using `COUNT(DISTINCT p.product_category)` is crucial. If a customer buys multiple products from the same category (e.g., two different "Analytics" products), we must only count that category once towards their total.

### 4.3. Step 3: Compare Each Customer's Count to the Total
Finally, we compare the results from the two previous steps. We need to find the `customer_id`s where `categories_purchased` is equal to `total_categories`.

## 5. Final Solution
The complete query combines these steps using CTEs for clarity.

```sql
-- CTE 1: Calculate the total number of distinct product categories available.
WITH total_categories AS (
  SELECT COUNT(DISTINCT product_category) AS total_count
  FROM products
),
-- CTE 2: For each customer, count the number of distinct product categories they've purchased from.
customer_categories AS (
  SELECT
    cc.customer_id,
    COUNT(DISTINCT p.product_category) AS categories_purchased
  FROM customer_contracts cc
  INNER JOIN products p ON cc.product_id = p.product_id
  GROUP BY cc.customer_id
)
-- Final Step: Select customers whose purchased category count matches the total available count.
SELECT
  cc.customer_id
FROM customer_categories cc
-- The HAVING clause is a concise way to perform the comparison without a JOIN or CROSS JOIN.
HAVING
  cc.categories_purchased = (SELECT total_count FROM total_categories);
```
> [!NOTE]
> The original solution used a `CROSS JOIN` to make the total count available to every row before filtering. Using `HAVING` with a scalar subquery is a more direct and often more readable way to achieve the same result. Both approaches are valid.

## 6. Result Analysis

### 6.1. Final Output
| customer_id |
|:------------|
| 1           |

### 6.2. Explanation
*   The `total_categories` CTE calculates that there are **3** distinct product categories in total.
*   The `customer_categories` CTE calculates:
    *   Customer `1` purchased from 3 distinct categories.
    *   Customer `2` purchased from 2 distinct categories.
*   The final `SELECT` statement compares each customer's count to the total of 3.
    *   For Customer `1`: `3 = 3` is true, so they are included.
    *   For Customer `2`: `2 = 3` is false, so they are excluded.
*   The query correctly identifies Customer `1` as the only Supercloud customer.

