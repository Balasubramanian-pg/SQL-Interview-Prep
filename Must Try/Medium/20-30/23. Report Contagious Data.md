# Continuous State Periods

## 1. Objective
> [!NOTE]
> Write a SQL query to identify and report on continuous periods of "success" and "failure" for a series of tasks. The report will only consider dates within the year 2019 and will show the start and end date for each continuous block.

## 2. Data Model

### 2.1. `Failed` Table
Contains a list of dates on which a task failed.
| fail_date  |
|:-----------|
| 2018-12-28 |
| 2018-12-29 |
| 2019-01-04 |
| 2019-01-05 |

### 2.2. `Succeeded` Table
Contains a list of dates on which a task succeeded.
| success_date |
|:-------------|
| 2018-12-30   |
| 2018-12-31   |
| 2019-01-01   |
| 2019-01-02   |
| 2019-01-03   |
| 2019-01-06   |

## 3. Core Concept: The "Gaps and Islands" Problem
This query solves a classic "gaps and islands" problem, where we need to find continuous sequences (islands) of data separated by breaks (gaps). A powerful technique to solve this is to create a grouping key that remains constant for all dates within a consecutive sequence.

> [!IMPORTANT]
> **The Date Grouping Trick: `date - ROW_NUMBER()`**
> We can create this grouping key by subtracting a sequential number from each date. For a series of consecutive dates, both the date and its row number increase by one each day. Therefore, their difference remains constant, forming a unique identifier for that specific sequence.
>
> **Example:**
> | Date         | `ROW_NUMBER()` | Calculation (`date` - `row_number` days) | `date_group` |
> |:-------------|:---------------|:-----------------------------------------|:-------------|
> | `2019-01-01` | 1              | `2019-01-01` - 1 day                     | `2018-12-31` |
> | `2019-01-02` | 2              | `2019-01-02` - 2 days                    | `2018-12-31` |
> | `2019-01-03` | 3              | `2019-01-03` - 3 days                    | `2018-12-31` |
>
> A gap in the dates (e.g., jumping to `2019-01-06`) will cause the `date_group` to change, starting a new group.

## 4. Incremental Query Construction
We will process the `Succeeded` and `Failed` tables independently and then combine the results.

### 4.1. Step 1: Identify Continuous Periods for `Succeeded` Dates
#### 4.1.1. Create the Grouping Key
First, we filter the `Succeeded` table for dates in 2019 and apply the date grouping trick.
```sql
SELECT
    success_date,
    DATE_SUB(success_date, INTERVAL ROW_NUMBER() OVER(ORDER BY success_date) DAY) AS date_group
FROM Succeeded
WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31';
```
**Intermediate Result (`grouped_success`):**
| success_date | date_group |
|:-------------|:-----------|
| 2019-01-01   | 2018-12-31 |
| 2019-01-02   | 2018-12-31 |
| 2019-01-03   | 2018-12-31 |
| 2019-01-06   | 2019-01-02 |

#### 4.1.2. Aggregate by the Grouping Key
Now, we can group by `date_group` and use `MIN()` and `MAX()` to find the start and end of each continuous period.
```sql
SELECT
    MIN(success_date) AS start_date,
    MAX(success_date) AS end_date
FROM (
    -- Previous query goes here as a subquery
) AS grouped_success
GROUP BY date_group;
```
**Intermediate Result (`succeeded_periods`):**
| start_date | end_date   |
|:-----------|:-----------|
| 2019-01-01 | 2019-01-03 |
| 2019-01-06 | 2019-01-06 |

### 4.2. Step 2: Identify Continuous Periods for `Failed` Dates
We apply the exact same logic to the `Failed` table.

### 4.3. Step 3: Combine and Order the Results
Finally, we use `UNION ALL` to combine the results from the succeeded and failed periods into a single report and order it chronologically.

## 5. Final Solution
The complete query uses CTEs to cleanly separate the logic for succeeded and failed periods before combining them.
```sql
-- CTE 1: Identify continuous periods of success within 2019.
WITH succeeded_periods AS (
    SELECT
        MIN(success_date) AS start_date,
        MAX(success_date) AS end_date,
        'succeeded' AS period_state
    FROM (
        -- Subquery to create a grouping key for consecutive dates.
        SELECT
            success_date,
            DATE_SUB(success_date, INTERVAL ROW_NUMBER() OVER(ORDER BY success_date) DAY) AS date_group
        FROM Succeeded
        WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31'
    ) AS grouped_success
    GROUP BY date_group
),
-- CTE 2: Identify continuous periods of failure within 2019.
failed_periods AS (
    SELECT
        MIN(fail_date) AS start_date,
        MAX(fail_date) AS end_date,
        'failed' AS period_state
    FROM (
        -- Subquery to create a grouping key for consecutive dates.
        SELECT
            fail_date,
            DATE_SUB(fail_date, INTERVAL ROW_NUMBER() OVER(ORDER BY fail_date) DAY) AS date_group
        FROM Failed
        WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'
    ) AS grouped_fail
    GROUP BY date_group
)
-- Final Query: Combine both sets of results and order chronologically.
SELECT
    period_state,
    start_date,
    end_date
FROM (
    SELECT * FROM succeeded_periods
    UNION ALL
    SELECT * FROM failed_periods
) AS combined_results
ORDER BY start_date;
```

## 6. Result Analysis

### 6.1. Final Output
| period_state | start_date | end_date   |
|:-------------|:-----------|:-----------|
| succeeded    | 2019-01-01 | 2019-01-03 |
| failed       | 2019-01-04 | 2019-01-05 |
| succeeded    | 2019-01-06 | 2019-01-06 |

### 6.2. Explanation
*   The first row shows a continuous `succeeded` period from Jan 1st to Jan 3rd.
*   The second row shows a continuous `failed` period from Jan 4th to Jan 5th.
*   The third row shows a single-day `succeeded` period on Jan 6th. The gap on Jan 5th broke the sequence, correctly starting a new period.

