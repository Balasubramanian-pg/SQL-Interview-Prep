# Finding the Third Transaction

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find the third transaction for every user. The output should include the user's ID, the spend amount, and the date of that specific transaction.

## 2. Data Model

### 2.1. `transactions` Table
Contains a log of all transactions made by users.
| Column Name      | Type      |
|:-----------------|:----------|
| user_id          | integer   |
| spend            | decimal   |
| transaction_date | timestamp |

## 3. Core Logic: Identifying the Nth Record in a Group
This is a classic "Top-N-per-group" problem, where N is 3. To solve this, we need to:
1.  Group all transactions by `user_id`.
2.  Within each group, establish a clear order for the transactions.
3.  Assign a rank or row number to each transaction based on this order.
4.  Filter for the transaction with a rank of 3.

> [!IMPORTANT]
> The most critical step is defining the order. The problem statement does not explicitly state how to order the transactions. A natural assumption would be to order them chronologically by `transaction_date`. We will proceed with this standard and logical assumption.

## 4. Incremental Query Construction
We will use a Common Table Expression (CTE) and a window function to solve this elegantly.

### 4.1. Step 1: Rank Transactions for Each User
We use the `ROW_NUMBER()` window function to assign a sequential number to each transaction for every user, ordered by date.
*   `PARTITION BY user_id`: This tells the function to restart the numbering for each new user.
*   `ORDER BY transaction_date`: This sorts the transactions chronologically before assigning numbers. The earliest transaction gets rank 1, the next gets rank 2, and so on.

```sql
-- This query will become our CTE
SELECT
    user_id,
    spend,
    transaction_date,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY transaction_date) AS transaction_rank
FROM
    transactions;
```
**Intermediate Result (`ranked_transactions`):**
| user_id | spend  | transaction_date      | transaction_rank |
|:--------|:-------|:----------------------|:-----------------|
| 111     | 100.50 | 01/08/2022 12:00:00   | 1                |
| 111     | 55.00  | 01/10/2022 12:00:00   | 2                |
| 111     | 89.60  | 02/05/2022 12:00:00   | 3                |
| 121     | 36.00  | 01/18/2022 12:00:00   | 1                |
| 145     | 24.99  | 01/26/2022 12:00:00   | 1                |

### 4.2. Step 2: Filter for the Third Transaction
With the ranks assigned, the final step is simple: we select only the rows where `transaction_rank` is exactly `3`.

```sql
SELECT
    user_id,
    spend,
    transaction_date
FROM
    ranked_transactions -- Assumes the previous query is in this CTE
WHERE
    transaction_rank = 3;
```

## 5. Final Solution
The complete query combines these steps into a clean and efficient structure.

```sql
-- CTE to rank each user's transactions chronologically.
WITH ranked_transactions AS (
    SELECT
        user_id,
        spend,
        transaction_date,
        ROW_NUMBER() OVER (
            PARTITION BY user_id
            ORDER BY transaction_date
        ) AS transaction_rank
    FROM
        transactions
)
-- Select only the rows where the rank is 3.
SELECT
    user_id,
    spend,
    transaction_date
FROM
    ranked_transactions
WHERE
    transaction_rank = 3;
```

## 6. Analysis and Discrepancy Note
### 6.1. Final Output (Based on Standard Interpretation)
| user_id | spend | transaction_date    |
|:--------|:------|:--------------------|
| 111     | 89.60 | 02/05/2022 12:00:00 |

### 6.2. Explanation
*   The CTE first groups all transactions by `user_id`.
*   For `user_id = 111`, it orders the three transactions by date and assigns ranks 1, 2, and 3.
*   For other users like `121` and `145`, they have fewer than three transactions, so they never receive a `transaction_rank` of 3.
*   The final `SELECT` statement filters for `transaction_rank = 3`, correctly identifying the single record for user `111`.

> [!WARNING]
> There might be ambiguity in some problem descriptions. While the provided example output might differ, ordering by `transaction_date` is the most logical and standard interpretation for sequencing transactions. If a different ordering (e.g., by spend amount) were required, it would typically be specified explicitly in the problem statement. This solution follows the standard best practice.
