# Cumulative Purchase Quantity

## 1. Overview
> [!NOTE]
> This document analyzes two SQL methods for answering the business question: **"For each product type, what is the cumulative (running total) quantity purchased over time? Show a list of every transaction, and for each one, display the total quantity purchased for that product's type up to and including that order's date."**

## 2. Table Schema
The query references a single table, `total_trans`, which likely acts as a daily summary or a raw transaction log. A plausible schema would be:

```sql
-- Table: total_trans
-- Stores a record of product transactions, possibly aggregated daily.
CREATE TABLE total_trans (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    order_date     DATE NOT NULL,             -- The date of the transaction
    product_type   VARCHAR(100) NOT NULL,     -- The category or type of product
    quantity       INT NOT NULL               -- The number of units sold
);
```
> [!TIP]
> Adding a composite index on the columns used for partitioning and ordering can significantly improve the performance of these queries.
> ```sql
> CREATE INDEX idx_product_date ON total_trans (product_type, order_date);
> ```

## 3. Method 1: Correlated Subquery
This is a traditional method that works but is generally inefficient on large datasets.

### 3.1. SQL Query
```sql
SELECT
    t1.order_date,
    t1.product_type,
    (
        SELECT
            SUM(quantity)
        FROM
            total_trans AS t2
        WHERE
            t2.order_date <= t1.order_date
            AND t2.product_type = t1.product_type
    ) AS cum_purchased
FROM
    total_trans AS t1
ORDER BY
    t1.product_type, t1.order_date;
```

### 3.2. Explanation
This query calculates a running total using a **correlated subquery**. This means the inner query is executed once for *every single row* processed by the outer query.
*   **Outer Query (`FROM total_trans AS t1`)**: This query iterates through each row of the `total_trans` table, aliased as `t1`.
*   **The Subquery**: For each row from `t1`, the inner query `(SELECT SUM(quantity) ...)` is executed.
    *   `WHERE t2.product_type = t1.product_type`: This is the **correlation**. It ensures the subquery only sums quantities for the same product type as the current row in the outer query (`t1`).
    *   `AND t2.order_date <= t1.order_date`: This is the **cumulative** logic. It restricts the sum to include only rows with a date on or before the outer query's current row's date.

> [!WARNING]
> This method is very inefficient. If the `total_trans` table has 10,000 rows, the inner subquery will be executed 10,000 times. This "row-by-row" processing scales poorly and should be avoided on large tables.

## 4. Method 2: Window Function (Modern Approach)
The modern, standard, and far more efficient way to calculate running totals is with **window functions**.

### 4.1. SQL Query
```sql
SELECT
    order_date,
    product_type,
    SUM(quantity) OVER (
        PARTITION BY product_type
        ORDER BY order_date
    ) AS cum_purchased
FROM
    total_trans
ORDER BY
    product_type, order_date;
```

### 4.2. Explanation
This query produces the exact same result but in a much more efficient way by performing a single scan over the data.
*   **`SUM(quantity) OVER (...)`**: This is the window function. It calculates a `SUM` over a specific "window" of rows related to the current row.
*   **`PARTITION BY product_type`**: This clause divides the data into partitions, or groups (e.g., one for 'Electronics', one for 'Apparel'). The `SUM` calculation is contained within these partitions and resets for each new `product_type`.
*   **`ORDER BY order_date`**: This clause sorts the rows **within each partition** by date. This ordering is crucial, as it tells the `SUM` function how to accumulate the total. The function sums the `quantity` from the first row of the partition up to and including the **current row**.

## 5. Method Comparison
> [!IMPORTANT]
> For calculating running totals, **the window function method is vastly superior** to the correlated subquery method in both performance and readability.
>
> - **Performance**: Window functions perform a single pass over the dataset. Correlated subqueries perform a new scan for each row, leading to exponential increases in execution time as the table grows.
> - **Readability**: The window function syntax `SUM(...) OVER (PARTITION BY ... ORDER BY ...)` clearly and explicitly states the intent to calculate a running total within ordered groups.
