# Non-Profitable Drugs

## 1. Problem Statement

### 1.1. Objective
CVS Health is analyzing its pharmacy sales data to identify areas of financial loss. Each drug is exclusively manufactured by a single manufacturer.

Write a query to identify the manufacturers associated with the drugs that resulted in losses for CVS Health and calculate the total amount of losses incurred for each.

Output the manufacturer's name, the number of drugs associated with losses, and the total losses in absolute value. Display the results sorted in descending order with the highest losses displayed at the top.

### 1.2. Definition
-   `cogs` stands for Cost of Goods Sold.
-   A loss occurs when the cost to produce a drug is greater than the revenue it generates.

> [!IMPORTANT]
> The formula for profit is `Total Profit = Total Sales - COGS`. Therefore, a drug is sold at a loss if `total_sales < cogs`.

## 2. Input Table: `pharmacy_sales`

### 2.1. Schema
|**Column Name**|**Type**|
|---|---|
|product_id|integer|
|units_sold|integer|
|total_sales|decimal|
|cogs|decimal|
|manufacturer|varchar|
|drug|varchar|

> [!NOTE]
> The `cogs` (Cost of Goods Sold) column represents the direct cost to the company for the drug, while `total_sales` represents the revenue generated.

### 2.2. Example Input
|**product_id**|**total_sales**|**cogs**|**manufacturer**|**drug**|
|---|---|---|---|---|
|156|3130097.00|3427421.73|Biogen|Acyclovir|
|25|2753546.00|2974975.36|AbbVie|Lamivudine and Zidovudine|
|50|2521023.73|2742445.90|Eli Lilly|Dermasorb TA Complete Kit|
|98|813188.82|140422.87|Biogen|Medi-Chord|

## 3. Example Output & Explanation

### 3.1. Example Output
|**manufacturer**|**drug_count**|**total_loss**|
|---|---|---|
|Biogen|1|297324.73|
|AbbVie|1|221429.36|
|Eli Lilly|1|221422.17|

### 3.2. Explanation
The query identifies drugs where `cogs` is greater than `total_sales`.
-   For **Biogen**, the drug 'Acyclovir' resulted in a loss of `3,427,421.73 - 3,130,097.00 = 297,324.73`.
-   For **AbbVie**, the drug 'Lamivudine and Zidovudine' resulted in a loss of `2,974,975.36 - 2,753,546.00 = 221,429.36`.
-   For **Eli Lilly**, the drug 'Dermasorb TA Complete Kit' resulted in a loss of `2,742,445.90 - 2,521,023.73 = 221,422.17`.

> [!TIP]
> The drug 'Medi-Chord' from Biogen is excluded from the calculation because it was profitable (`total_sales > cogs`), which is why Biogen's `drug_count` is 1, not 2.

## 4. Conceptual Approach
To solve this, we need to first filter for only the loss-making drugs and then aggregate the results by manufacturer.

1.  **Filter for Loss-Making Drugs**: The first and most important step is to select only the rows from the `pharmacy_sales` table where a loss occurred (`total_sales < cogs`).
2.  **Group by Manufacturer**: With the filtered list of unprofitable drugs, we then group these rows by `manufacturer`.
3.  **Aggregate the Results**: For each manufacturer group, we perform two calculations:
    -   Count the number of drugs to get `drug_count`.
    -   Sum up the individual losses to get `total_loss`.
4.  **Sort the Output**: Finally, we order the results by the `total_loss` in descending order.

> [!NOTE]
> The key is to filter for only the loss-making drugs first using the `WHERE` clause. The aggregation with `GROUP BY` is then performed only on this smaller, relevant subset of data, which is highly efficient.

## 5. SQL Solution

```sql
SELECT
  manufacturer,
  COUNT(drug) AS drug_count,
  SUM(cogs - total_sales) AS total_loss
FROM pharmacy_sales
WHERE
  total_sales < cogs
GROUP BY
  manufacturer
ORDER BY
  total_loss DESC;
```

## 6. Code Breakdown

### 6.1. The `WHERE` Clause
-   `WHERE total_sales < cogs`: This clause is the foundation of the query. It filters the entire table to create a temporary result set containing only the rows for drugs that were sold at a loss.

> [!WARNING]
> Filtering with `WHERE` before grouping is much more efficient than aggregating the entire table and then filtering with a `HAVING` clause (e.g., `HAVING SUM(total_sales) < SUM(cogs)`). Always filter as early as possible.

### 6.2. The `GROUP BY` Clause
-   `GROUP BY manufacturer`: This clause takes the filtered set of loss-making drugs and groups them into "buckets," one for each unique manufacturer. All subsequent aggregate functions will operate on these buckets.

### 6.3. The `SELECT` Clause & Aggregations
-   `COUNT(drug) AS drug_count`: For each manufacturer's group, this function counts the number of rows (which corresponds to the number of unprofitable drugs) and renames the column to `drug_count`.

> [!TIP]
> Using `COUNT(drug)` or `COUNT(*)` would yield the same result here since we've filtered out non-loss drugs. `COUNT(drug)` can be slightly more descriptive of the intent.

-   `SUM(cogs - total_sales) AS total_loss`: This calculates the total loss for each manufacturer.
> [!IMPORTANT]
> The order of subtraction, `cogs - total_sales`, is a direct and efficient way to calculate the loss as a positive number (absolute value). This works because the `WHERE` clause has already guaranteed that for every row being processed, `cogs` is greater than `total_sales`.

### 6.4. The `ORDER BY` Clause
-   `ORDER BY total_loss DESC`: This sorts the final aggregated results, placing the manufacturer with the highest total losses at the top of the output.

> [!CAUTION]
> The problem requires sorting by the calculated `total_loss`. Forgetting the `DESC` keyword would incorrectly sort the results from lowest loss to highest.
