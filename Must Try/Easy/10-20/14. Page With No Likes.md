# Pages with Zero Likes

## 1. Problem Statement

### 1.1. Objective
Assume you're given two tables containing data about Facebook Pages and their respective likes. Write a query to return the IDs of the Facebook pages that have zero likes. The output should be sorted in ascending order based on the page IDs.

> [!IMPORTANT]
> The core task is to find which `page_id`s exist in the `pages` table but do not have any corresponding entries in the `page_likes` table. This is a common data integrity or user engagement analysis pattern known as an "anti-join."

### 1.2. Input Tables

#### 1.2.1. `pages` Table:

|**Column Name**|**Type**|
|---|---|
|page_id|integer|
|page_name|varchar|

**Example Input:**

|**page_id**|**page_name**|
|---|---|
|20001|SQL Solutions|
|20045|Brain Exercises|
|20701|Tips for Data Analysts|

#### 1.2.2. `page_likes` Table:

|**Column Name**|**Type**|
|---|---|
|user_id|integer|
|page_id|integer|
|liked_date|datetime|

**Example Input:**

|**user_id**|**page_id**|**liked_date**|
|---|---|---|
|111|20001|04/08/2022 00:00:00|
|121|20045|03/12/2022 00:00:00|
|156|20001|07/25/2022 00:00:00|

### 1.3. Example Output & Explanation

#### 1.3.1. Example Output:

|**page_id**|
|---|
|20701|

#### 1.3.2. Explanation
In the example data, pages `20001` and `20045` both have entries in the `page_likes` table. Page `20701` exists in the `pages` table but has no corresponding likes, so it is the only one returned in the output.

## 2. Conceptual Approach
To find the Facebook pages with zero likes, we need to identify all pages from the master `pages` list that do not have a matching `page_id` in the `page_likes` table. There are several standard SQL patterns to achieve this.

1.  **`LEFT JOIN` and `IS NULL`**: Join the `pages` table to the `page_likes` table. Pages with no likes will have `NULL` values for the columns from the `page_likes` table. We can filter for these `NULL`s.
2.  **`NOT IN` Subquery**: Select pages where the `page_id` is not in the list of all `page_id`s that have been liked.
3.  **`NOT EXISTS` Correlated Subquery**: For each page, check if there does not exist a corresponding entry in the `page_likes` table.

> [!NOTE]
> All three methods will produce the correct result for this problem, but they can have different performance characteristics and nuances, especially on large datasets.

## 3. SQL Solutions

### 3.1. Method 1: Using `LEFT JOIN` (Recommended for Readability)
This is the most common and often most intuitive method for finding records that exist in one table but not another.

```sql
SELECT
  p.page_id
FROM pages AS p
LEFT JOIN page_likes AS pl
  ON p.page_id = pl.page_id
WHERE
  pl.page_id IS NULL
ORDER BY
  p.page_id ASC;
```

#### 3.1.1. Explanation
-   `LEFT JOIN`: This join is crucial. It starts with every row from the `pages` table (`p`) and tries to find a match in `page_likes` (`pl`).
-   If a match is found, the columns from `pl` are populated.
-   If **no match** is found (meaning the page has never been liked), the columns from `pl` will be `NULL` for that row.
-   `WHERE pl.page_id IS NULL`: This is the filter that isolates our target group. It keeps only the rows where the `LEFT JOIN` failed to find a match, which are precisely the pages with zero likes.

> [!TIP]
> The `LEFT JOIN ... WHERE key IS NULL` pattern is a fundamental SQL technique for performing an "anti-join." It is highly readable and generally performs well.

### 3.2. Method 2: Using `NOT IN`
This method is also very readable but comes with performance caveats.

```sql
SELECT
  page_id
FROM pages
WHERE page_id NOT IN (
  SELECT page_id FROM page_likes WHERE page_id IS NOT NULL
)
ORDER BY page_id ASC;
```
#### 3.2.1. Explanation
-   The subquery `(SELECT page_id FROM page_likes ...)` is executed first. It creates a complete list of all `page_id`s that have at least one like.
-   The outer query then selects `page_id`s from the `pages` table, but the `WHERE page_id NOT IN (...)` clause filters out any page whose ID is present in the subquery's list.

> [!WARNING]
> The `NOT IN` operator can behave unexpectedly and perform poorly if the subquery returns any `NULL` values. It's a best practice to add `WHERE page_id IS NOT NULL` inside the subquery to guard against this, though in this schema `page_id` is likely a non-nullable foreign key.

### 3.3. Method 3: Using `NOT EXISTS` (Often Most Performant)
This method uses a correlated subquery and is often the most efficient for anti-join patterns.

```sql
SELECT
  p.page_id
FROM pages AS p
WHERE NOT EXISTS (
    SELECT 1
    FROM page_likes AS pl
    WHERE pl.page_id = p.page_id
)
ORDER BY p.page_id ASC;
```

#### 3.3.1. Explanation
-   The outer query iterates through each row in the `pages` table (`p`).
-   For **each page**, the `NOT EXISTS` clause runs a correlated subquery.
-   The subquery `(SELECT 1 FROM page_likes ...)` tries to find *any* matching record in the `page_likes` table for the current page (`WHERE pl.page_id = p.page_id`).
-   If the subquery finds a match, `EXISTS` returns `TRUE`, and `NOT EXISTS` becomes `FALSE`, so the page is discarded.
-   If the subquery finds **no match**, `EXISTS` returns `FALSE`, and `NOT EXISTS` becomes `TRUE`, so the page is kept.

> [!IMPORTANT]
> `NOT EXISTS` is highly optimized in most database systems because it can stop searching as soon as it finds the first match in the subquery, making it very efficient for checking for the existence (or non-existence
