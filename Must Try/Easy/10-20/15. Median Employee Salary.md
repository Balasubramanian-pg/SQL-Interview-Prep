# Median Salary by Company

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find the median salary for each company. The median is the middle value in an ordered set of salaries. For companies with an even number of employees, this query will return the two middle salary records.

## 2. Data Model

### 2.1. `Employee` Table
Contains employee records, including their company and salary.
| Id  | Company | Salary |
|:----|:--------|:-------|
| 1   | A       | 2341   |
| 2   | A       | 341    |
| 3   | A       | 15     |
| 4   | A       | 15314  |
| 5   | A       | 451    |
| 6   | A       | 513    |
| 7   | B       | 15     |
...and so on.

## 3. Core Concept: The Logic of Finding a Median
SQL does not have a built-in `MEDIAN()` aggregate function like `AVG()` or `MAX()`. Therefore, we must calculate it manually by finding the middle row(s) in an ordered list. This requires two pieces of information for each employee: their salary rank within their company, and the total number of employees in that company.

> [!IMPORTANT]
> The position of the median depends on whether the count of employees is odd or even.
> - **Odd Count (n):** The median is the single middle value at position `(n + 1) / 2`.
> - **Even Count (n):** The median is conceptually the average of the two middle values at positions `n / 2` and `n / 2 + 1`.

Our query will use a single, elegant `WHERE` clause that handles both of these cases simultaneously:
`WHERE salary_rank BETWEEN employee_count / 2.0 AND employee_count / 2.0 + 1`

## 4. Incremental Query Construction
We will use a Common Table Expression (CTE) to prepare the data before filtering for the median.

### 4.1. Step 1: Rank Salaries and Count Employees per Company
First, we need to use window functions to add the `salary_rank` and `employee_count` to each row without collapsing the data.

```sql
-- This query will become our CTE
SELECT
    Id,
    Company,
    Salary,
    -- Rank salaries in ascending order, restarting for each company.
    ROW_NUMBER() OVER(PARTITION BY Company ORDER BY Salary) AS salary_rank,
    -- Get the total employee count, restarting for each company.
    COUNT(*) OVER(PARTITION BY Company) AS employee_count
FROM
    Employee;
```
**Intermediate Result (`ranked_employees`):**
| Id  | Company | Salary | salary_rank | employee_count |
|:----|:--------|:-------|:------------|:---------------|
| 3   | A       | 15     | 1           | 6              |
| 2   | A       | 341    | 2           | 6              |
| 5   | A       | 451    | 3           | 6              |
| 6   | A       | 513    | 4           | 6              |
| 1   | A       | 2341   | 5           | 6              |
| 4   | A       | 15314  | 6           | 6              |
| 8   | B       | 13     | 1           | 6              |
| ... | ...     | ...    | ...         | ...            |
| 17  | C       | 65     | 1           | 5              |
| ... | ...     | ...    | ...         | ...            |

### 4.2. Step 2: Filter for the Median Ranks
With `salary_rank` and `employee_count` available for every row, we can now apply our filtering logic to isolate the median record(s).

## 5. Final Solution
The complete query uses a CTE to prepare the rankings and counts, then filters the result in the main query.

```sql
WITH ranked_employees AS (
    -- Step 1: Rank salaries and count employees within each company using window functions.
    SELECT
        Id,
        Company,
        Salary,
        ROW_NUMBER() OVER(PARTITION BY Company ORDER BY Salary) AS salary_rank,
        COUNT(*) OVER(PARTITION BY Company) AS employee_count
    FROM Employee
)
-- Step 2: Filter the ranked data to find the median row(s).
SELECT
    Id,
    Company,
    Salary
FROM ranked_employees
WHERE
    salary_rank BETWEEN employee_count / 2.0 AND employee_count / 2.0 + 1
ORDER BY
    Company, Salary;
```

## 6. Result Analysis

### 6.1. Final Output
| Id  | Company | Salary |
|:----|:--------|:-------|
| 5   | A       | 451    |
| 6   | A       | 513    |
| 12  | B       | 234    |
| 9   | B       | 1154   |
| 14  | C       | 2645   |

### 6.2. Explanation
*   **Company A (Even Count = 6):**
    *   The condition becomes `salary_rank BETWEEN 6 / 2.0 AND 6 / 2.0 + 1`, which simplifies to `BETWEEN 3 AND 4`.
    *   The query correctly returns the employees with ranks 3 and 4 (Salaries: 451 and 513).
*   **Company C (Odd Count = 5):**
    *   The condition becomes `salary_rank BETWEEN 5 / 2.0 AND 5 / 2.0 + 1`, which simplifies to `BETWEEN 2.5 AND 3.5`.
    *   Since `salary_rank` is an integer, only rank `3` falls within this range.
    *   The query correctly returns the single employee with rank 3 (Salary: 2645).

> [!TIP]
> This query correctly identifies the record(s) representing the median. For companies with an even number of employees, the two returned salary values would typically be averaged in an application layer or in a subsequent query to calculate the final median value.
