# Laptop vs. Mobile Viewership

## 1. Problem Statement

### 1.1. Objective
Assume you're given a table on user viewership categorized by device type, where the three types are laptop, tablet, and phone.

Write a query that calculates the total viewership for laptops and mobile devices. Output the total viewership for laptops as `laptop_views` and the total viewership for mobile devices as `mobile_views`.

### 1.2. Definition
-   "Mobile" viewership is defined as the sum of tablet and phone viewership.

> [!IMPORTANT]
> The final output should be a single row with two columns: one for the total laptop views and one for the total mobile views. This requires aggregating the entire table into these two categories.

### 1.3. Input Table: `viewership`

#### 1.3.1. Schema
|Column Name|Type|
|---|---|
|user_id|integer|
|device_type|string ('laptop', 'tablet', 'phone')|
|view_time|timestamp|

#### 1.3.2. Example Input
|user_id|device_type|view_time|
|---|---|---|
|123|tablet|01/02/2022 00:00:00|
|125|laptop|01/07/2022 00:00:00|
|128|laptop|02/09/2022 00:00:00|
|129|phone|02/09/2022 00:00:00|
|145|tablet|02/24/2022 00:00:00|

### 1.4. Example Output & Explanation

#### 1.4.1. Example Output
|laptop_views|mobile_views|
|---|---|
|2|3|

#### 1.4.2. Explanation
Based on a larger dataset, there are a total of 2 laptop views and 3 mobile views (sum of tablet and phone views). The example input shows 2 laptop views, 2 tablet views, and 1 phone view, which would result in 2 `laptop_views` and 3 `mobile_views`.

## 2. Conceptual Approach
To solve this, we need to count rows based on conditions and present these counts in separate columns in a single output row. This is a classic **conditional aggregation** problem.

1.  **Create Two Counters**: We need one counter for 'laptop' views and another for 'mobile' views.
2.  **Iterate and Categorize**: For each row in the `viewership` table, we check the `device_type`.
    -   If the type is 'laptop', we increment the laptop counter.
    -   If the type is 'tablet' or 'phone', we increment the mobile counter.
3.  **Aggregate**: After checking all rows, the final values of the two counters are our result.

> [!TIP]
> This technique effectively "pivots" the data. Instead of having device types in rows, we are creating summary columns for our desired categories.

## 3. SQL Solutions

### 3.1. Method 1: Using `SUM` with `CASE` (Most Compatible)
This approach is widely supported across all SQL dialects and is a fundamental pattern for conditional aggregation.

```sql
SELECT
    SUM(CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END) AS laptop_views,
    SUM(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END) AS mobile_views
FROM viewership;
```

### 3.2. Method 2: Using `COUNT` with `FILTER` (PostgreSQL)
This is a more concise and often more readable approach, but it is not universally supported.

```sql
SELECT
    COUNT(*) FILTER (WHERE device_type = 'laptop') AS laptop_views,
    COUNT(*) FILTER (WHERE device_type IN ('tablet', 'phone')) AS mobile_views
FROM viewership;
```
> [!CAUTION]
> The `FILTER` clause is a modern SQL feature, prominently supported by PostgreSQL. It is not available in many other common database systems like MySQL or older versions of SQL Server. The `CASE` expression approach is a safer, more portable choice.

## 4. Code Breakdown (Method 1: `SUM` with `CASE`)

### 4.1. Calculating Laptop Views
-   `SUM(CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END) AS laptop_views`: This expression calculates the total count for laptop views.
-   The `CASE` statement acts as a flag. For each row, it checks if `device_type` is 'laptop'.
    -   If it is, it returns the number `1`.
    -   If it is not, it returns the number `0`.
-   The `SUM()` function then adds up all these `1`s and `0`s. The final sum is equal to the total count of rows where the condition was met.

> [!NOTE]
> Summing a binary flag (a column of 1s and 0s) is a standard and highly efficient SQL pattern for counting items that meet a certain condition.

### 4.2. Calculating Mobile Views
-   `SUM(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END) AS mobile_views`: This follows the exact same logic as the laptop calculation.
-   The key difference is the condition `device_type IN ('tablet', 'phone')`.

> [!TIP]
> Using the `IN` operator is a clean and readable way to check if a value matches any item in a list, making it perfect for grouping 'tablet' and 'phone' into the 'mobile' category.

### 4.3. No `GROUP BY` Clause
> [!IMPORTANT]
> A `GROUP BY` clause is not needed in this query. We are not calculating viewership per user, per month, or per any other category. The objective is to produce a single row containing the grand totals for the entire table. Omitting the `GROUP BY` clause causes the aggregate functions (`SUM`) to operate over the whole table.
