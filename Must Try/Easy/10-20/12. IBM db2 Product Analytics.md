# Histogram of Employee Query Usage

## 1. Problem Statement

### 1.1. Objective
IBM is analyzing how their employees are utilizing the Db2 database by tracking the SQL queries they execute. The objective is to generate data for a histogram that shows the number of unique queries run by employees during the third quarter of 2023 (July to September).

> [!IMPORTANT]
> A key requirement of the analysis is to also count the number of employees who did **not** run any queries during this period. This "zero queries" bucket is essential for understanding the full scope of user engagement.

### 1.2. Input Schemas

#### 1.2.1. `queries` Schema:
|Column Name|Type|Description|
|---|---|---|
|employee_id|integer|The ID of the employee who executed the query.|
|query_id|integer|The unique identifier for each query (Primary Key).|
|query_starttime|datetime|The timestamp when the query started.|
|execution_time|integer|The duration of the query execution in seconds.|

#### 1.2.2. `employees` Schema:
|Column Name|Type|Description|
|---|---|---|
|employee_id|integer|The ID of the employee.|
|full_name|string|The full name of the employee.|
|gender|string|The gender of the employee.|

> [!NOTE]
> The `employees` table serves as the master list of all employees, which is crucial for identifying those who were inactive (ran zero queries).

### 1.3. Example Output & Explanation

#### 1.3.1. Example Output:
|unique_queries|employee_count|
|---|---|
|0|191|
|1|46|
|2|12|
|3|1|

#### 1.3.2. Explanation
The output is a histogram. It shows that:
-   191 employees did not run any queries in Q3 2023.
-   46 employees ran exactly 1 unique query.
-   12 employees ran 2 unique queries, and so on.

## 2. Conceptual Approach
This problem requires a two-level aggregation to build the histogram. The most challenging part is correctly including the count for employees who ran zero queries.

1.  **First Aggregation (Inner Query)**: First, we need to count the number of unique queries executed by each employee within the specified time frame (Q3 2023).
    -   Filter the `queries` table for the correct date range.
    -   Group the results by `employee_id`.
    -   Use `COUNT(DISTINCT query_id)` to get the unique query count for each active employee.

2.  **Include All Employees**: The result from the first step only includes employees who ran at least one query. To include the inactive employees, we must perform a `LEFT JOIN` from the master `employees` table to our aggregated query counts.

3.  **Handle Nulls**: The `LEFT JOIN` will result in `NULL` values for the query count of employees who did not run any queries. We need to convert these `NULL`s to `0` using the `COALESCE` function.

4.  **Second Aggregation (Outer Query)**: Finally, we perform the second aggregation to build the histogram.
    -   Group the results by the (now coalesced) unique query count.
    -   Use `COUNT(employee_id)` to get the number of employees in each group (e.g., how many employees ran 0 queries, 1 query, etc.).

> [!TIP]
> This "two-level aggregation" pattern, where the output of one aggregation becomes the input for a second, is a common technique in data analysis. Using Common Table Expressions (CTEs) is an excellent way to structure this logic clearly.

## 3. SQL Solution

```sql
WITH query_counts AS (
  -- First aggregation: Count unique queries per employee in Q3 2023.
  SELECT
    employee_id,
    COUNT(DISTINCT query_id) AS unique_query_count
  FROM queries
  WHERE query_starttime >= '2023-07-01' AND query_starttime < '2023-10-01'
  GROUP BY employee_id
),
employee_query_summary AS (
  -- Join back to all employees to include those with zero queries.
  SELECT
    e.employee_id,
    COALESCE(qc.unique_query_count, 0) AS unique_queries
  FROM employees AS e
  LEFT JOIN query_counts AS qc
    ON e.employee_id = qc.employee_id
)
-- Second aggregation: Build the histogram.
SELECT
  unique_queries,
  COUNT(employee_id) AS employee_count
FROM employee_query_summary
GROUP BY unique_queries
ORDER BY unique_queries ASC;
```

## 4. Code Breakdown

### 4.1. CTE 1: `query_counts`
-   This CTE performs the first level of aggregation.
-   `WHERE query_starttime >= '2023-07-01' AND query_starttime < '2023-10-01'`: This clause filters for the third quarter of 2023.

> [!WARNING]
> Using `< '2023-10-01'` is a robust way to handle date ranges with timestamps. It correctly includes all times on September 30th without accidentally excluding records from the end of the day or including records from the beginning of the next quarter.

-   `GROUP BY employee_id`: This groups all queries by the employee who ran them.
-   `COUNT(DISTINCT query_id)`: This counts the number of *unique* queries for each employee.

### 4.2. CTE 2: `employee_query_summary`
-   This CTE is crucial for including the inactive employees.
-   `FROM employees AS e LEFT JOIN query_counts AS qc ...`: This performs a `LEFT JOIN` from the master list of all employees to our aggregated query counts.

> [!IMPORTANT]
> A `LEFT JOIN` is essential here. An `INNER JOIN` would incorrectly drop all employees who did not run any queries, making it impossible to create the "0" bucket in our histogram.

-   `COALESCE(qc.unique_query_count, 0) AS unique_queries`: This is the key to handling the inactive employees. The `LEFT JOIN` produces `NULL` for the `unique_query_count` of any employee not found in the `query_counts` CTE. `COALESCE` replaces these `NULL`s with `0`.

> [!TIP]
> `COALESCE(value, default_value)` is a standard SQL function that returns the first non-NULL value in a list of arguments. It's the perfect tool for replacing `NULL`s with a default like 0.

### 4.3. Final `SELECT` Statement
-   This is the second level of aggregation that builds the final histogram.
-   `GROUP BY unique_queries`: This groups all employees by the number of unique queries they ran (0, 1, 2, etc.).
-   `COUNT(employee_id) AS employee_count`: This counts the number of employees within each of those groups.
-   `ORDER BY unique_queries ASC`: This sorts the final histogram for readability.

> [!CAUTION]
> A common mistake is to try to perform both aggregations in a single step, which is not possible. The problem must be broken down logically, and CTEs provide a clean way to do so.
