# Frequent Callers

## 1. Problem Statement

### 1.1. Objective
UnitedHealth Group (UHG) wants to analyze usage of their Advocate4Me program. Specifically, they want to identify policy holders who are frequent users of the service.

Write a query to find how many UHG policy holders made **three or more calls**.

> [!IMPORTANT]
> The final output should be a single number representing the total count of policy holders who meet the "three or more calls" criteria.

### 1.2. Input Table: `callers`

#### 1.2.1. Schema
|**Column Name**|**Type**|
|---|---|
|policy_holder_id|integer|
|case_id|varchar|
|call_category|varchar|
|call_date|timestamp|
|call_duration_secs|integer|

> [!NOTE]
> It is assumed that each unique `case_id` represents a distinct call made by a policy holder.

#### 1.2.2. Example Input
|policy_holder_id|case_id|call_category|
|---|---|---|
|1|f1d012f9-...|emergency assistance|
|1|41ce8fb6-...|authorisation|
|2|9b1af84b-...|claims assistance|
|2|8471a3d4-...|emergency assistance|
|2|38208fae-...|benefits|

### 1.3. Example Output & Explanation

#### 1.3.1. Example Output
|**policy_holder_count**|
|---|
|1|

#### 1.3.2. Explanation
Based on a larger dataset, the example shows that:
-   Policy holder `1` made 2 calls.
-   Policy holder `2` made 3 calls.

Since only policy holder `2` meets the criteria of making three or more calls, the total count of such policy holders is 1.

## 2. Conceptual Approach
To find the number of policy holders who made at least three calls, we need to first count the calls for each individual and then count how many individuals meet the threshold.

1.  **Group by Policy Holder**: First, we need to group all call records by the `policy_holder_id`. This creates a "bucket" for each unique policy holder.
2.  **Count Calls for Each Holder**: For each policy holder's group, we count the number of calls they made.
3.  **Filter for Frequent Callers**: We then filter these groups, keeping only those where the call count is 3 or more.
4.  **Count the Frequent Callers**: Finally, we count how many policy holders remain after the filtering. This final count is our answer.

> [!TIP]
> The `GROUP BY` clause is the key to performing a per-user analysis. The `HAVING` clause is then used to apply a filter condition to the results of the aggregation performed on those groups.

## 3. SQL Solution
To find the number of UHG policy holders who made three or more calls, you can use a SQL query with a subquery.

```sql
SELECT
  COUNT(*) AS policy_holder_count
FROM (
    SELECT
      policy_holder_id
    FROM callers
    GROUP BY
      policy_holder_id
    HAVING
      COUNT(DISTINCT case_id) >= 3
) AS frequent_callers;
```

## 4. Code Breakdown

### 4.1. The Inner Query (Subquery)
The purpose of the inner query is to identify the list of all policy holders who are "frequent callers."

```sql
SELECT
  policy_holder_id
FROM callers
GROUP BY
  policy_holder_id
HAVING
  COUNT(DISTINCT case_id) >= 3
```

-   **`GROUP BY policy_holder_id`**: This clause is essential. It aggregates all rows for each unique policy holder into a single summary row.
-   **`HAVING COUNT(DISTINCT case_id) >= 3`**: This is the filter that defines our cohort.
    -   `HAVING` is used because we are filtering on the result of an aggregate function (`COUNT`). A `WHERE` clause filters rows *before* aggregation, which would not work here.

> [!CAUTION]
> Remember the key difference: `WHERE` filters rows, `HAVING` filters groups. Since our condition is "the count of calls for a group must be >= 3," `HAVING` is the correct choice.

    -   `COUNT(DISTINCT case_id)` counts the number of unique calls for each policy holder.

> [!NOTE]
> Using `DISTINCT` inside the `COUNT` is a robust practice. It protects against potential data issues where the same `case_id` might be logged twice, ensuring we count each unique call only once.

> [!TIP]
> The result of this subquery is a temporary table (aliased as `frequent_callers`) that contains a single column: a list of the `policy_holder_id`s who made 3 or more calls.

### 4.2. The Outer Query
The outer query performs the final, simple count on the results of the subquery.

```sql
SELECT
  COUNT(*) AS policy_holder_count
FROM (...) AS frequent_callers;
```
-   `FROM (...) AS frequent_callers`: This specifies that we are querying the temporary result set generated by our inner query.
-   `COUNT(*)`: This function simply counts the number of rows in the `frequent_callers` result set. Since each row represents one policy holder who met our criteria, this gives us the final answer.

> [!IMPORTANT]
> The final `COUNT(*)` is counting *policy holders*, whereas the `COUNT(DISTINCT case_id)` in the subquery was counting *calls*. This two-step aggregation is the key to solving the problem correctly.
