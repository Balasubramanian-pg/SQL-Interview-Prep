# Histogram of Tweets

## 1. Problem Statement

### 1.1. Objective
Assume you're given a table of Twitter tweet data. Write a query to obtain a histogram of tweets posted per user in 2022. Output the tweet count per user as the bucket and the number of Twitter users who fall into that bucket.

In other words, group the users by the number of tweets they posted in 2022 and count the number of users in each group.

> [!IMPORTANT]
> This is a two-step aggregation problem. First, you must count the number of tweets for each user. Second, you must count the number of users corresponding to each of those tweet counts. This is often called calculating a "frequency of a frequency."

### 1.2. Input Table: `tweets`

|Column Name|Type|
|---|---|
|tweet_id|integer|
|user_id|integer|
|msg|string|
|tweet_date|timestamp|

#### 1.2.1. Example Input
|tweet_id|user_id|msg|tweet_date|
|---|---|---|---|
|214252|111|Am considering taking Tesla...|12/30/2021 00:00:00|
|739252|111|Despite the constant negative...|01/01/2022 00:00:00|
|846402|111|Following @NickSinghTech...|02/14/2022 00:00:00|
|241425|254|If the salary is so competitive...|03/01/2022 00:00:00|
|231574|148|I no longer have a manager...|03/23/2022 00:00:00|

> [!NOTE]
> The tweet with `tweet_id` 214252 from 2021 will be excluded from the calculation, as the analysis is focused only on 2022.

### 1.3. Example Output & Explanation

#### 1.3.1. Example Output
|tweet_bucket|users_num|
|---|---|
|1|2|
|2|1|

#### 1.3.2. Explanation
Based on the example input (and filtering for 2022):
-   User `111` posted 2 tweets.
-   User `254` posted 1 tweet.
-   User `148` posted 1 tweet.

When we create the histogram:
-   The bucket for "1 tweet" (`tweet_bucket`=1) contains 2 users (254 and 148).
-   The bucket for "2 tweets" (`tweet_bucket`=2) contains 1 user (111).

## 2. Conceptual Approach
To generate the histogram, we need to perform two levels of aggregation.

1.  **First Aggregation (Inner Query)**: First, we need to count the number of tweets posted by each user in 2022.
    -   Filter the `tweets` table for the year 2022.
    -   Group the results by `user_id`.
    -   Use `COUNT()` to get the total tweets for each user.
    -   This will give us an intermediate result like `(user_id, tweet_count)`.

2.  **Second Aggregation (Outer Query)**: Next, we need to count how many users fall into each `tweet_count` bucket.
    -   Use the result from the first step as the input.
    -   Group the results by the `tweet_count`.
    -   Use `COUNT()` again to get the number of users in each group.

> [!TIP]
> This two-level aggregation structure is perfectly suited for a subquery or a Common Table Expression (CTE), where the inner query performs the first aggregation and the outer query performs the second.

## 3. SQL Solution (Subquery Approach)

```sql
SELECT
    tweet_count AS tweet_bucket,
    COUNT(*) AS users_num
FROM (
    -- Inner Query: First aggregation to count tweets per user
    SELECT
        user_id,
        COUNT(tweet_id) AS tweet_count
    FROM tweets
    WHERE EXTRACT(YEAR FROM tweet_date) = 2022
    GROUP BY user_id
) AS user_tweet_counts
GROUP BY tweet_count
ORDER BY tweet_bucket ASC;
```

## 4. Code Breakdown

### 4.1. The Inner Query (Subquery)
-   `FROM tweets WHERE EXTRACT(YEAR FROM tweet_date) = 2022`: This line filters the dataset to include only tweets from the year 2022.
-   `GROUP BY user_id`: This aggregates the rows for each `user_id` so we can count their tweets.
-   `COUNT(tweet_id) AS tweet_count`: This counts the number of tweets for each user and creates the `tweet_count` column.
-   The result of this subquery is a temporary table (aliased as `user_tweet_counts`) that lists each user and their total tweet count for the year.

> [!CAUTION]
> The function to extract the year from a timestamp varies by SQL dialect.
> - **PostgreSQL**: `EXTRACT(YEAR FROM tweet_date)`
> - **MySQL/SQL Server**: `YEAR(tweet_date)`
> - **SQLite**: `STRFTIME('%Y', tweet_date)`

### 4.2. The Outer Query
-   `FROM (...) AS user_tweet_counts`: This indicates that the outer query is operating on the intermediate result generated by the inner query.
-   `GROUP BY tweet_count`: This is the second level of aggregation. It groups together all users who have the same `tweet_count`. For example, all users who tweeted 5 times will be in one group.
-   `COUNT(*) AS users_num`: This counts the number of rows (i.e., users) within each `tweet_count` group, giving us the final number for our histogram.
-   `ORDER BY tweet_bucket ASC`: This sorts the final output for readability.

> [!IMPORTANT]
> The outer query's `COUNT(*)` is counting *users*, while the inner query's `COUNT(tweet_id)` is counting *tweets*. This distinction is the key to solving the problem.

## 5. Alternative Solution (CTE Approach)
A Common Table Expression (CTE) can make the same logic more readable and easier to maintain.

```sql
WITH user_tweet_counts AS (
  SELECT
    user_id,
    COUNT(tweet_id) AS tweet_count
  FROM tweets
  WHERE EXTRACT(YEAR FROM tweet_date) = 2022
  GROUP BY user_id
)
SELECT
  tweet_count AS tweet_bucket,
  COUNT(user_id) AS users_num
FROM user_tweet_counts
GROUP BY tweet_count
ORDER BY tweet_bucket ASC;
```
> [!NOTE]
> This CTE approach is functionally identical to the subquery method but is often preferred in modern SQL for its clarity. It explicitly separates the first aggregation step (`user_tweet_counts`) from the final aggregation step, making the query's logic easier to follow.
