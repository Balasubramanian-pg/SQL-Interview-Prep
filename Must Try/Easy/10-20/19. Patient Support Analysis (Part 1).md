# Policy Holders with Frequent Calls

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find the total number of UnitedHealth Group (UHG) policy holders who have made three or more distinct calls. Each unique call is identified by the `case_id`.

## 2. Data Model

### 2.1. `callers` Table
Contains a log of all calls made by policy holders to the Advocate4Me program.
| Column Name        | Type      |
|:-------------------|:----------|
| policy_holder_id   | integer   |
| case_id            | varchar   |
| call_category      | varchar   |
| call_date          | timestamp |
| call_duration_secs | integer   |

### 2.2. Example Data
| policy_holder_id | case_id                              | call_category        |
|:-----------------|:-------------------------------------|:---------------------|
| 1                | f1d012f9-9d02-4966-a968-bf6c5bc9a9fe | emergency assistance |
| 1                | 41ce8fb6-1ddd-4f50-ac31-07bfcce6aaab | authorisation        |
| 2                | 9b1af84b-eedb-4c21-9730-6f099cc2cc5e | claims assistance    |
| 2                | 8471a3d4-6fc7-4bb2-9fc7-4583e3638a9e | emergency assistance |
| 2                | 38208fae-bad0-49bf-99aa-7842ba2e37bc | benefits             |

## 3. Incremental Query Construction
The problem requires us to first identify the policy holders who meet a certain condition (3+ calls) and then count how many such holders there are. This is a classic two-step aggregation problem, which is well-suited for a subquery or a Common Table Expression (CTE).

### 3.1. Step 1: Find Policy Holders with 3 or More Calls
First, we need to group the `callers` table by `policy_holder_id` and count the number of calls for each holder.

> [!IMPORTANT]
> The problem statement specifies that "each call is identified by the `case_id` column." This implies we should count the number of *distinct* `case_id`s for each policy holder to avoid overcounting if the data contains duplicate rows for the same call.

```sql
SELECT
    policy_holder_id,
    COUNT(DISTINCT case_id) AS call_count
FROM
    callers
GROUP BY
    policy_holder_id;
```
Now, we add a `HAVING` clause to filter this result, keeping only the policy holders with a `call_count` of 3 or more.

```sql
-- This query identifies the "frequent callers"
SELECT
    policy_holder_id
FROM
    callers
GROUP BY
    policy_holder_id
HAVING
    COUNT(DISTINCT case_id) >= 3;
```
**Intermediate Result:**
| policy_holder_id |
|:-----------------|
| 2                |
...and any others who meet the criteria.

### 3.2. Step 2: Count the Frequent Callers
The previous query gives us a list of all policy holders who made 3 or more calls. The final step is to count how many rows are in this list. We can do this by wrapping the previous query in a subquery and counting the results.

## 4. Final Solution
The complete query uses a subquery to first identify the frequent callers and then an outer query to count them.

```sql
-- The outer query counts the rows generated by the inner query.
SELECT
    COUNT(*) AS policy_holder_count
FROM (
    -- The inner query (subquery) identifies all policy holders with 3 or more distinct calls.
    SELECT
        policy_holder_id
    FROM
        callers
    -- Group all call records by the policy holder.
    GROUP BY
        policy_holder_id
    -- Filter the groups, keeping only those with a count of 3 or more distinct case_ids.
    HAVING
        COUNT(DISTINCT case_id) >= 3
) AS frequent_callers;
```

> [!TIP]
> An alternative and often more readable approach for multi-step logic is to use a Common Table Expression (CTE). The result is identical.
> ```sql
> WITH frequent_callers AS (
>   SELECT
>     policy_holder_id
>   FROM callers
>   GROUP BY policy_holder_id
>   HAVING COUNT(DISTINCT case_id) >= 3
> )
> SELECT COUNT(policy_holder_id) AS policy_holder_count
> FROM frequent_callers;
> ```

## 5. Result Analysis

### 5.1. Final Output
| policy_holder_count |
|:--------------------|
| 1                   |

### 5.2. Explanation
*   The subquery first groups all calls by `policy_holder_id`.
*   It finds that policy holder `1` made 2 distinct calls. This group is filtered out by the `HAVING COUNT(...) >= 3` clause.
*   It finds that policy holder `2` made 3 distinct calls. This group is kept.
*   The subquery returns a list containing just one ID: `2`.
*   The outer query then runs `COUNT(*)` on this list, resulting in `1`.
