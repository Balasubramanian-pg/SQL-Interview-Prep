# Companies with Duplicate Job Listings

## 1. Problem Statement

### 1.1. Objective
Assume you're given a table containing job postings from various companies on the LinkedIn platform. Write a query to retrieve the count of companies that have posted duplicate job listings.

### 1.2. Definition
-   Duplicate job listings are defined as two or more job listings within the **same company** that share an **identical title and description**.

> [!IMPORTANT]
> The definition of a "duplicate" is the core of this problem. It requires a match on three columns simultaneously: `company_id`, `title`, and `description`.

### 1.3. Input Table: `job_listings`

|Column Name|Type|
|---|---|
|job_id|integer|
|company_id|integer|
|title|string|
|description|string|

#### 1.3.1. Example Input
|job_id|company_id|title|description|
|---|---|---|---|
|248|827|Business Analyst|Business analyst evaluates...|
|149|845|Business Analyst|Business analyst evaluates...|
|945|345|Data Analyst|Data analyst reviews data to identify...|
|164|345|Data Analyst|Data analyst reviews data to identify...|
|172|244|Data Engineer|Data engineer works in a variety...|

### 1.4. Example Output & Explanation

#### 1.4.1. Example Output
|duplicate_companies|
|---|
|1|

#### 1.4.2. Explanation
In the example, company `345` has two job listings (`job_id` 945 and 164) that are identical in both `title` ('Data Analyst') and `description`. Therefore, this company has posted a duplicate listing. No other company has done so, making the final count 1.

## 2. Conceptual Approach
To solve this problem, we need to first identify which listings are duplicates and then count the number of unique companies associated with those duplicates.

1.  **Group Identical Listings**: Group the job listings by the criteria for a duplicate: `company_id`, `title`, and `description`.
2.  **Identify Duplicate Groups**: For each of these groups, count how many jobs are in it. If the count is greater than 1, it represents a duplicate listing for that company.
3.  **Count the Companies**: Finally, count how many unique companies have at least one of these duplicate groups.

> [!TIP]
> This is a two-step aggregation problem. The first step finds the duplicate listings per company, and the second step counts the companies. This structure lends itself well to using a subquery or a Common Table Expression (CTE).

## 3. SQL Solutions

### 3.1. Method 1: Using `GROUP BY` and `HAVING`
This is the most classic and direct way to solve this problem.

```sql
SELECT
  COUNT(DISTINCT company_id) AS duplicate_companies
FROM (
  SELECT
    company_id
  FROM job_listings
  GROUP BY
    company_id, title, description
  HAVING
    COUNT(job_id) > 1
) AS duplicate_listings;
```

#### 3.1.1. Explanation
-   **Inner Subquery**: The subquery `(SELECT company_id FROM ...)` is the core of the logic.
    -   `GROUP BY company_id, title, description`: This groups rows that are identical on all three criteria.
    -   `HAVING COUNT(job_id) > 1`: This is a filter applied *after* grouping. It keeps only the groups that contain more than one job, which are, by definition, our duplicate listings.
    -   The result of this subquery is a list of `company_id`s that have posted at least one duplicate job.

> [!NOTE]
> The `HAVING` clause is essential here because it operates on the result of an aggregate function (`COUNT`). A `WHERE` clause cannot be used for this purpose as it filters rows *before* aggregation.

-   **Outer Query**:
    -   `SELECT COUNT(DISTINCT company_id) ...`: The outer query takes the list of company IDs from the subquery and counts how many unique companies are in it. `DISTINCT` is used because a company could have multiple different sets of duplicate listings, but we only want to count the company once.

### 3.2. Method 2: Using a Window Function
This is a more modern approach that can be more readable for those familiar with window functions.

```sql
WITH duplicate_listings AS (
  SELECT
    company_id,
    COUNT(*) OVER (PARTITION BY company_id, title, description) AS listing_count
  FROM job_listings
)
SELECT
  COUNT(DISTINCT company_id) AS duplicate_companies
FROM duplicate_listings
WHERE listing_count > 1;
```

#### 3.2.1. Explanation
-   **`duplicate_listings` CTE**:
    -   `COUNT(*) OVER (PARTITION BY ...)`: This window function counts the number of jobs within each partition.
    -   `PARTITION BY company_id, title, description`: This clause defines the groups, identical to the `GROUP BY` clause in the first method. The function "stamps" the count of identical listings onto every single row in that group without collapsing them.

> [!IMPORTANT]
> The `PARTITION BY` clause is the window function equivalent of `GROUP BY` for defining the groups over which the function operates.

-   **Final `SELECT`**:
    -   The final query reads from the CTE and applies a simple `WHERE listing_count > 1` filter to find all rows that are part of a duplicate set.
    -   It then performs a `COUNT(DISTINCT company_id)` on the filtered rows.

> [!CAUTION]
> This method might be slightly less performant on some database systems as it calculates the count for every row before filtering, whereas the `GROUP BY`/`HAVING` method aggregates first. However, the readability is often considered superior.

### 3.3. Method 3: Using `EXISTS`
This method uses a correlated subquery to check for the existence of duplicates.

```sql
SELECT
  COUNT(DISTINCT j1.company_id) AS duplicate_companies
FROM job_listings AS j1
WHERE EXISTS (
  SELECT 1
  FROM job_listings AS j2
  WHERE j1.company_id = j2.company_id
    AND j1.title = j2.title
    AND j1.description = j2.description
    AND j1.job_id != j2.job_id
);
```

#### 3.3.1. Explanation
-   The outer query iterates through each job listing (`j1`).
-   For each listing, the `EXISTS` clause runs a subquery.
-   The subquery checks if there is at least one other job listing (`j2`) for the same company, with the same title and description, but a different `job_id`.

> [!WARNING]
> The condition `j1.job_id != j2.job_id` is absolutely critical. Without it, every job listing would find itself in the subquery, and every company would be incorrectly flagged as having duplicates.

-   If the subquery finds such a duplicate, `EXISTS` returns `TRUE`, and the `company_id` from `j1` is included in the set to be counted.
-   `EXISTS` is often efficient because it can stop searching as soon as it finds the first match.
