# Identifying Subject Matter Experts (SMEs)

## 1. The Business Question
The objective of this query is to identify employees who qualify as "Subject Matter Experts" (SMEs) based on a specific, multi-part set of criteria related to their domains of expertise and years of experience.

The business question is:
**"Which employees qualify as SMEs? An SME is defined as an employee who meets *either* of the following conditions:**
*   **Condition A**: They have expertise in **exactly one** domain with at least **8 years** of experience in it.
*   **Condition B**: They have expertise in **exactly two** domains with a combined total of at least **12 years** of experience across them."

> [!IMPORTANT]
> The logic requires evaluating two separate conditions using an `OR` operator. This means an employee only needs to satisfy one of the two definitions to be considered an SME.

## 2. Assumed Table Schema
The query references a single table, `employee_expertise`, which is structured to hold multiple skill/domain entries for each employee. A plausible schema would be:

```sql
-- Table: employee_expertise
-- Stores a record for each domain of expertise an employee has.
CREATE TABLE employee_expertise (
    employee_id         INT NOT NULL,
    domain              VARCHAR(100) NOT NULL,
    years_of_experience INT NOT NULL
);
```

> [!TIP]
> To ensure data integrity, a composite primary key on `(employee_id, domain)` would prevent an employee from having duplicate entries for the same domain. An index on `employee_id` is also crucial for the performance of the `GROUP BY` operation.

## 3. Solution Approaches

### 3.1. Method 1: Complex `HAVING` Clause (Direct Approach)
This is a very direct and efficient way to solve this problem by applying the complex filtering logic directly after the aggregation.

```sql
SELECT
    employee_id
FROM
    employee_expertise
GROUP BY
    employee_id
HAVING
    (COUNT(DISTINCT domain) = 2 AND SUM(years_of_experience) >= 12)
    OR (COUNT(DISTINCT domain) = 1 AND SUM(years_of_experience) >= 8);
```

#### 3.1.1. Explanation

1.  **`GROUP BY employee_id`**: This is the most important step. It groups all rows belonging to the same `employee_id` together. This creates a "summary bucket" for each employee, containing all their listed domains and associated years of experience.

2.  **The `HAVING` Clause**: The `HAVING` clause is used to filter these *groups* (the employees) based on aggregate calculations like `COUNT()` and `SUM()`. It will only keep the groups that satisfy the compound condition.
    -   The `OR` operator is key here. An employee's group is kept if it meets the first condition `OR` the second condition.
    -   **Condition 1**: `(COUNT(DISTINCT domain) = 2 AND SUM(years_of_experience) >= 12)` checks for employees who meet the "two-domain" criteria.
    -   **Condition 2**: `(COUNT(DISTINCT domain) = 1 AND SUM(years_of_experience) >= 8)` checks for employees who meet the "one-domain" criteria.

> [!NOTE]
> The `HAVING` clause is the correct tool for this job because we are filtering based on the results of aggregate functions (`COUNT` and `SUM`). A `WHERE` clause, which filters rows *before* aggregation, cannot be used here.

### 3.2. Method 2: Using a Common Table Expression (CTE)
An alternative approach, which is often more readable for complex filtering, is to first calculate the aggregate metrics for all employees in a CTE and then filter the results in a simple `WHERE` clause.

> [!TIP]
> This CTE approach is often preferred in complex scenarios because it improves readability by separating the aggregation logic from the filtering logic. It makes the query more self-documenting.

```sql
WITH employee_summary AS (
    -- Step 1: Calculate the total domains and experience for every employee.
    SELECT
        employee_id,
        COUNT(DISTINCT domain) AS domain_count,
        SUM(years_of_experience) AS total_experience
    FROM
        employee_expertise
    GROUP BY
        employee_id
)
-- Step 2: Filter the summary results based on the SME criteria.
SELECT
    employee_id
FROM
    employee_summary
WHERE
    (domain_count = 2 AND total_experience >= 12)
    OR (domain_count = 1 AND total_experience >= 8);
```

#### 3.2.1. Explanation

1.  **The `employee_summary` CTE**:
    -   This first part of the query creates a temporary, pre-aggregated result set named `employee_summary`.
    -   It calculates two key metrics for **every single employee**: their total number of unique domains (`domain_count`) and their total combined years of experience (`total_experience`).
    -   The result is a simple summary table with one row per employee.

> [!CAUTION]
> In this CTE, `COUNT(DISTINCT domain)` is a robust way to count domains. If the source data could have duplicates (e.g., 'Cloud' listed twice for the same employee), `DISTINCT` ensures the count is accurate.

2.  **The Final `SELECT` Statement**:
    -   This query now operates on the clean, pre-aggregated data in `employee_summary`.
    -   Instead of a complex `HAVING` clause, it uses a standard `WHERE` clause to filter the summary rows. The logic in the `WHERE` clause is identical to the original `HAVING` clause, but it's applied to simple columns (`domain_count`, `total_experience`), which can make the query easier to read and maintain.

## 4. Comparison of Methods
-   **Method 1 (`HAVING`)**: Very direct and efficient. For a query of this complexity, it is a perfectly acceptable and high-performance solution.
-   **Method 2 (CTE)**: Offers superior readability and modularity. It separates the "what to calculate" (in the CTE) from the "what to keep" (in the final `WHERE` clause). This can be a significant advantage as the business logic becomes more complex.

> [!IMPORTANT]
> The performance of both methods is typically very similar in modern database systems, as the query optimizer will likely generate the same execution plan. The choice between them is often a matter of coding style and readability preference.
