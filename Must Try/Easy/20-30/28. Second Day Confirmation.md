# Second-Day Confirmations

## 1. Problem Statement

### 1.1. Objective
Assume you're given tables with information about TikTok user sign-ups and confirmations through email and text. New users on TikTok sign up using their email addresses, and upon sign-up, each user receives a text message confirmation to activate their account.

Write a query to display the user IDs of those who did not confirm their sign-up on the first day, but confirmed on the second day.

### 1.2. Definition
-   `action_date` refers to the date when users activated their accounts and confirmed their sign-up through text messages.
-   The "first day" is the `signup_date`. The "second day" is the day immediately following the `signup_date`.

> [!IMPORTANT]
> The query must specifically identify users whose confirmation (`signup_action = 'Confirmed'`) occurred exactly one day after their registration. Confirmations on the same day or more than one day later should be excluded.

## 2. Input Tables

### 2.1. `emails` Table:

|**Column Name**|**Type**|
|---|---|
|email_id|integer|
|user_id|integer|
|signup_date|datetime|

#### 2.1.1. Example Input:
|**email_id**|**user_id**|**signup_date**|
|---|---|---|
|125|7771|06/14/2022 00:00:00|
|433|1052|07/09/2022 00:00:00|

### 2.2. `texts` Table:

|**Column Name**|**Type**|
|---|---|
|text_id|integer|
|email_id|integer|
|signup_action|string ('Confirmed', 'Not confirmed')|
|action_date|datetime|

#### 2.2.1. Example Input:
|**text_id**|**email_id**|**signup_action**|**action_date**|
|---|---|---|---|
|6878|125|Confirmed|06/14/2022 00:00:00|
|6997|433|Not Confirmed|07/09/2022 00:00:00|
|7000|433|Confirmed|07/10/2022 00:00:00|

## 3. Example Output & Explanation

### 3.1. Example Output:

|**user_id**|
|---|
|1052|

### 3.2. Explanation
-   User `7771` (via `email_id` 125) signed up on `06/14/2022` and confirmed on the same day. The day difference is 0, so they are excluded.
-   User `1052` (via `email_id` 433) signed up on `07/09/2022` and confirmed on `07/10/2022`. The day difference is exactly 1, so they are included in the output.

## 4. Conceptual Approach
To find users who confirmed on the second day, we need to connect their signup information with their confirmation actions and measure the time difference.

1.  **Link Signup and Action**: Join the `emails` table with the `texts` table on `email_id`. This allows us to compare the `signup_date` with the `action_date` for each user action.
2.  **Filter for Confirmed Actions**: We are only interested in successful activations, so we filter the results to include only rows where `signup_action` is 'Confirmed'.
3.  **Calculate Day Difference**: For the remaining rows, calculate the number of days between the `action_date` and the `signup_date`.
4.  **Filter for Second-Day Confirmations**: Keep only the rows where the calculated difference is exactly 1 day.
5.  **Select Unique Users**: Select the distinct `user_id`s from the filtered results.

> [!TIP]
> Using an `INNER JOIN` is appropriate here because we are only interested in users who both signed up (exist in `emails`) and have a confirmation action (exist in `texts`).

> [!NOTE]
> The prompt implies that there will be at most one 'Confirmed' action per user, which simplifies the logic. If a user could confirm multiple times, a more complex query using window functions might be needed to find their *first* confirmation date.

## 5. SQL Solution
The exact syntax for calculating the difference between two dates can vary by SQL dialect.

### 5.1. MySQL Solution

```sql
SELECT DISTINCT
  e.user_id
FROM emails AS e
INNER JOIN texts AS t
  ON e.email_id = t.email_id
WHERE
  t.signup_action = 'Confirmed'
  AND DATEDIFF(t.action_date, e.signup_date) = 1;
```

### 5.2. PostgreSQL Solution

```sql
SELECT DISTINCT
  e.user_id
FROM emails AS e
INNER JOIN texts AS t
  ON e.email_id = t.email_id
WHERE
  t.signup_action = 'Confirmed'
  AND DATE(t.action_date) - DATE(e.signup_date) = 1;
```

## 6. Code Breakdown (MySQL Example)

### 6.1. The `SELECT DISTINCT` Clause
-   `SELECT DISTINCT e.user_id`: This selects the unique user IDs. `DISTINCT` is used as a safeguard in case the join or data structure could result in multiple rows for the same user meeting the criteria.

> [!CAUTION]
> It is good practice to use table aliases (like `e` for `emails` and `t` for `texts`) to make the query more readable and to avoid ambiguity when columns have the same name.

### 6.2. The `INNER JOIN` Clause
-   `FROM emails AS e INNER JOIN texts AS t ON e.email_id = t.email_id`: This combines the two tables, creating a row for each text action that has a corresponding email signup. This allows us to have both `signup_date` and `action_date` in the same row for comparison.

### 6.3. The `WHERE` Clause
The `WHERE` clause applies two critical filters to the joined data.

-   `t.signup_action = 'Confirmed'`: This first condition filters out all irrelevant actions (like 'Not Confirmed'), leaving only the successful confirmation events.
-   `AND DATEDIFF(t.action_date, e.signup_date) = 1`: This is the core logic of the query.
    -   `DATEDIFF(end_date, start_date)`: This MySQL function calculates the difference between two dates in days.
    -   `= 1`: This condition ensures that we only keep the rows where the confirmation happened exactly one day after the signup.

> [!IMPORTANT]
> Be mindful of the date function syntax for your specific SQL dialect. For example, in SQL Server, the function would be `DATEDIFF(day, e.signup_date, t.action_date) = 1`. In PostgreSQL, a direct subtraction of `DATE` types works.

> [!TIP]
> It's often safer to cast or convert timestamps to dates before comparing them (e.g., `DATEDIFF(DATE(t.action_date), DATE(e.signup_date))`) to avoid issues with time components affecting the day count. However, for this problem, the difference in days is the primary concern.
