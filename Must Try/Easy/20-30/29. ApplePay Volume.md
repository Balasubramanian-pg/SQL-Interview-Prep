# Merchant Transaction Volume via Apple Pay

## 1. The Business Question
Based on the provided SQL, the business question being asked is:

**"What is the total transaction volume processed via Apple Pay for each merchant? List the merchants in descending order, from the one with the highest Apple Pay volume to the lowest."**

> [!IMPORTANT]
> "Transaction volume" in this context refers to the total monetary value of transactions, not the number of transactions.

## 2. Assumed Table Schema
The query references a single table, `transactions`. A plausible schema for this table would be:

```sql
-- Table: transactions
-- Stores a record of every transaction processed.
CREATE TABLE transactions (
    transaction_id     INT PRIMARY KEY,
    merchant_id        INT NOT NULL,                   -- The ID of the merchant
    transaction_amount DECIMAL(10, 2) NOT NULL,        -- The value of the transaction
    payment_method     VARCHAR(50),                    -- e.g., 'Apple Pay', 'Credit Card'
    transaction_date   TIMESTAMP
);
```
> [!TIP]
> To optimize this query, an index on `merchant_id` would be beneficial as it's the key used for grouping. If the `payment_method` column has low cardinality, a composite index on `(merchant_id, payment_method)` could be even more effective.

## 3. Solution Approaches

### 3.1. Method 1: Conditional Aggregation with `CASE`
This is a powerful technique that calculates the sum for a specific subset of data while still considering all merchants.

```sql
SELECT
    merchant_id,
    SUM(
        CASE
            WHEN LOWER(payment_method) = 'apple pay' THEN transaction_amount
            ELSE 0
        END
    ) AS volume
FROM
    transactions
GROUP BY
    merchant_id
ORDER BY
    volume DESC;
```

#### 3.1.1. Explanation

1.  **`GROUP BY merchant_id`**: This is the foundational step. It groups all transaction rows by `merchant_id`, so the `SUM` function will calculate a separate total for each merchant.

2.  **`CASE WHEN ... END`**: This is an `if-then-else` statement that operates on every single row *before* the `SUM` is calculated.
    -   `LOWER(payment_method) = 'apple pay'`: This converts the `payment_method` text to lowercase for a case-insensitive match (e.g., it will correctly handle 'Apple Pay', 'apple pay', or 'APPLE PAY').
    -   If a transaction's payment method is 'apple pay', the `CASE` statement returns its `transaction_amount`.
    -   If not, it returns `0`.

3.  **`SUM(...)`**: The `SUM` function then adds up the values produced by the `CASE` statement for all transactions belonging to a single merchant. This effectively sums only the Apple Pay transactions, because all other transactions contribute `0` to the total.

4.  **`ORDER BY volume DESC`**: Finally, this sorts the results, placing the merchant with the highest Apple Pay volume at the top.

> [!NOTE]
> The primary advantage of this method is that it will list **all** merchants in the output, including those with an Apple Pay volume of `0`. This is useful for a complete report showing every merchant's status.

### 3.2. Method 2: Filtering with `WHERE` (More Performant)
A more direct and often more performant way to write this query is to filter the rows *before* aggregating them.

```sql
SELECT
    merchant_id,
    SUM(transaction_amount) AS volume
FROM
    transactions
WHERE
    LOWER(payment_method) = 'apple pay'
GROUP BY
    merchant_id
ORDER BY
    volume DESC;
```

#### 3.2.1. Explanation

1.  **`WHERE LOWER(payment_method) = 'apple pay'`**: This is the key difference. This clause **filters the entire table first**, keeping only the rows where the payment method is 'apple pay'. All other rows (e.g., 'Credit Card') are discarded before any grouping or calculation happens.

> [!TIP]
> Filtering with `WHERE` before aggregating is generally more efficient than conditional aggregation, especially if the target subset ('apple pay' transactions) is a small fraction of the total data. The database has to perform the aggregation on a much smaller set of rows.

2.  **`GROUP BY merchant_id`**: This then groups the remaining (Apple Pay only) rows by `merchant_id`.

3.  **`SUM(transaction_amount)`**: Since only Apple Pay transactions are left, we can now use a simple `SUM(transaction_amount)`. The calculation is performed on the pre-filtered data for each merchant group.

4.  **`ORDER BY volume DESC`**: This sorts the final result set.

> [!WARNING]
> This `WHERE` clause method will **only** return merchants who have had at least one Apple Pay transaction. Merchants with zero Apple Pay volume will not appear in the results at all. This is an important distinction from the conditional aggregation method.

## 4. Comparison of Methods
-   **Method 1 (Conditional Aggregation)**:
    -   **Pro**: Returns all merchants, including those with zero volume, which might be required for a comprehensive report.
    -   **Con**: Can be less performant as it aggregates over the entire table.

-   **Method 2 (`WHERE` clause)**:
    -   **Pro**: More efficient, especially on large tables, as it reduces the amount of data to be aggregated.
    -   **Con**: Excludes merchants with no Apple Pay transactions from the result set.

> [!IMPORTANT]
> The choice between these two methods depends on the specific business requirement. If the goal is a ranked list of *only* the merchants who use Apple Pay, Method 2 is superior. If the goal is a complete report on *all* merchants showing their Apple Pay volume (even if zero), Method 1 is the correct choice.
