# Top 2 Power Users on Microsoft Teams

## 1. Problem Statement

### 1.1. Objective
Write a query to identify the top 2 Power Users who sent the highest number of messages on Microsoft Teams in August 2022. Display the IDs of these 2 users along with the total number of messages they sent. Output the results in descending order based on the count of the messages.

### 1.2. Assumption
-   No two users have sent the same number of messages in August 2022.

> [!IMPORTANT]
> The analysis is time-bound to a specific month and year (August 2022) and requires finding the "Top N" users, which involves aggregating, ordering, and limiting the results.

## 2. Input Table: `messages`

### 2.1. Schema
|**Column Name**|**Type**|
|---|---|
|message_id|integer|
|sender_id|integer|
|receiver_id|integer|
|content|varchar|
|sent_date|datetime|

### 2.2. Example Input
|**message_id**|**sender_id**|**receiver_id**|**content**|**sent_date**|
|---|---|---|---|---|
|901|3601|4500|You up?|08/03/2022 00:00:00|
|902|4500|3601|Only if you're buying|08/03/2022 00:00:00|
|743|3601|8752|Let's take this offline|06/14/2022 00:00:00|
|922|3601|4500|Get on the call|08/10/2022 00:00:00|

> [!NOTE]
> The message with `message_id` 743 is from June 2022 and will be excluded by the date filter in the query.

## 3. Example Output

|**sender_id**|**message_count**|
|---|---|
|3601|2|
|4500|1|

## 4. Conceptual Approach
To identify the top 2 power users, we need to follow a standard aggregation and ranking process.

1.  **Filter by Time Period**: First, isolate the data to only include messages sent in August 2022.
2.  **Group by Sender**: Group the filtered messages by the `sender_id` to analyze each user's activity.
3.  **Count Messages**: For each sender, count the number of messages they sent.
4.  **Order by Count**: Sort the users in descending order based on their message count to bring the top users to the front.
5.  **Limit to Top 2**: Select only the top two rows from the sorted result.

> [!TIP]
> This "Filter -> Group -> Aggregate -> Order -> Limit" pattern is a fundamental and highly common sequence in SQL for performing Top-N analysis.

## 5. SQL Solutions

### 5.1. Method 1: Using `GROUP BY`, `ORDER BY`, and `LIMIT` (Recommended)
This is the most direct and common way to solve this problem.

```sql
SELECT
    sender_id,
    COUNT(message_id) AS message_count
FROM
    messages
WHERE
    sent_date >= '2022-08-01' AND sent_date < '2022-09-01'
GROUP BY
    sender_id
ORDER BY
    message_count DESC
LIMIT 2;
```

#### 5.1.1. Code Breakdown
-   **`WHERE sent_date >= '2022-08-01' AND sent_date < '2022-09-01'`**: This clause filters for messages sent in August 2022.

> [!CAUTION]
> Using a date range (`>=` and `<`) is generally more performant and robust than using functions like `EXTRACT` or `MONTH`/`YEAR` on the `sent_date` column, especially if the column is indexed. It allows the database to use the index more effectively (this is known as being SARGable).

-   **`GROUP BY sender_id`**: This aggregates all messages sent by the same user.
-   **`COUNT(message_id)`**: This counts the number of messages for each user group.
-   **`ORDER BY message_count DESC`**: This sorts the users by their message count, from highest to lowest.
-   **`LIMIT 2`**: This clause takes only the first two rows from the sorted result.

> [!IMPORTANT]
> The `ORDER BY` clause is essential and must come before `LIMIT`. `LIMIT` simply takes the top N rows from the result set *after* it has been sorted.

### 5.2. Method 2: Using a Window Function
This is an alternative method using a Common Table Expression (CTE) and a window function, which can be useful for more complex ranking scenarios.

```sql
WITH ranked_senders AS (
    SELECT
        sender_id,
        COUNT(message_id) as message_count,
        ROW_NUMBER() OVER (ORDER BY COUNT(message_id) DESC) as row_num
    FROM
        messages
    WHERE
        sent_date >= '2022-08-01' AND sent_date < '2022-09-01'
    GROUP BY
        sender_id
)
SELECT
    sender_id,
    message_count
FROM
    ranked_senders
WHERE
    row_num <= 2;
```

#### 5.2.1. Code Breakdown
-   **`ranked_senders` CTE**:
    -   The query inside the CTE first performs the same `GROUP BY` and `COUNT` as the first method.
    -   `ROW_NUMBER() OVER (ORDER BY COUNT(message_id) DESC)`: It then uses a window function to assign a unique, sequential rank to each user based on their message count. The user with the highest count gets `row_num = 1`.

> [!NOTE]
> This approach separates the logic into two clear steps: first, aggregate the counts, then rank them. This can make complex queries easier to read and debug.

-   **Final `SELECT`**:
    -   The outer query simply selects from the CTE and filters for the rows `WHERE row_num <= 2`, effectively retrieving the top 2 users.

> [!WARNING]
> The problem assumes no ties. If ties were possible, the choice of window function would matter:
> - `ROW_NUMBER()`: Would arbitrarily assign ranks 1 and 2 to tied users, always returning exactly 2 rows.
> - `RANK()` or `DENSE_RANK()`: Would give tied users the same rank, potentially returning more than 2 rows if there's a tie for 2nd place. Given the assumption, `ROW_NUMBER()` is appropriate.
