# Top-Rated Reviews

## 1. Overview
> [!NOTE]
> This document analyzes a SQL query designed to answer the business question: **"Across all reviews, what is the total count of 'top-rated' reviews (defined as 4 or 5 stars), and what percentage of all reviews do these top-rated reviews represent?"**

## 2. Table Schema
The query references a single table, `reviews`. A plausible schema is as follows.

### 2.1. `reviews` Table
```sql
-- Stores a record for every review submitted for a business.
CREATE TABLE reviews (
    review_id     INT PRIMARY KEY,
    business_id   INT NOT NULL,           -- The ID of the business being reviewed
    user_id       INT NOT NULL,           -- The ID of the user who wrote the review
    review_stars  INT NOT NULL,           -- The star rating given (e.g., 1 to 5)
    review_date   DATE
);
```
> [TIP]
> An index on the `review_stars` column could slightly improve the performance of this query, as it is the primary column used for filtering within the aggregation.

## 3. Method 1: Conditional `SUM` and `COUNT`
This method uses conditional logic within aggregate functions to calculate the required metrics in a single pass.

### 3.1. SQL Query
```sql
SELECT
    -- Count the number of top-rated reviews by summing a flag (1 for top, 0 otherwise).
    SUM(CASE WHEN review_stars IN (4, 5) THEN 1 ELSE 0 END) AS business_num,

    -- Calculate the percentage of top-rated reviews.
    ROUND(
        100 *
        (
            SUM(CASE WHEN review_stars IN (4, 5) THEN 1 ELSE 0 END)::NUMERIC
            / COUNT(business_id)
        ),
        2
    ) AS top_business_pct
FROM
    reviews;
```

### 3.2. Explanation
This query calculates two summary metrics over the entire `reviews` table.
*   **`SUM(...) AS business_num`**: This is a conditional count. The `CASE` statement is evaluated for every row, returning `1` if `review_stars` is 4 or 5, and `0` otherwise. The `SUM()` function then adds these values, giving a total count of only the top-rated reviews.
> [!CAUTION]
> The column alias `business_num` is slightly misleading. The query does not count top-rated businesses; it counts the number of top-rated *reviews*.
*   **Percentage Calculation**:
    *   **Numerator**: `SUM(CASE ... END)` is the same conditional count of top-rated reviews.
    *   **Denominator**: `COUNT(business_id)` counts the total number of reviews in the table (assuming `business_id` is never `NULL`).
    *   **Division**: The ratio of top reviews to total reviews is calculated. The `::NUMERIC` cast is a PostgreSQL-specific syntax used to ensure floating-point division. In other SQL dialects, you might use `CAST(...)` or multiply by `1.0`.
    *   **`ROUND(100 * ..., 2)`**: The ratio is converted to a percentage and rounded to two decimal places.

## 4. Method 2: Using `AVG` for Percentage Calculation
A more concise and elegant way to calculate a percentage is to use the `AVG` function on a numeric flag.

### 4.1. SQL Query
```sql
SELECT
    SUM(CASE WHEN review_stars IN (4, 5) THEN 1 ELSE 0 END) AS business_num,
    ROUND(
        100.0 * AVG(CASE WHEN review_stars IN (4, 5) THEN 1.0 ELSE 0.0 END),
        2
    ) AS top_business_pct
FROM
    reviews;
```

### 4.2. Explanation
This method leverages a mathematical property of the `AVG` function to simplify the percentage calculation.
*   **`business_num`**: This calculation is identical to the first method.
*   **`top_business_pct`**:
    *   The `CASE` statement creates a numeric "flag" for each row: `1.0` for a top-rated review and `0.0` for any other.
    *   The `AVG()` function is then applied to this series of 1.0s and 0.0s.
    > [!IMPORTANT]
    > The key insight is that the average of a series of 1s and 0s is mathematically equivalent to the percentage of 1s in that series. For example, the average of `(1, 1, 1, 0, 0)` is `3 / 5 = 0.6`, which directly represents a 60% rate.
    *   The result is multiplied by `100.0` and rounded as before.

## 5. Method Comparison
> [!TIP]
> Both methods are highly performant as they only require a single pass over the data. The `AVG` method is often considered more concise and elegant by experienced SQL developers for calculating percentages. The choice between them is typically a matter of style and readability preference.
