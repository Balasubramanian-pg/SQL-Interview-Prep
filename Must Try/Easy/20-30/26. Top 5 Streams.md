# Unsold Product Groups

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to find all product groups located in the 'US' that have had no sales.

## 2. Data Model

### 2.1. `orders` Table
Contains transaction-level data.
| Column Name | Type |
|:------------|:-----|
| order_id    | int  |
| item_id     | int  |
| quantity    | int  |
| order_date  | date |

### 2.2. `catalog` Table
Contains product and item metadata.
| Column Name   | Type |
|:--------------|:-----|
| item_id       | int  |
| product_id    | int  |
| product_group | var  |
| location      | var  |

## 3. Core Logic: Finding What Doesn't Exist
The problem requires us to find `product_group`s from the `catalog` that have no corresponding sales records in the `orders` table. This is a classic "anti-join" pattern.

The logic must ensure that **no item** within a US-based product group has ever been sold.

> [!IMPORTANT]
> A `LEFT JOIN` from the `catalog` to the `orders` table is the key. This will keep all items from the catalog, and for those items that have never been sold, the columns from the `orders` table will be `NULL`. We can then aggregate by `product_group` and count the non-NULL orders to identify groups with zero sales.

## 4. Incremental Query Construction
We will build the query step-by-step.

### 4.1. Step 1: Join Catalog Items with Their Orders
First, we perform a `LEFT JOIN` from `catalog` to `orders`. We also filter for items in the 'US' location.

```sql
SELECT
    c.product_group,
    c.item_id AS catalog_item,
    o.order_id
FROM
    catalog c
LEFT JOIN
    orders o ON c.item_id = o.item_id
WHERE
    c.location = 'US';
```
**Intermediate Result:** This would produce a list of all US items. Items with sales will have an `order_id`, while unsold items will have `NULL` for `order_id`.

| product_group | catalog_item | order_id |
|:--------------|:-------------|:---------|
| A             | 46           | 1        |
| B             | 63           | 2        |
| D             | 53           | 5        |
| E (unsold)    | 99           | NULL     |

### 4.2. Step 2: Aggregate by Product Group and Count Orders
Now, we can group the results by `product_group` and count the number of orders associated with each group.

> [!TIP]
> `COUNT(o.order_id)` will only count rows where `order_id` is not `NULL`. This is exactly what we need to determine if a group has any sales.

```sql
SELECT
    c.product_group,
    COUNT(o.order_id) AS total_orders
FROM
    catalog c
LEFT JOIN
    orders o ON c.item_id = o.item_id
WHERE
    c.location = 'US'
GROUP BY
    c.product_group;
```
**Intermediate Result:**
| product_group | total_orders |
|:--------------|:-------------|
| A             | 1            |
| B             | 1            |
| D             | 1            |
| E (unsold)    | 0            |

### 4.3. Step 3: Filter for Groups with Zero Orders
The final step is to add a `HAVING` clause to the aggregation, keeping only the groups where the `total_orders` count is zero.

## 5. Final Solution
The complete query combines these steps efficiently.
```sql
SELECT
    c.product_group
FROM
    catalog c
LEFT JOIN
    orders o ON c.item_id = o.item_id
WHERE
    c.location = 'US'
GROUP BY
    c.product_group
-- Keep only the groups where the count of non-NULL order_ids is zero.
HAVING
    COUNT(o.order_id) = 0;
```

## 6. Analysis of an Alternative (Incorrect) Approach
An initial attempt might look like this:
```sql
-- This query is incorrect.
SELECT c.product_group
FROM orders o
LEFT JOIN catalog c on o.item_id = c.item_id
WHERE o.order_id IS NULL AND c.location = 'US';
```
> [!WARNING]
> This query is flawed for two main reasons:
> 1.  **Incorrect Join Direction**: A `LEFT JOIN` from `orders` to `catalog` will keep all orders. The condition `o.order_id IS NULL` can never be true, so this query will return nothing. The join must start from `catalog`.
> 2.  **Lack of Aggregation**: It doesn't group by `product_group`. It attempts to find individual *items* with no sales, not entire *groups* with no sales. It would fail to correctly identify a group where some items were sold but others were not.
