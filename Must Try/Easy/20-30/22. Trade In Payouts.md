# First-Week User Purchase Rate

## 1. The Business Question
The objective of this query is to answer a key user activation metric:

**"What percentage of newly signed-up users make at least one purchase within their first week (7 days) of signing up?"**

> [!IMPORTANT]
> The metric is binary for each user: either they made at least one purchase in the first 7 days, or they did not. A user making 10 purchases in their first week is counted the same as a user making one purchase.

## 2. Assumed Table Schema
The query joins two tables, `signups` and `user_purchases`. A plausible schema for these tables that supports the query logic is detailed below.

```sql
-- Table: signups
-- Stores a record for every user who signs up for the service.
CREATE TABLE signups (
    user_id     INT PRIMARY KEY,
    signup_date DATE NOT NULL
);

-- Table: user_purchases
-- Stores a record for every purchase made by a user.
CREATE TABLE user_purchases (
    purchase_id  INT PRIMARY KEY,
    user_id      INT NOT NULL,
    purchase_date DATE NOT NULL,
    product_id   INT,
    FOREIGN KEY (user_id) REFERENCES signups(user_id)
);
```

> [!NOTE]
> The relationship between these two tables is one-to-many. A single `user_id` from the `signups` table can be associated with zero, one, or many records in the `user_purchases` table.

> [!TIP]
> For performance on large datasets, it would be beneficial to have indexes on `signups(signup_date)` and `user_purchases(user_id, purchase_date)`.

## 3. Solution Approaches

### 3.1. Method 1: `LEFT JOIN` with a Complex `WHERE` Clause
This method uses a clever but non-obvious `WHERE` clause to filter the joined data before counting.

```sql
-- Step 1: Count total signups and users who purchased in the first week.
WITH user_count_tbl AS (
    SELECT
        COUNT(DISTINCT up.user_id) AS total_purchase_users,
        COUNT(DISTINCT s.user_id) AS total_signup_users
    FROM
        signups AS s
    LEFT OUTER JOIN
        user_purchases AS up ON s.user_id = up.user_id
    WHERE
        up.purchase_date IS NULL
        OR (up.purchase_date BETWEEN s.signup_date AND (s.signup_date + INTERVAL '7 day'))
)
-- Step 2: Calculate the final percentage.
SELECT
    ROUND(
        100.0 * total_purchase_users / total_signup_users,
        2
    ) AS single_purchase_pct
FROM
    user_count_tbl;
```

#### 3.1.1. Explanation

1.  **The `LEFT JOIN`**:
    -   A `LEFT OUTER JOIN` is used from `signups` to `user_purchases`. This is essential because it guarantees that **every user who signed up is included** in the initial result set, even if they have never made a purchase. For such users, the columns from the `user_purchases` table (`up`) will be `NULL`.

2.  **The `WHERE` Clause**:
    -   This is the trickiest part of the query. It filters the joined rows, keeping only two specific types of records:
        -   `up.purchase_date IS NULL`: This condition keeps all users who **never made a purchase**.
        -   `OR (up.purchase_date BETWEEN ...)`: This condition keeps records for purchases that occurred **within the first 7 days**.
    -   Crucially, this `WHERE` clause filters out any purchases that happened *after* the 7-day window.

> [!WARNING]
> This `WHERE` clause logic is powerful but can be difficult to interpret at first glance. It simultaneously defines the valid time window for purchases while also ensuring non-purchasing users are not accidentally filtered out.

3.  **The `COUNT` Functions**:
    -   `COUNT(DISTINCT s.user_id)`: This correctly counts **all signed-up users** because the `WHERE` clause was carefully crafted to keep every original signup record. This is our denominator.
    -   `COUNT(DISTINCT up.user_id)`: This counts unique users from the purchases table. The `COUNT()` function ignores `NULL` values. Therefore, this only counts users who had a non-`NULL` `up.user_id` that was kept by the `WHERE` clauseâ€”meaning they made a purchase **within the first week**. This is our numerator.

> [!TIP]
> The fact that `COUNT(column_name)` ignores `NULL`s is a fundamental behavior in SQL that this query leverages to separate the numerator from the denominator in a single step.

### 3.2. Method 2: Conditional Aggregation (Recommended)
A more common and often more intuitive way to solve this is to use conditional aggregation, which avoids the complex `WHERE` clause.

> [!NOTE]
> Conditional aggregation is a powerful technique where you use a `CASE` statement inside an aggregate function (like `SUM`, `COUNT`, `MAX`, or `AVG`) to perform calculations on a subset of your data.

```sql
WITH user_purchase_status AS (
    -- For each user, determine if they made a purchase in their first week.
    SELECT
        s.user_id,
        MAX(
            CASE
                WHEN up.purchase_date <= s.signup_date + INTERVAL '7 day' THEN 1
                ELSE 0
            END
        ) AS made_first_week_purchase
    FROM
        signups AS s
    LEFT JOIN
        user_purchases AS up ON s.user_id = up.user_id
    GROUP BY
        s.user_id
)
-- Calculate the average of the 0/1 flag to get the percentage.
SELECT
    ROUND(100.0 * AVG(made_first_week_purchase), 2) AS single_purchase_pct
FROM
    user_purchase_status;
```

#### 3.2.1. Explanation

1.  **The `user_purchase_status` CTE**:
    -   This CTE creates a simple flag for every single user who signed up.
    -   The `GROUP BY s.user_id` ensures we get one row of output for each user.
    -   The `MAX(CASE ... END)` is the conditional aggregation. It checks every purchase for a user. If *any* purchase falls within the 7-day window, the `CASE` returns a `1`. The `MAX()` function ensures that if a user has at least one `1`, their final flag will be `1`. Otherwise, it will be `0`.

2.  **The Final `SELECT` Statement**:
    -   This step uses a common SQL trick. The average of a column containing only `1`s and `0`s is mathematically equivalent to the percentage of `1`s.
    -   `AVG(made_first_week_purchase)` elegantly calculates the ratio of users who purchased in the first week to the total number of users.

> [!IMPORTANT]
> Calculating `AVG()` on a binary (0/1) flag is a standard and highly efficient pattern for finding a percentage or rate. For example, `AVG(1, 1, 0, 0)` is `(1+1+0+0)/4 = 0.5`, or 50%.

## 4. Comparison of Methods
-   **Method 1 (`LEFT JOIN` with `WHERE`)**: Clever and concise, but the logic in the `WHERE` clause can be difficult to reason about and prone to error if modified.
-   **Method 2 (Conditional Aggregation)**: Generally preferred for being more explicit and readable. The logic is broken down into clear steps: first, flag each user, then aggregate the flags. This approach is often easier to debug and maintain.
