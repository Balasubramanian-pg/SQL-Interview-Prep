# Return on Ad Spend (ROAS) by Advertiser

## 1. The Business Question
The objective of this query is to measure the effectiveness of advertising efforts on a per-advertiser basis. The specific business question is:

**"Calculate the Return on Ad Spend (ROAS) for each advertiser. The ROAS should be calculated as the sum of revenue divided by the sum of spend for each advertiser. Round the ROAS to two decimal places and order the results by `advertiser_id`."**

> [!IMPORTANT]
> Return on Ad Spend (ROAS) is a key marketing metric used to evaluate the profitability of advertising campaigns. It is calculated with the formula: `ROAS = Total Revenue / Total Spend`. A ROAS of 3.0, for example, means that for every $1 spent on advertising, $3 in revenue was generated.

## 2. Assumed Table Schema
The query references a single table, `ad_campaigns`, which contains performance data for individual campaigns.

| Column Name   | Data Type     | Description                                                 |
| ------------- | ------------- | ----------------------------------------------------------- |
| campaign_id   | INTEGER       | Unique identifier for each ad campaign.                     |
| advertiser_id | INTEGER       | Identifier for the advertiser running the campaign.         |
| spend         | DECIMAL(10,2) | Amount spent on the campaign.                               |
| revenue       | DECIMAL(10,2) | Revenue generated from the campaign.                        |

> [!TIP]
> For this type of aggregation query, performance can be improved by having an index on the column used for grouping, which is `advertiser_id` in this case.
>
> `CREATE INDEX idx_ad_campaigns_advertiser ON ad_campaigns (advertiser_id);`

## 3. Solution Approaches

### 3.1. Method 1: Direct Aggregation
This is the most direct and common approach for this type of problem. It performs the aggregation and calculation in a single query block.

```sql
SELECT
    advertiser_id,
    ROUND(SUM(revenue) / SUM(spend), 2) AS roas
FROM
    ad_campaigns
GROUP BY
    advertiser_id
ORDER BY
    advertiser_id;
```

#### 3.1.1. Explanation

1.  **`GROUP BY advertiser_id`**: This clause is the foundation of the query. It groups all rows belonging to the same `advertiser_id` together, so that aggregate functions like `SUM()` will operate on each advertiser's data independently.

2.  **`SUM(revenue)` and `SUM(spend)`**: For each advertiser group, these functions calculate the total revenue and total spend across all of their campaigns.

3.  **`SUM(revenue) / SUM(spend)`**: This performs the core ROAS calculation.

> [!NOTE]
> It is crucial to use `SUM(revenue) / SUM(spend)` and not `AVG(revenue / spend)`. The latter would calculate the ROAS for each individual campaign and then average those ratios, which would not give a true picture of the overall return and could be skewed by small campaigns with high or low ROAS.

4.  **`ROUND(..., 2) AS roas`**: This formats the final result by rounding it to two decimal places for clean, readable output.

> [!CAUTION]
> This query can fail with a "division by zero" error if any advertiser has a `SUM(spend)` of 0. A more robust query would use `NULLIF(SUM(spend), 0)` to gracefully handle this edge case by returning `NULL` for the ROAS.

### 3.2. Method 2: Using a Common Table Expression (CTE)
This approach breaks the logic into two steps: first, aggregating the totals, and second, calculating the ROAS. This can make the query more readable and modular, especially if the logic becomes more complex.

```sql
WITH advertiser_totals AS (
    -- Step 1: Calculate total revenue and spend for each advertiser.
    SELECT
        advertiser_id,
        SUM(revenue) AS total_revenue,
        SUM(spend) AS total_spend
    FROM
        ad_campaigns
    GROUP BY
        advertiser_id
)
-- Step 2: Calculate ROAS using the aggregated totals from the CTE.
SELECT
    advertiser_id,
    ROUND(total_revenue / total_spend, 2) AS roas
FROM
    advertiser_totals
ORDER BY
    advertiser_id;
```

#### 3.2.1. Explanation

1.  **The `advertiser_totals` CTE**:
    -   This Common Table Expression (CTE) has a single purpose: to aggregate the total revenue and total spend for each advertiser.
    -   The logic inside the CTE is a simple `GROUP BY` query. The result is a temporary, intermediate table that contains one row for each `advertiser_id` with their `total_revenue` and `total_spend`.

> [!TIP]
> Using CTEs is an excellent practice for improving code readability. It allows you to separate logical steps, making the query self-documenting and easier to debug. You can test the CTE's query by itself to ensure the intermediate results are correct.

2.  **The Final `SELECT` Statement**:
    -   This query is much simpler and more declarative because the heavy lifting of aggregation was already done in the CTE.
    -   It reads directly from the `advertiser_totals` temporary table and performs the final ROAS calculation (`total_revenue / total_spend`) on the pre-aggregated values.

## 4. Comparison of Methods
-   **Method 1 (Direct Aggregation)**: Quick, concise, and perfectly suitable for a straightforward aggregation like this.
-   **Method 2 (CTE)**: Offers superior readability and modularity. While it might seem verbose for this simple problem, it provides a much cleaner structure for more complex queries where you might need to reuse the aggregated totals for multiple different calculations.

> [!IMPORTANT]
> For this specific problem, the performance of both methods will likely be identical, as any modern database optimizer will generate the same execution plan. The choice between them is primarily a matter of coding style and the anticipated future complexity of the query.
