# Top Cities by Trade Volume

## 1. Problem Statement

### 1.1. Objective
Assume you're given tables containing completed trade orders and user details in a Robinhood trading system.

Write a query to retrieve the **top three cities** that have the highest number of completed trade orders, listed in descending order. Output the city name and the corresponding number of completed trade orders.

> [!IMPORTANT]
> A key constraint is to only count trades with a `status` of **'Completed'**. Any 'Cancelled' or other status trades must be excluded from the count.

### 1.2. Input Tables

#### 1.2.1. `trades` Table:
|Column Name|Type|
|---|---|
|order_id|integer|
|user_id|integer|
|quantity|integer|
|status|string ('Completed', 'Cancelled')|
|date|timestamp|

#### 1.2.2. `users` Table:
|Column Name|Type|
|---|---|
|user_id|integer|
|city|string|
|email|string|
|signup_date|datetime|

> [!NOTE]
> The two tables are linked by the `user_id` column. This relationship is essential for mapping a trade to the city where the user is located.

### 1.3. Example

#### 1.3.1. Example Input Data:
`trades` table:
|order_id|user_id|status|
|---|---|---|
|100101|111|Cancelled|
|100102|111|Completed|
|100259|148|Completed|
|100264|148|Completed|
|100305|300|Completed|
|100400|178|Completed|
|100565|265|Completed|

`users` table:
|user_id|city|
|---|---|
|111|San Francisco|
|148|Boston|
|178|San Francisco|
|265|Denver|
|300|San Francisco|

#### 1.3.2. Example Output:
|city|total_orders|
|---|---|
|San Francisco|3|
|Boston|2|
|Denver|1|

#### 1.3.3. Explanation
After filtering for only 'Completed' trades:
-   **San Francisco**: Has 3 completed orders (from users 111, 178, and 300).
-   **Boston**: Has 2 completed orders (both from user 148).
-   **Denver**: Has 1 completed order (from user 265).
These are the top three cities, ordered by their total number of completed orders.

## 2. Conceptual Approach
To solve this problem, we need to combine data from two tables, filter it, aggregate it, and then select the top results.

1.  **Join Tables**: Combine the `trades` and `users` tables using `user_id` to associate each trade with a city.
2.  **Filter for Completed Trades**: Isolate only the rows where the trade `status` is 'Completed'.
3.  **Group by City**: Group the filtered rows by `city` to prepare for counting.
4.  **Count Orders**: For each city group, count the number of orders.
5.  **Order by Count**: Sort the cities in descending order based on their total order count.
6.  **Limit to Top 3**: Select only the top three rows from the sorted result.

> [!TIP]
> Using clear aliases for your tables (e.g., `trades AS t`, `users AS u`) is a best practice that makes your `JOIN` and `SELECT` clauses much easier to read and debug.

## 3. SQL Solution

```sql
SELECT
    u.city,
    COUNT(t.order_id) AS total_orders
FROM trades AS t
JOIN users AS u
  ON t.user_id = u.user_id
WHERE
    t.status = 'Completed'
GROUP BY
    u.city
ORDER BY
    total_orders DESC
LIMIT 3;
```

## 4. Code Breakdown

### 4.1. The `JOIN` Clause
-   `FROM trades AS t JOIN users AS u ON t.user_id = u.user_id`: This line combines the two tables.
-   An `INNER JOIN` (the default `JOIN` type) is used here. This is appropriate because we are only interested in trades made by users for whom we have city information. Any trades from users not present in the `users` table would be irrelevant and are correctly excluded.

> [!NOTE]
> To optimize this join on large tables, ensure that the `user_id` column is indexed in both the `trades` and `users` tables.

### 4.2. The `WHERE` Clause
-   `WHERE t.status = 'Completed'`: This is a crucial filtering step that happens *before* any grouping or counting. It ensures that our aggregation is performed only on the subset of data we care about.

### 4.3. The `GROUP BY` Clause
-   `GROUP BY u.city`: This clause aggregates all the filtered rows into "buckets," with one bucket for each unique city. All subsequent aggregate functions (like `COUNT()`) will operate on these buckets.

### 4.4. The `SELECT` and `COUNT`
-   `COUNT(t.order_id) AS total_orders`: For each city group, this function counts the number of orders. Using `COUNT(t.order_id)` is slightly more explicit than `COUNT(*)` as it signifies we are counting trade entities.

### 4.5. The `ORDER BY` and `LIMIT` Clauses
-   `ORDER BY total_orders DESC`: This sorts the aggregated results, placing the cities with the highest counts at the top.

> [!IMPORTANT]
> The `ORDER BY` clause is essential and must come before the `LIMIT` clause. `LIMIT` operates on the final, sorted result set to select the top N rows.

-   `LIMIT 3`: This final clause restricts the output to only the top three rows from the sorted list.

> [!CAUTION]
> The syntax for limiting results can vary by SQL dialect. `LIMIT 3` is used in PostgreSQL and MySQL. In SQL Server, the equivalent would be `SELECT TOP 3 ...`.
