# SQL Analysis: App Click-Through Rate (CTR)

## 1. Problem Statement

### 1.1. Objective
Assume you have an events table on Facebook app analytics. Write a query to calculate the click-through rate (CTR) for each app in 2022 and round the results to 2 decimal places.

### 1.2. Definition and Note
-   Percentage of click-through rate (CTR) = `100.0 * Number of clicks / Number of impressions`

> [!IMPORTANT]
> To avoid integer division, it is crucial to multiply the ratio by a floating-point number like `100.0`, not the integer `100`.

## 2. Input Table: `events`

### 2.1. Schema

|Column Name|Type|
|---|---|
|app_id|integer|
|event_type|string|
|timestamp|datetime|

### 2.2. Example Input

|app_id|event_type|timestamp|
|---|---|---|
|123|impression|07/18/2022 11:36:12|
|123|impression|07/18/2022 11:37:12|
|123|click|07/18/2022 11:37:42|
|234|impression|07/18/2022 14:15:12|
|234|click|07/18/2022 14:16:12|

## 3. Example Output & Explanation

### 3.1. Example Output

|app_id|ctr|
|---|---|
|123|50.00|
|234|100.00|

### 3.2. Explanation
For App `123`, the click-through rate (CTR) is 50.00%. This is calculated because out of the 2 impressions it received, it got 1 click.

The calculation is: `(1 click / 2 impressions) * 100.0 = 50.00%`.

## 4. Conceptual Approach
To calculate the CTR for each app, we need to aggregate the number of clicks and impressions separately for each `app_id` and then apply the CTR formula.

1.  **Filter by Year**: The analysis is restricted to the year 2022, so we must first filter the `events` table by the `timestamp`.
2.  **Group by App**: Since we need a CTR for *each* app, we will group the filtered data by `app_id`.
3.  **Conditional Aggregation**: For each app group, we need to count the total number of 'click' events and 'impression' events. This can be done efficiently using `SUM` with a `CASE` statement.
4.  **Calculate the Rate**: Apply the CTR formula to the aggregated counts.
5.  **Handle Division by Zero**: A crucial edge case is when an app has zero impressions. Dividing by zero would cause an error. We must handle this gracefully.

> [!TIP]
> The most effective way to solve this is with **conditional aggregation**. This pattern uses `SUM(CASE WHEN ...)` to count different categories of data within a single `GROUP BY` operation, avoiding the need for multiple subqueries or joins.

## 5. SQL Solution (Robust)
This solution uses `NULLIF` to prevent division-by-zero errors, which is the most robust approach.

```sql
SELECT
    app_id,
    ROUND(
        100.0 *
        SUM(CASE WHEN event_type = 'click' THEN 1 ELSE 0 END) /
        NULLIF(SUM(CASE WHEN event_type = 'impression' THEN 1 ELSE 0 END), 0),
    2) AS ctr
FROM
    events
WHERE
    EXTRACT(YEAR FROM timestamp) = 2022
GROUP BY
    app_id;
```

## 6. Code Breakdown

### 6.1. Filtering and Grouping
-   `WHERE EXTRACT(YEAR FROM timestamp) = 2022`: This line filters the dataset to include only events from the year 2022.
-   `GROUP BY app_id`: This aggregates the rows for each `app_id` so we can perform calculations like `SUM()` on a per-app basis.

> [!NOTE]
> The function to extract the year from a timestamp can vary depending on the SQL dialect.
> - **PostgreSQL**: `EXTRACT(YEAR FROM timestamp)`
> - **MySQL/SQL Server**: `YEAR(timestamp)`
> - **SQLite**: `STRFTIME('%Y', timestamp)`

### 6.2. Numerator: Counting Clicks
-   `SUM(CASE WHEN event_type = 'click' THEN 1 ELSE 0 END)`: This is the conditional aggregation for counting clicks. For each row in a group, the `CASE` statement returns `1` if the `event_type` is 'click' and `0` otherwise. The `SUM()` then adds these up to get the total click count for that app.

### 6.3. Denominator: Counting Impressions
-   `SUM(CASE WHEN event_type = 'impression' THEN 1 ELSE 0 END)`: This follows the same logic to get the total impression count for the app.

### 6.4. Handling Division by Zero
-   `NULLIF(..., 0)`: This is a critical function for preventing errors. `NULLIF(value, value_to_replace)` returns `NULL` if the two arguments are equal; otherwise, it returns the first argument.
-   By wrapping the denominator (`SUM(...)` for impressions) in `NULLIF(..., 0)`, we ensure that if an app has 0 impressions, the denominator becomes `NULL` instead of `0`. In SQL, any division involving `NULL` results in `NULL`, gracefully avoiding a "division by zero" error.

> [!WARNING]
> Forgetting to handle potential division by zero is a common mistake in CTR calculations. A query that errors out is unusable. The `NULLIF` approach is a clean and standard way to make your query robust.

### 6.5. Final Calculation
-   `100.0 * ... / ...`: As noted, multiplying by `100.0` ensures the result is a floating-point number.
-   `ROUND(..., 2)`: This rounds the final percentage to two decimal places as required.

## 7. Alternative Solution (Using `HAVING`)
An alternative way to avoid division-by-zero errors is to explicitly exclude any apps that have zero impressions.

```sql
SELECT
    app_id,
    ROUND(
        100.0 *
        SUM(CASE WHEN event_type = 'click' THEN 1 ELSE 0 END) /
        SUM(CASE WHEN event_type = 'impression' THEN 1 ELSE 0 END),
    2) AS ctr
FROM
    events
WHERE
    EXTRACT(YEAR FROM timestamp) = 2022
GROUP BY
    app_id
HAVING
    SUM(CASE WHEN event_type = 'impression' THEN 1 ELSE 0 END) > 0;
```
> [!CAUTION]
> This `HAVING` clause approach is functionally different from the `NULLIF` solution. This query will **completely omit** any apps that had 0 impressions from the final result set. The `NULLIF` solution will **include** those apps but show their `ctr` as `NULL`. The correct choice depends on the specific business requirement.
