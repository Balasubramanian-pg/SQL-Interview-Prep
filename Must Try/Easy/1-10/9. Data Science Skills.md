# Finding Candidates with Required Skills

## 1. Problem Statement

### 1.1. Objective
Given a table of candidates and their skills, you're tasked with finding the candidates best suited for an open Data Science job. You want to find candidates who are proficient in Python, Tableau, and PostgreSQL.

Write a query to list the candidates who possess **all** of the required skills for the job. Sort the output by candidate ID in ascending order.

> [!IMPORTANT]
> The core requirement is that a candidate must possess *all three* specified skills (Python, Tableau, AND PostgreSQL), not just one or some of them.

### 1.2. Assumption
-   There are no duplicates in the `candidates` table (e.g., the same candidate and skill listed twice).

> [!NOTE]
> This assumption simplifies the query slightly, but the chosen solution is robust enough to handle such duplicates correctly if they were present.

## 2. Input Table: `candidates`

### 2.1. Schema
|**Column Name**|**Type**|
|---|---|
|candidate_id|integer|
|skill|varchar|

### 2.2. Example Input
|**candidate_id**|**skill**|
|---|---|
|123|Python|
|123|Tableau|
|123|PostgreSQL|
|234|R|
|234|PowerBI|
|234|SQL Server|
|345|Python|
|345|Tableau|

> [!TIP]
> Notice how the data is structured in a "long" format, where each skill for a candidate is a separate row. This is a common and flexible way to store entity-attribute data.

## 3. Example Output & Explanation

### 3.1. Example Output
|**candidate_id**|
|---|
|123|

### 3.2. Explanation
Candidate `123` is the only one included in the output because they possess all three required skills: Python, Tableau, and PostgreSQL. Candidate `345` has Python and Tableau but is missing PostgreSQL, so they are excluded.

## 4. Conceptual Approach
The problem requires us to find candidates who match a set of criteria. A robust way to solve this in SQL is to group all the skills for each candidate and then check if the size of their relevant skill set matches our requirement.

1.  **Filter for Relevant Skills**: First, reduce the dataset to only include rows that contain one of our three target skills ('Python', 'Tableau', 'PostgreSQL').
2.  **Group by Candidate**: Group the filtered rows by `candidate_id`. This creates a "bucket" for each candidate containing all their relevant skills.
3.  **Count the Skills per Candidate**: For each candidate's bucket, count the number of distinct skills.
4.  **Filter by Count**: Keep only the candidates whose distinct skill count is exactly 3. This means they have all the skills we are looking for.
5.  **Sort the Results**: Order the final list of candidate IDs in ascending order.

> [!NOTE]
> The key insight for this problem is to use `GROUP BY` to collect all skills for a single candidate and then `HAVING` to apply a condition to that collected group of skills.

## 5. SQL Solution
To find the candidates with all the required skills, you can use a SQL query with a `GROUP BY` and `HAVING` clause.

```sql
SELECT
  candidate_id
FROM
  candidates
WHERE
  skill IN ('Python', 'Tableau', 'PostgreSQL')
GROUP BY
  candidate_id
HAVING
  COUNT(DISTINCT skill) = 3
ORDER BY
  candidate_id ASC;
```

## 6. Code Breakdown

### 6.1. The `WHERE` Clause
-   `WHERE skill IN ('Python', 'Tableau', 'PostgreSQL')`: This clause performs the initial filtering. It's an efficient way to keep only the rows that are relevant to our analysis, reducing the amount of data that needs to be processed by the `GROUP BY` clause.

### 6.2. The `GROUP BY` Clause
-   `GROUP BY candidate_id`: This clause is essential. It aggregates all the rows that passed the `WHERE` filter and groups them into a single summary row for each unique `candidate_id`.

### 6.3. The `HAVING` Clause
-   `HAVING COUNT(DISTINCT skill) = 3`: This is the core logic of the query.
    -   The `HAVING` clause is used because it filters the results *after* the `GROUP BY` aggregation has occurred. You cannot use `WHERE` to filter on an aggregate function like `COUNT()`.
    -   `COUNT(DISTINCT skill)` counts the number of unique skills within each candidate's group.
    -   `= 3`: This condition checks if the count of relevant skills is exactly three. If a candidate has all three, they are included in the final result.

> [!CAUTION]
> Using `COUNT(DISTINCT skill)` is a robust choice. If the source data accidentally contained a duplicate entry (e.g., candidate 123 had 'Python' listed twice), `COUNT(skill)` would incorrectly result in 4, but `COUNT(DISTINCT skill)` would correctly result in 3.

### 6.4. The `ORDER BY` Clause
-   `ORDER BY candidate_id ASC`: This final clause sorts the output by `candidate_id` in ascending order to meet the presentation requirements.

> [!TIP]
> This `GROUP BY`/`HAVING` pattern is far more scalable and efficient than other approaches, such as joining the table to itself three times (once for each skill). It requires only a single scan of the filtered data.
