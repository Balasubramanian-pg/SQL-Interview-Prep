# Days Between First and Last Posts

## 1. Problem Statement

### 1.1. Objective
Given a table of Facebook posts, for each user who posted at least twice in 2021, write a query to find the number of days between that userâ€™s first post of the year and last post of the year. Output the user ID and the number of days between their first and last posts.

> [!IMPORTANT]
> A key constraint is that the analysis must only include users who have posted **at least twice** in the year 2021. Users with a single post, or no posts in 2021, should be excluded from the final output.

### 1.2. Input Table: `posts`

|Column Name|Type|
|---|---|
|user_id|integer|
|post_id|integer|
|post_content|text|
|post_date|timestamp|

#### 1.2.1. Example Input:

|user_id|post_id|post_content|post_date|
|---|---|---|---|
|151652|599415|Need a hug|07/10/2021 12:00:00|
|661093|624356|Bed. Class 8-12...|07/29/2021 13:00:00|
|004239|784254|Happy 4th of July!|07/04/2021 11:00:00|
|661093|442560|Just going to cry...|07/08/2021 14:00:00|
|151652|111766|I'm so done with covid...|07/12/2021 19:00:00|

### 1.3. Example Output:

| user_id | days_between |
| ------- | ------------ |
| 151652  | 2            |
| 661093  | 21           |

## 2. Conceptual Approach
To solve this problem, we need to perform a series of filtering and aggregation steps on the `posts` table.

1.  **Filter by Year**: First, we must narrow down the dataset to include only posts made in the year 2021.
2.  **Group by User**: Since the calculation is on a per-user basis, we need to group the filtered data by `user_id`.
3.  **Filter by Post Count**: Within each user group, we must ensure the user has made at least two posts. This is a condition on an aggregated value, which is a perfect use case for the `HAVING` clause.
4.  **Find Date Boundaries**: For the remaining user groups, we need to find the earliest (`MIN`) and latest (`MAX`) `post_date`.
5.  **Calculate the Difference**: The final step is to calculate the difference in days between the `MAX` and `MIN` dates for each user.

> [!NOTE]
> The `post_date` column is a `timestamp`, but the problem asks for the difference in days. We will need to use date functions to extract or calculate this difference, and the specific function may vary between SQL dialects.

## 3. SQL Solutions

### 3.1. Method 1: Direct Aggregation with `HAVING`
This is the most direct and concise approach, performing all steps within a single query block.

#### 3.1.1. PostgreSQL Syntax

```sql
SELECT
    user_id,
    DATE_PART('day', MAX(post_date) - MIN(post_date)) AS days_between
FROM
    posts
WHERE
    EXTRACT(YEAR FROM post_date) = 2021
GROUP BY
    user_id
HAVING
    COUNT(post_id) >= 2;
```

#### 3.1.2. MySQL Syntax

```sql
SELECT
    user_id,
    DATEDIFF(MAX(post_date), MIN(post_date)) AS days_between
FROM
    posts
WHERE
    YEAR(post_date) = 2021
GROUP BY
    user_id
HAVING
    COUNT(post_id) >= 2;
```

#### 3.1.3. Explanation
-   The `WHERE` clause filters for posts in 2021.
-   The `GROUP BY` clause groups the data by `user_id`.
-   The `HAVING` clause filters these groups, keeping only those with two or more posts.
-   The `SELECT` clause then calculates the difference between the `MAX` and `MIN` dates for the remaining groups.

> [!CAUTION]
> Date and time functions are highly dependent on the SQL dialect. `DATEDIFF()` in MySQL and `DATE_PART()` in PostgreSQL accomplish the same goal here but have different syntax and argument orders. Always be aware of the specific database system you are using.

### 3.2. Method 2: Using a Common Table Expression (CTE)
This approach breaks the logic into two steps, which can be more readable and easier to maintain for complex queries.

#### 3.2.1. PostgreSQL Syntax
```sql
WITH user_post_dates AS (
    SELECT
        user_id,
        MIN(post_date) AS first_post_date,
        MAX(post_date) AS last_post_date
    FROM
        posts
    WHERE
        EXTRACT(YEAR FROM post_date) = 2021
    GROUP BY
        user_id
    HAVING
        COUNT(post_id) >= 2
)
SELECT
    user_id,
    DATE_PART('day', last_post_date - first_post_date) AS days_between
FROM
    user_post_dates;
```

> [!TIP]
> Using a CTE separates the logic of "finding the user cohort and their date boundaries" from the final "calculating the difference." This makes the query self-documenting and easier to debug, as you can run the CTE's query independently.

### 3.3. Method 3: Using Window Functions
This approach avoids an explicit `GROUP BY` by using window functions to append the required information to each row before a final filtering and de-duplication step.

#### 3.3.1. MySQL Syntax
```sql
WITH post_date_bounds AS (
    SELECT
        user_id,
        MIN(post_date) OVER (PARTITION BY user_id) AS first_post_date,
        MAX(post_date) OVER (PARTITION BY user_id) AS last_post_date,
        COUNT(*) OVER (PARTITION BY user_id) AS post_count
    FROM
        posts
    WHERE
        YEAR(post_date) = 2021
)
SELECT DISTINCT
    user_id,
    DATEDIFF(last_post_date, first_post_date) AS days_between
FROM
    post_date_bounds
WHERE
    post_count >= 2;
```

#### 3.3.2. Explanation
-   **`post_date_bounds` CTE**: This CTE uses window functions to perform calculations over partitions of data.
    -   `MIN/MAX(post_date) OVER (PARTITION BY user_id)`: For each row, this calculates the min/max `post_date` for that row's `user_id`. Every row for a given user will be annotated with the same `first_post_date` and `last_post_date`.
    -   `COUNT(*) OVER (PARTITION BY user_id)`: Similarly, this calculates the total post count for each user and stamps it on every one of their rows.

> [!WARNING]
> While powerful, this window function approach can be less performant for this specific problem. It calculates the `MIN`, `MAX`, and `COUNT` for every single row within a partition, which generates a lot of redundant data that must then be de-duplicated with `SELECT DISTINCT` in the final step. The `GROUP BY` method is typically more efficient here.

> [!IMPORTANT]
> The `SELECT DISTINCT` in the final query is absolutely necessary for the window function approach. Without it, you would get one output row for every post a user made in 2021, which is incorrect.
