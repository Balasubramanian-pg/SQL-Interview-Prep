# Disparity in Monthly Credit Card Issuance

## 1. Problem Statement

### 1.1. Objective
Your team at JPMorgan Chase is preparing to launch a new credit card. To gain insights into market performance, you're analyzing the volatility in the number of credit cards issued each month.

Write a query that outputs the name of each credit card and the difference (disparity) between the number of cards issued in its best month (highest issuance) and its worst month (lowest issuance). Arrange the results based on the largest disparity.

> [!IMPORTANT]
> The "difference" or "disparity" is a measure of volatility. It is calculated as `(Maximum Monthly Issuance) - (Minimum Monthly Issuance)` for each card.

### 1.2. Input Table: `monthly_cards_issued`

#### 1.2.1. Schema
|Column Name|Type|
|---|---|
|card_name|string|
|issued_amount|integer|
|issue_month|integer|
|issue_year|integer|

#### 1.2.2. Example Input
|card_name|issued_amount|issue_month|issue_year|
|---|---|---|---|
|Chase Freedom Flex|55000|1|2021|
|Chase Freedom Flex|60000|2|2021|
|Chase Freedom Flex|65000|3|2021|
|Chase Freedom Flex|70000|4|2021|
|Chase Sapphire Reserve|170000|1|2021|
|Chase Sapphire Reserve|175000|2|2021|
|Chase Sapphire Reserve|180000|3|2021|

### 1.3. Example Output & Explanation

#### 1.3.1. Example Output
|card_name|difference|
|---|---|
|Chase Freedom Flex|15000|
|Chase Sapphire Reserve|10000|

#### 1.3.2. Explanation
-   For **Chase Freedom Flex**, the best month had 70,000 cards issued, and the worst month had 55,000. The difference is `70,000 - 55,000 = 15,000`.
-   For **Chase Sapphire Reserve**, the best month had 180,000 cards issued, and the worst month had 170,000. The difference is `180,000 - 170,000 = 10,000`.

## 2. Conceptual Approach
The core of this problem is to find the maximum and minimum `issued_amount` for each distinct `card_name` and then calculate their difference.

1.  **Group by Card**: Since the calculation needs to be done on a per-card basis, we must group the data by `card_name`.
2.  **Find Max and Min**: For each card group, we need to find the single highest `issued_amount` and the single lowest `issued_amount` from all its monthly records.
3.  **Calculate the Difference**: Subtract the minimum value from the maximum value for each card.
4.  **Sort the Results**: Order the final output by the calculated difference in descending order to show the cards with the highest volatility first.

> [!NOTE]
> This is a straightforward aggregation problem. The `GROUP BY` clause is the key to performing calculations on distinct subsets of your data.

## 3. SQL Solutions

### 3.1. Method 1: Direct Aggregation with `GROUP BY` (Recommended)
This is the most direct, concise, and efficient way to solve this problem.

```sql
SELECT
  card_name,
  MAX(issued_amount) - MIN(issued_amount) AS difference
FROM
  monthly_cards_issued
GROUP BY
  card_name
ORDER BY
  difference DESC;
```

#### 3.1.1. Code Breakdown
-   **`GROUP BY card_name`**: This is the most important part of the query. It creates a group for each unique `card_name` (e.g., one group for all 'Chase Freedom Flex' rows, another for all 'Chase Sapphire Reserve' rows).
-   **`MAX(issued_amount)` and `MIN(issued_amount)`**: These aggregate functions are applied to each group created by the `GROUP BY` clause. They find the single highest and single lowest `issued_amount` within that group.
-   **`... AS difference`**: The result of the subtraction is aliased as `difference`.
-   **`ORDER BY difference DESC`**: This sorts the final result set based on the calculated `difference`, from largest to smallest.

> [!TIP]
> This single-query approach is highly efficient because the database can calculate the `MAX`, `MIN`, and the difference in a single pass over the grouped data.

### 3.2. Method 2: Using Window Functions
This is an alternative method that achieves the same result. While more verbose for this specific problem, it can be useful if you need to retain the original row-level detail for other calculations.

```sql
WITH card_ranges AS (
  SELECT
    card_name,
    issued_amount,
    MAX(issued_amount) OVER (PARTITION BY card_name) AS max_issued,
    MIN(issued_amount) OVER (PARTITION BY card_name) AS min_issued
  FROM
    monthly_cards_issued
)
SELECT DISTINCT
  card_name,
  max_issued - min_issued AS difference
FROM
  card_ranges
ORDER BY
  difference DESC;
```

#### 3.2.1. Code Breakdown
-   **`card_ranges` CTE**: This Common Table Expression uses window functions to find the max and min values.
    -   `MAX(...) OVER (PARTITION BY card_name)`: For each row, this function finds the maximum `issued_amount` within that row's `card_name` partition and "stamps" that value onto the row. Every row for 'Chase Freedom Flex' will have `70000` in the `max_issued` column.
    -   The `MIN(...)` function works similarly.
-   **Final `SELECT`**:
    -   The final query selects from the CTE. Since every row for a given card now has the same `max_issued` and `min_issued` values, we use `SELECT DISTINCT card_name` to collapse these rows into a single output row per card.
    -   The difference is then calculated and the results are ordered.

> [!WARNING]
> While window functions are extremely powerful, they can be less efficient for simple aggregations like this one. This approach calculates the max and min for *every single row* and then requires a `DISTINCT` operation to de-duplicate the results, which is more work than the simple `GROUP BY` method.

> [!IMPORTANT]
> The `GROUP BY` approach (Method 1) is the standard and preferred solution for this problem due to its simplicity, readability, and performance. The window function approach is a good alternative to be aware of for more complex scenarios where you might need both aggregated and row-level data.
