# Game Retention Rate Analysis

## 1. Objective
> [!NOTE]
> This document explains how to write a SQL query to calculate the number of players who install a game on a given date and the corresponding Day 1 retention rate.

## 2. Data Model

### 2.1. `Activity` Table
Contains records of player activity, including the date of the event.
| player_id | device_id | event_date | games_played |
|:----------|:----------|:-----------|:-------------|
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-03-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-01 | 0            |
| 3         | 4         | 2016-07-03 | 5            |

## 3. Core Concepts
*   **Install Date**: A player's first-ever `event_date` in the `Activity` table.
*   **Day 1 Retention**: The percentage of players who had an `event_date` exactly one day after their install date.

> [!IMPORTANT]
> A player is only considered "retained on Day 1" if they log in on `install_date + 1`. A login on `install_date + 2` or later does not count towards Day 1 retention.

## 4. Incremental Query Construction
We will use a Common Table Expression (CTE) to first prepare the data by adding necessary context to each row, and then aggregate the results.

### 4.1. Step 1: Augment Activity Data with Window Functions
For each activity record, we need to know three things:
1.  Is this the player's first-ever login? (`ROW_NUMBER`)
2.  What is the player's install date? (`MIN`)
3.  What was the date of their next login? (`LEAD`)

A CTE is the perfect tool to calculate all of this at once.

> [!TIP]
> Using window functions like `ROW_NUMBER()`, `MIN() OVER (...)`, and `LEAD()` is far more efficient than using self-joins, as it avoids multiple scans of the table.

```sql
-- This query will become our CTE
SELECT
    player_id,
    event_date,
    -- 1. Rank each player's logins chronologically. The first login will have rnk = 1.
    ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS rnk,
    -- 2. Find the very first login date for the player (the install date).
    MIN(event_date) OVER(PARTITION BY player_id) AS install_dt,
    -- 3. Find the date of the player's next login. It will be NULL for their last login.
    LEAD(event_date, 1) OVER(PARTITION BY player_id ORDER BY event_date) AS next_login_dt
FROM
    Activity;
```
**Intermediate Result (from the CTE):**
| player_id | event_date | rnk | install_dt | next_login_dt |
|:----------|:-----------|:----|:-----------|:--------------|
| 1         | 2016-03-01 | 1   | 2016-03-01 | 2016-03-02    |
| 1         | 2016-03-02 | 2   | 2016-03-01 | NULL          |
| 2         | 2017-06-25 | 1   | 2017-06-25 | NULL          |
| 3         | 2016-03-01 | 1   | 2016-03-01 | 2016-07-03    |
| 3         | 2016-07-03 | 2   | 2016-03-01 | NULL          |

### 4.2. Step 2: Isolate Install Events
Our calculations are based on the install date. From the CTE result above, we can see that all install events are marked with `rnk = 1`. We filter our dataset to keep only these rows.

```sql
...
FROM
    PlayerActivity -- Assumes the query from Step 1 is in a CTE named PlayerActivity
WHERE
    rnk = 1;
```
**Intermediate Result (after filtering for `rnk = 1`):**
| player_id | event_date | rnk | install_dt | next_login_dt |
|:----------|:-----------|:----|:-----------|:--------------|
| 1         | 2016-03-01 | 1   | 2016-03-01 | 2016-03-02    |
| 2         | 2017-06-25 | 1   | 2017-06-25 | NULL          |
| 3         | 2016-03-01 | 1   | 2016-03-01 | 2016-07-03    |

### 4.3. Step 3: Group by Install Date and Calculate Metrics
With the filtered data, we can now group by the `install_dt` and perform our final calculations:
*   **Installs**: A simple `COUNT()` of players for each install date.
*   **Day 1 Retention**: A conditional sum. We check if `next_login_dt` is exactly one day after `install_dt`. We sum up these "retained" players and divide by the total number of installs.

> [!CAUTION]
> When dividing integers, many SQL dialects perform integer division (e.g., `1 / 2 = 0`). To get a decimal result, you must cast one of the numbers to a decimal type or multiply by a float (e.g., `SUM(...) * 1.0 / COUNT(...)`). The query below uses the `ROUND` function which often handles this implicitly, but it's a critical point to be aware of.

## 5. Final Solution
The complete query combines all steps.

```sql
WITH PlayerActivity AS (
    -- Step 1: Augment data with install date and next login date for each player
    SELECT
        player_id,
        event_date,
        ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS rnk,
        MIN(event_date) OVER(PARTITION BY player_id) AS install_dt,
        LEAD(event_date, 1) OVER(PARTITION BY player_id ORDER BY event_date) AS next_login_dt
    FROM Activity
)
-- Step 3: Group by install date and calculate metrics
SELECT
    install_dt,
    -- Count the number of unique players who installed on this date
    COUNT(DISTINCT player_id) AS installs,
    -- Calculate Day 1 retention rate
    ROUND(
        SUM(CASE WHEN next_login_dt = install_dt + INTERVAL '1 day' THEN 1.0 ELSE 0 END) /
        COUNT(DISTINCT player_id),
        2
    ) AS Day1_retention
FROM
    PlayerActivity
-- Step 2: Filter to only include each player's first-ever event (the install)
WHERE
    rnk = 1
GROUP BY
    install_dt
ORDER BY
    install_dt;
```

## 6. Result Analysis

### 6.1. Final Output
| install_dt | installs | Day1_retention |
|:-----------|:---------|:---------------|
| 2016-03-01 | 2        | 0.50           |
| 2017-06-25 | 1        | 0.00           |

### 6.2. Explanation
*   **For `2016-03-01`**:
    *   **Installs**: Player 1 and Player 3 installed on this date. Total = `2`.
    *   **Retention**: Player 1's next login was `2016-03-02`, which is `install_dt + 1`. They are counted as retained. Player 3's next login was `2016-07-03`, which is not `install_dt + 1`. They are not counted.
    *   **Calculation**: `1 retained player / 2 total installs` = `0.50`.
*   **For `2017-06-25`**:
    *   **Installs**: Only Player 2 installed on this date. Total = `1`.
    *   **Retention**: Player 2 has no subsequent login (`next_login_dt` is `NULL`). They are not counted as retained.
    *   **Calculation**: `0 retained players / 1 total install` = `0.00`.
