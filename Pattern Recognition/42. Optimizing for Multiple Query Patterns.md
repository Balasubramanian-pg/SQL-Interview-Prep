**Pattern**: Designing schemas that support different query access patterns.

**Decomposition Strategy**:

1. Identify common query patterns
2. Analyze frequency and performance requirements
3. Create appropriate indexes or materialized views
4. Consider denormalization for performance

**Example**: "Optimize a product catalog for both category browsing and product search."

```SQL
-- Create indexes for category browsing
CREATE INDEX idx_products_category ON products(category_id, price);

-- Create indexes for product search
CREATE INDEX idx_products_name ON products USING GIN (to_tsvector('english', product_name));

-- Create a materialized view for common query pattern
CREATE MATERIALIZED VIEW category_summary AS
SELECT
    c.category_id,
    c.category_name,
    COUNT(p.product_id) AS product_count,
    MIN(p.price) AS min_price,
    MAX(p.price) AS max_price,
    AVG(p.price) AS avg_price
FROM categories c
JOIN products p ON c.category_id = p.category_id
GROUP BY c.category_id, c.category_name;

-- Create refresh schedule
CREATE OR REPLACE FUNCTION refresh_category_summary()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW category_summary;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule('0 3 * * *', 'SELECT refresh_category_summary()');
```