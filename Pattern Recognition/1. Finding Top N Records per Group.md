## Pattern: Finding the highest/lowest N values within each category.

**The TL;DR**: You got a bunch of stuff, it's all in different groups, and you just wanna snag the top (or bottom) few from each group. Simple, right? Like picking the best few snacks from each aisle at the grocery store. We don't need a whole philosophical debate about it.

> [!TIP]
> **Real-world example, because apparently, we need one for everything:**
> Imagine you're a manager (lol, me? a manager? *shudders*). You got departments, and you wanna know who's raking in the most cash in each one. Not the *overall* highest, but the highest *in each department*. It's about giving credit where it's due, in their respective lanes. Traditional, sensible stuff.

### My "Decomposition Strategy" (aka, how we get it done without breaking a sweat, mostly)

This is the ancient wisdom, distilled. It's how it's always been done, and frankly, it works, so why change it?

#### 1. Figure out your "who" and your "what."

*   **Groups (Categories)**: This is your `PARTITION BY` column. What are you separating your data by? In our employee example, it's `department`. Each department is its own little world. We're keeping things organized, as one should.
*   **Metric to Rank By**: This is your `ORDER BY` column. What are you measuring? For employees, it's `salary`. Are we looking for the high scores or the low scores? That'll be `DESC` (for highest) or `ASC` (for lowest). Simple math, people.

> [!TIP]
> **Think of it like this:**
> You're sorting your socks. `PARTITION BY` is your color categories (white, black, striped). `ORDER BY` is how clean they are (cleanest to dirtiest). You wouldn't mix your whites with your colors, would you? That's just chaos.

#### 2. Get your ranking game on with window functions.

This is where the SQL magic happens. Don't worry, it's not some TikTok dance trend. This is proper, old-school function stuff.

*   **`PARTITION BY <grouping_columns>`**: This is literally telling the database, "Hey, treat these groups separately. Reset the count for each one." Like, when you're ranking students, the top student in Math is different from the top student in English. Common sense.
*   **`ORDER BY <metric_column> [ASC|DESC]`**: Within each group, how do you want them sorted? Highest salary first? Lowest grades last? You decide.
*   **The Ranking Function Itself**:
    *   `RANK()`: Gives ranks, but if there's a tie, they share the rank, and the next rank skips a number. Kinda like if two people tie for first, the next person is third. Old-school, but sometimes a bit wonky if you need continuous numbers.
    *   `DENSE_RANK()`: Similar to `RANK()`, but no gaps. If two people tie for first, they both get 1, and the next person gets 2. This feels more logical to me, no shade to `RANK()`, but like, why skip numbers?
    *   `ROW_NUMBER()`: Gives each row a unique number, 1, 2, 3... Even if there's a tie, it just picks one arbitrarily. So if you need *exactly* N results, even if it means randomly leaving out someone who tied, this is your go-to. It's a bit cold, but efficient.
    
    > [!CAUTION]
    > **Seriously, pay attention to the ranking function choice!**
    > This ain't just some aesthetic preference. `RANK()`, `DENSE_RANK()`, and `ROW_NUMBER()` behave differently when there are ties. If you pick the wrong one, your "top N" might be more or less than N, or it might exclude someone unfairly. Don't be that person. Understand the implications. This isn't just about getting it done, it's about getting it done *right*.

    **Example (the `WITH ranked_employees` part):**
    ```sql
     WITH ranked_employees AS (
        SELECT
            name, department, salary,
            RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank -- This assigns the rank
        FROM employees
    )
    ```
    This basically makes a temporary table with everyone's rank in their department. Like, a temporary leaderboard, if you will.

#### 3. Filter out the noise (aka, keep only what you need).

Once everyone's got their rank, you just ditch the ones that didn't make the cut.

*   **`WHERE rank <= N`**: This is it. Just keep the top N (or bottom N) based on their shiny new rank.

    **Example (the final `SELECT`):**
    ```sql
     SELECT name, department, salary
     FROM ranked_employees
     WHERE rank <= 3; -- Only the top 3, please and thank you.
    ```

### Let's walk through the "Top 3 highest-paid employees in each department" example (again, because practice makes perfect, or something):

**My data (pretend this is a real spreadsheet, ugh):**

| name      | department | salary |
| :-------- | :--------- | :----- |
| Alice     | HR         | 60000  |
| Bob       | HR         | 75000  |
| Carol     | HR         | 70000  |
| David     | HR         | 75000  |
| Eve       | Engineering| 100000 |
| Frank     | Engineering| 90000  |
| Grace     | Engineering| 110000 |
| Heidi     | Engineering| 90000  |
| Ivan      | Sales      | 80000  |
| Judy      | Sales      | 85000  |
| Kelly     | Sales      | 80000  |
| Liam      | Sales      | 90000  |

**The SQL (the one we already saw, but repetition is key for learning, or so they say):**

```sql
 WITH ranked_employees AS (
    SELECT
        name, department, salary,
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
)
 SELECT name, department, salary
 FROM ranked_employees
 WHERE rank <= 3;
```

**What happens, step by step (don't blink, you might miss it):**

1.  **Original data:** We start with everything, just chilling.
2.  **`ranked_employees` CTE magic:**
    *   It sees `PARTITION BY department` and says, "Aight, HR is one group, Engineering is another, Sales is a third."
    *   Then, `ORDER BY salary DESC` makes sure everyone in *their own group* is sorted by highest salary first.
    *   `RANK()` then assigns numbers. Bob and David in HR both got 75000, so they're both `rank 1`. Carol at 70000 is `rank 3` (because `RANK()` skips 2). Alice is `rank 4`. Same drill for Engineering and Sales.

    > [!NOTE]
    > **After the CTE (it's like a sneak peek of the intermediate step):**
    > | name  | department | salary | rank |
    > | :---- | :--------- | :----- | :--- |
    > | Bob   | HR         | 75000  | 1    |
    > | David | HR         | 75000  | 1    |
    > | Carol | HR         | 70000  | 3    |
    > | Alice | HR         | 60000  | 4    |
    > | Grace | Engineering| 110000 | 1    |
    > | Eve   | Engineering| 100000 | 2    |
    > | Frank | Engineering| 90000  | 3    |
    > | Heidi | Engineering| 90000  | 3    |
    > | Liam  | Sales      | 90000  | 1    |
    > | Judy  | Sales      | 85000  | 2    |
    > | Ivan  | Sales      | 80000  | 3    |
    > | Kelly | Sales      | 80000  | 3    |
    > See how HR got a `rank 3` and then a `rank 4`? That's `RANK()` for you. It's a bit extra sometimes.

3.  **Final `SELECT` with `WHERE rank <= 3`**:
    *   Now, we just filter out everyone whose rank is higher than 3. Bye, Alice! Bye, Heidi (even though you tied, your rank was still 3 alongside Frank)! Bye, Kelly (same deal as Heidi)!

    > [!NOTE]
    > **Final, final results (the good stuff):**
    > | name  | department | salary |
    > | :---- | :--------- | :----- |
    > | Bob   | HR         | 75000  |
    > | David | HR         | 75000  |
    > | Carol | HR         | 70000  |
    > | Grace | Engineering| 110000 |
    > | Eve   | Engineering| 100000 |
    > | Frank | Engineering| 90000  |
    > | Heidi | Engineering| 90000  |
    > | Liam  | Sales      | 90000  |
    > | Judy  | Sales      | 85000  |
    > | Ivan  | Sales      | 80000  |
    > | Kelly | Sales      | 80000  |
    > Notice how we said "top 3," but for Engineering and Sales, we got *four* because of ties at rank 3? That's the `RANK()` life. If you wanted *exactly* three, you'd use `ROW_NUMBER()`, but you'd be leaving out one of those tied folks arbitrarily. Tough choices, but choices that matter.

### One Last Thing (Because my elders taught me to be thorough)

This pattern is a foundational piece of SQL. It's not some fly-by-night hack. Understanding it deeply will save you so much grief. It's practical, reliable, and frankly, just how things are done when you're dealing with categorized data. Don't overthink it, just use it. It works.
