## Pattern: Identifying the highest/lowest N values within each category.

**Core Idea**: You have data that can be grouped into categories, and within each category, you want to find the "best" or "worst" `N` items based on some metric.

**Real-world Analogy**:
Imagine you have a list of students with their scores in various subjects. You want to find the top 3 scoring students *in each subject*. Or, imagine you have sales data for different product categories, and you want to find the bottom 5 selling products *within each category*.

---

### Decomposition Strategy (The "How-to")

This strategy is highly effective because it breaks down a seemingly complex problem into manageable, logical steps, leveraging SQL's powerful window functions.

#### 1. Identify the groups and the metric to rank by

*   **Groups (Categories)**: These are the columns that define your independent sets. In the "top 3 highest-paid employees in each department" example, the `department` column defines the groups. Each department is a separate group.
*   **Metric to Rank By**: This is the column (or an expression derived from columns) that you want to order your data by *within each group*. In the example, `salary` is the metric, and we're interested in higher salaries.
*   **Ranking Order**: Do you want the highest values (descending order) or the lowest values (ascending order)? This determines `DESC` or `ASC` in your `ORDER BY` clause. For "highest-paid," it's `salary DESC`. For "lowest-paid," it would be `salary ASC`.

    **Example Breakdown**:
    *   **Groups**: `department`
    *   **Metric**: `salary`
    *   **Order**: `DESC` (because we want *highest* salaries)

#### 2. Apply window functions with `PARTITION BY` and `ORDER BY`

This is the heart of the solution. Window functions allow you to perform calculations across a set of table rows that are related to the current row.

*   **`PARTITION BY <grouping_columns>`**: This clause divides your dataset into the logical groups identified in step 1. The window function will then operate independently *within each partition*. It's like saying, "reset the ranking for every new department."
    *   **Example**: `PARTITION BY department` means the ranking will start fresh from 1 for Department A, then start from 1 again for Department B, and so on.

*   **`ORDER BY <metric_column> [ASC|DESC]`**: This clause specifies the order in which rows within each partition should be processed for the window function. This is where you define what "highest" or "lowest" means.
    *   **Example**: `ORDER BY salary DESC` means within each department, employees will be ordered from highest salary to lowest.

*   **Ranking Window Function**: This is the specific function that assigns a rank or number to each row within its partition based on the specified order. Several options exist, and the choice depends on how you want to handle ties:
    *   **`RANK()`**: Assigns a unique rank to each distinct value, but leaves gaps in the sequence if there are ties. If two employees tie for 1st, they both get rank 1, and the next employee gets rank 3 (skipping 2).
    *   **`DENSE_RANK()`**: Similar to `RANK()`, but does *not* leave gaps. If two employees tie for 1st, they both get rank 1, and the next employee gets rank 2. This is often preferred when you want a continuous sequence of ranks.
    *   **`ROW_NUMBER()`**: Assigns a unique, sequential number to each row within its partition, starting from 1. If there are ties in the ordering column, the assignment of `ROW_NUMBER` to tied rows is arbitrary (depends on internal order, not guaranteed). Use this when you need *exactly* N rows per group and don't care about tie-breaking order.
    *   **`NTILE(N)`**: Divides the rows in an ordered partition into a specified number of groups (N). It assigns each row a bucket number, starting from 1. Less commonly used for "top N" directly but useful for creating quantiles.

    **Example Choice**: `RANK()` is used in the provided example. This means if two employees in the same department have the exact same salary and are both in the top 3, they will both get the same rank (e.g., 2), and the next employee will get rank 4 (if `RANK()` is used) or rank 3 (if `DENSE_RANK()` is used). The choice of `RANK()` vs. `DENSE_RANK()` vs. `ROW_NUMBER()` is crucial and depends on business requirements regarding ties.

    **Putting it together (CTE `ranked_employees`)**:
    ```sql
    WITH ranked_employees AS (
        SELECT
            name,
            department,
            salary,
            -- This is the window function call
            RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
        FROM employees
    )
    ```
    This CTE (Common Table Expression) creates a temporary result set where each employee row now includes their rank within their respective department based on salary.

#### 3. Filter by rank `â‰¤ N`

Once you have the ranks, the final step is straightforward: select only those rows where the calculated rank is less than or equal to `N`.

*   **`WHERE rank <= N`**: This is a simple filtering clause applied to the results of the CTE. `N` is your target number (e.g., 3 for "top 3").

    **Example Filtering**:
    ```sql
    SELECT name, department, salary
    FROM ranked_employees
    WHERE rank <= 3;
    ```
    This query will return only those rows from `ranked_employees` where the `rank` column has a value of 1, 2, or 3.

---

### Detailed Explanation of the Example: "Find the top 3 highest-paid employees in each department."

**Schema**: `employees` table with columns: `name`, `department`, `salary`.

**Sample Data**:

| name      | department | salary |
| :-------- | :--------- | :----- |
| Alice     | HR         | 60000  |
| Bob       | HR         | 75000  |
| Carol     | HR         | 70000  |
| David     | HR         | 75000  |
| Eve       | Engineering| 100000 |
| Frank     | Engineering| 90000  |
| Grace     | Engineering| 110000 |
| Heidi     | Engineering| 90000  |
| Ivan      | Sales      | 80000  |
| Judy      | Sales      | 85000  |
| Kelly     | Sales      | 80000  |
| Liam      | Sales      | 90000  |

**SQL Query**:

```sql
WITH ranked_employees AS (
    SELECT
        name,
        department,
        salary,
        -- The window function assigns a rank to each employee within their department
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
)
SELECT name, department, salary
FROM ranked_employees
WHERE rank <= 3;
```

**Step-by-Step Execution Trace**:

1.  **`FROM employees`**: The query starts by looking at the entire `employees` table.

2.  **`SELECT name, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank`**:
    *   The `PARTITION BY department` clause tells the database to treat each `department` as a separate group for ranking.
        *   Group 1: HR employees
        *   Group 2: Engineering employees
        *   Group 3: Sales employees
    *   The `ORDER BY salary DESC` clause tells the database to sort employees within each of these groups by `salary` in descending order (highest salary first).
    *   The `RANK()` function then assigns a rank based on this ordering within each group.

    **Result of `ranked_employees` CTE**:

    | name  | department | salary | rank |
    | :---- | :--------- | :----- | :--- |
    | Bob   | HR         | 75000  | 1    |
    | David | HR         | 75000  | 1    |
    | Carol | HR         | 70000  | 3    |
    | Alice | HR         | 60000  | 4    |
    | Grace | Engineering| 110000 | 1    |
    | Eve   | Engineering| 100000 | 2    |
    | Frank | Engineering| 90000  | 3    |
    | Heidi | Engineering| 90000  | 3    |
    | Liam  | Sales      | 90000  | 1    |
    | Judy  | Sales      | 85000  | 2    |
    | Ivan  | Sales      | 80000  | 3    |
    | Kelly | Sales      | 80000  | 3    |

    *Notice how Bob and David in HR both get rank 1 because of their tied salary. Carol gets rank 3, skipping 2, because `RANK()` leaves gaps.*
    *Notice how Frank and Heidi in Engineering both get rank 3 because of their tied salary.*
    *Notice how Ivan and Kelly in Sales both get rank 3 because of their tied salary.*

3.  **`FROM ranked_employees WHERE rank <= 3`**:
    *   The outer query then selects from this temporary `ranked_employees` result.
    *   The `WHERE rank <= 3` clause filters out all rows where the `rank` is greater than 3.

    **Final Result**:

    | name  | department | salary |
    | :---- | :--------- | :----- |
    | Bob   | HR         | 75000  |
    | David | HR         | 75000  |
    | Carol | HR         | 70000  |
    | Grace | Engineering| 110000 |
    | Eve   | Engineering| 100000 |
    | Frank | Engineering| 90000  |
    | Heidi | Engineering| 90000  |
    | Liam  | Sales      | 90000  |
    | Judy  | Sales      | 85000  |
    | Ivan  | Sales      | 80000  |
    | Kelly | Sales      | 80000  |

    *Although we asked for "top 3", we got more than 3 employees for Engineering and Sales because of ties at rank 3 when using `RANK()`. If we used `ROW_NUMBER()`, we would get exactly 3, but the tie-breaking would be arbitrary.*

---

### Alternative Ranking Functions (and when to use them):

Let's re-run with other functions and see the difference.

**1. Using `DENSE_RANK()`**

```sql
WITH ranked_employees AS (
    SELECT
        name, department, salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
)
SELECT name, department, salary
FROM ranked_employees
WHERE rank <= 3;
```

**Result of `ranked_employees` CTE (with `DENSE_RANK`)**:

| name  | department | salary | rank |
| :---- | :--------- | :----- | :--- |
| Bob   | HR         | 75000  | 1    |
| David | HR         | 75000  | 1    |
| Carol | HR         | 70000  | 2    |
| Alice | HR         | 60000  | 3    |
| Grace | Engineering| 110000 | 1    |
| Eve   | Engineering| 100000 | 2    |
| Frank | Engineering| 90000  | 3    |
| Heidi | Engineering| 90000  | 3    |
| Liam  | Sales      | 90000  | 1    |
| Judy  | Sales      | 85000  | 2    |
| Ivan  | Sales      | 80000  | 3    |
| Kelly | Sales      | 80000  | 3    |

**Final Result (with `DENSE_RANK`)**:

| name  | department | salary |
| :---- | :--------- | :----- |
| Bob   | HR         | 75000  |
| David | HR         | 75000  |
| Carol | HR         | 70000  |
| Alice | HR         | 60000  |
| Grace | Engineering| 110000 |
| Eve   | Engineering| 100000 |
| Frank | Engineering| 90000  |
| Heidi | Engineering| 90000  |
| Liam  | Sales      | 90000  |
| Judy  | Sales      | 85000  |
| Ivan  | Sales      | 80000  |
| Kelly | Sales      | 80000  |

*In this case, `DENSE_RANK` behaved identically to `RANK` because the ties happened at rank 1 and rank 3, not at rank 2. The difference would be more apparent if we had a tie at rank 2 and then another employee at rank 3.*

**When to use `DENSE_RANK()`**: When you want a continuous sequence of ranks without gaps, and you still want all tied items to receive the same rank.

**2. Using `ROW_NUMBER()`**

```sql
WITH ranked_employees AS (
    SELECT
        name, department, salary,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn
    FROM employees
)
SELECT name, department, salary
FROM ranked_employees
WHERE rn <= 3;
```

**Result of `ranked_employees` CTE (with `ROW_NUMBER`)**:

| name  | department | salary | rn |
| :---- | :--------- | :----- | :-- |
| Bob   | HR         | 75000  | 1  |
| David | HR         | 75000  | 2  |  *Arbitrary order for tied salaries*
| Carol | HR         | 70000  | 3  |
| Alice | HR         | 60000  | 4  |
| Grace | Engineering| 110000 | 1  |
| Eve   | Engineering| 100000 | 2  |
| Frank | Engineering| 90000  | 3  |  *Arbitrary order for tied salaries*
| Heidi | Engineering| 90000  | 4  |
| Liam  | Sales      | 90000  | 1  |
| Judy  | Sales      | 85000  | 2  |
| Ivan  | Sales      | 80000  | 3  |  *Arbitrary order for tied salaries*
| Kelly | Sales      | 80000  | 4  |

**Final Result (with `ROW_NUMBER`)**:

| name  | department | salary |
| :---- | :--------- | :----- |
| Bob   | HR         | 75000  |
| David | HR         | 75000  |
| Carol | HR         | 70000  |
| Grace | Engineering| 110000 |
| Eve   | Engineering| 100000 |
| Frank | Engineering| 90000  |
| Liam  | Sales      | 90000  |
| Judy  | Sales      | 85000  |
| Ivan  | Sales      | 80000  |

*Notice how for HR, `Bob` and `David` both have 75000. `ROW_NUMBER()` arbitrarily assigned 1 to Bob and 2 to David. As a result, only `Bob`, `David`, and `Carol` are included for HR, and `Alice` is excluded. Similarly for Engineering and Sales, `ROW_NUMBER()` picked *one* of the tied employees at the cut-off point.*

**When to use `ROW_NUMBER()`**: When you need to select *exactly* N rows per group, and if there are ties at the Nth position, it's acceptable for the database to arbitrarily choose which of the tied rows to include. This is good for "pagination" or simply getting a fixed number of results per group. If tie-breaking needs to be deterministic, you might add another `ORDER BY` column (e.g., `ORDER BY salary DESC, name ASC`) to ensure consistent results.

---

### Key Takeaways and Best Practices:

*   **Understanding Window Functions**: This pattern fundamentally relies on understanding how `OVER (PARTITION BY ... ORDER BY ...)` works. It creates a "window" of rows for calculation.
*   **Tie-Breaking Logic**: The choice between `RANK()`, `DENSE_RANK()`, and `ROW_NUMBER()` is critical. Always consider how ties at the `N`-th position should be handled according to your business requirements.
*   **Performance**: Window functions are generally efficient. However, `PARTITION BY` can be costly if the partitioning column has a very high cardinality (many unique values) and no appropriate index. Indexing the `PARTITION BY` column and the `ORDER BY` column can significantly improve performance.
*   **Clarity with CTEs**: Using a CTE (Common Table Expression) like `ranked_employees` makes the query much more readable and easier to debug. It clearly separates the ranking logic from the final filtering logic.
*   **Flexibility**: This pattern is highly versatile. You can find:
    *   Highest/Lowest `N` by any metric.
    *   Using multiple `PARTITION BY` columns (e.g., "top 3 products by sales for each region *and* month").
    *   Using multiple `ORDER BY` columns for complex tie-breaking (e.g., `ORDER BY salary DESC, hire_date ASC` to break salary ties by earlier hire date).

This pattern is a cornerstone of analytical SQL, enabling powerful insights by segmenting data and ranking within those segments.
