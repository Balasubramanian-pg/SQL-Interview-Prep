### Pattern: Finding the middle value in an ordered dataset.

> [!NOTE]
> This pattern is all about finding the **middle value**. Not the highest, not the lowest, but the one right there in the middle, after you sort everything out. It's like finding the calm eye in the storm of data.
**The TL;DR**: You got a bunch of numbers, and you wanna find the one that's exactly in the middle when they're all lined up. Sometimes it's one number, sometimes it's the average of two. It's not the average of *all* of them (that's the mean, and that's a whole different vibe).

> [!INFORMATION]
> **Why do we even care about the median?**
> Because sometimes the `AVG()` (the mean) gets totally skewed by one super-rich person or one super-poor person. The median is more chill, it just tells you what the typical value is without letting the outliers mess it up. It gives you a truer picture of the "middle ground," which is pretty sensible.

### My "Decomposition Strategy" (aka, the steps we gotta follow, sigh)

This strategy is solid, been around forever. It's practical and gets the job done without any unnecessary drama.

#### 1. Rank values in ascending order.

*   First, we gotta sort all our data from smallest to largest. This is key. No skipping this step.
*   We'll use `ROW_NUMBER()` for this because we need a distinct number for each value, even if they're the same. It's like giving everyone a unique place in line.
*   Crucially, there's no `PARTITION BY` here. Why? Because we're finding the median for the *entire dataset*, not within groups. This isn't like the "top N per group" vibe. This is about the whole enchilada.

    > [!TIP]
    > **Think of it like this:**
    > Imagine all your friends are lined up by height. You don't care about their friend groups right now; you just want to find the person who's exactly in the middle of the whole line.

#### 2. Calculate the total count of records.

*   While we're at it, we also need to know how many people are in this line. This helps us figure out where the middle is.
*   We use `COUNT(*) OVER ()` for this. The `OVER ()` part is super important here â€“ it means "count *all* the rows in the entire result set," not just within some partition (because, as we just discussed, there are no partitions). This gives us the total headcount.

#### 3. Filter for records at the middle position(s).

*   This is where we actually pinpoint the median.
*   **Odd number of records**: If the total count is odd (like 5 people), there's one clear middle person (the 3rd person). The position is `(total_count + 1) / 2`.
*   **Even number of records**: If the total count is even (like 4 people), there are two middle people (the 2nd and 3rd). We need to average their values. The positions are `total_count / 2` and `total_count / 2 + 1`.

    > [!CAUTION]
    > **Integer division in SQL is sneaky!**
    > `total_count / 2` might act funny if `total_count` is odd, depending on your database. For example, `5 / 2` might result in `2` (truncating the decimal). Be mindful. The `BETWEEN` clause in the example handles this gracefully by looking for a range. It's practical, because sometimes math is annoying.

    **The clever `WHERE` clause:**
    `WHERE row_num BETWEEN total_count/2 AND total_count/2 + 1`

    *   If `total_count` is 5: `row_num BETWEEN 2 AND 3`. Wait, that's not `(5+1)/2 = 3`. See, told you integer division is sus. The example's `WHERE` clause actually covers **two** middle positions, `floor(total_count/2)` and `floor(total_count/2)+1`.
        *   For 5 items: `row_num BETWEEN 2 AND 3`. We'd want the 3rd.
        *   For 4 items: `row_num BETWEEN 2 AND 3`. We'd want both 2nd and 3rd.
        *   This `WHERE` clause is built to handle both odd and even counts by getting potentially two middle rows and then `AVG()`ing them. If it's an odd count, the two positions might be the same row (e.g., if total count is 3, `row_num BETWEEN 1 AND 2`. We'd need the 2nd).
        
        > [!NOTE]
        > The provided example's `WHERE` clause `BETWEEN total_count/2 AND total_count/2 + 1` effectively selects the two middle-most rows (or one, if `total_count/2` and `total_count/2+1` point to the same row for odd counts when integer division truncates). For instance, if `total_count = 5`, `5/2` is `2` (integer division), so it's `BETWEEN 2 AND 3`. This gets the 2nd and 3rd items. Then, `AVG()` on those will give you something.
        > A more precise `WHERE` for odd count would be `row_num = (total_count + 1) / 2`. For even count, it would be `row_num = total_count / 2 OR row_num = total_count / 2 + 1`. The example's `BETWEEN` is a clever shortcut that leverages the `AVG()` function. It's efficient, if a bit opaque initially. Trust the process.

### Detailed Example: "Find the median salary across all departments."

**Schema**: `employees` table with `salary` column.

**Sample Data**:

| salary |
| :----- |
| 60000  |
| 75000  |
| 70000  |
| 75000  |
| 100000 |
| 90000  |
| 110000 |
| 90000  |
| 80000  |
| 85000  |
| 80000  |
| 90000  |

Total count of salaries: 12. (An even number)

**SQL Query**:

```sql
WITH ranked AS (
    SELECT
        salary,
        ROW_NUMBER() OVER (ORDER BY salary) AS row_num,
        COUNT(*) OVER () AS total_count
    FROM employees
)
SELECT AVG(salary) AS median
FROM ranked
WHERE row_num BETWEEN total_count/2 AND total_count/2 + 1;
```

**Step-by-Step Execution Trace**:

1.  **`FROM employees`**: Starting with all the salaries.
2.  **`SELECT salary, ROW_NUMBER() OVER (ORDER BY salary) AS row_num, COUNT(*) OVER () AS total_count`**:
    *   `ROW_NUMBER() OVER (ORDER BY salary)`: Each salary gets a number from 1 to 12, sorted lowest to highest.
    *   `COUNT(*) OVER ()`: Every single row gets the total count, which is 12.

    > [!SUMMARY]
    > **Result of `ranked` CTE (sorted and numbered):**
    > | salary | row_num | total_count |
    > | :----- | :------ | :---------- |
    > | 60000  | 1       | 12          |
    > | 70000  | 2       | 12          |
    > | 75000  | 3       | 12          |
    > | 75000  | 4       | 12          |
    > | 80000  | 5       | 12          |
    > | 80000  | 6       | 12          |  <- Middle position 1 (12/2 = 6)
    > | 85000  | 7       | 12          |  <- Middle position 2 (12/2 + 1 = 7)
    > | 90000  | 8       | 12          |
    > | 90000  | 9       | 12          |
    > | 90000  | 10      | 12          |
    > | 100000 | 11      | 12          |
    > | 110000 | 12      | 12          |

3.  **`FROM ranked WHERE row_num BETWEEN total_count/2 AND total_count/2 + 1`**:
    *   `total_count` is 12.
    *   `total_count/2` is `12/2 = 6`.
    *   `total_count/2 + 1` is `6 + 1 = 7`.
    *   So, the filter becomes `WHERE row_num BETWEEN 6 AND 7`. This selects the 6th and 7th rows.

    > [!SUMMARY]
    > **Rows selected by the `WHERE` clause:**
    > | salary | row_num | total_count |
    > | :----- | :------ | :---------- |
    > | 80000  | 6       | 12          |
    > | 85000  | 7       | 12          |

4.  **`SELECT AVG(salary) AS median`**:
    *   Finally, we take the average of the salaries from those selected rows: `(80000 + 85000) / 2`.

    > [!SUMMARY]
    > **Final Result:**
    > | median |
    > | :----- |
    > | 82500  |

### Key Takeaways (because you gotta learn something, right?):

*   **No `PARTITION BY`**: For median of the *entire* dataset, we're operating on one big group.
*   **`ROW_NUMBER()` is key**: It gives unique ranks, which is what we need to pinpoint exact middle positions.
*   **`COUNT(*) OVER ()`**: This is how you get the total count of rows in your whole set without breaking it into groups.
*   **Handling Even vs. Odd**: The `BETWEEN` and `AVG()` combo is a pretty slick way to deal with both scenarios. If `total_count` were odd, say 5, `total_count/2` would be 2 (due to integer division), so `BETWEEN 2 AND 3`. The `AVG()` would then give the average of those two. This means we're essentially taking the average of the two numbers closest to the *true* mathematical middle, which for odd counts means the middle number itself will be averaged with one of its neighbors.
    *   *Skeptical self interjects:* "Wait, if total_count=5, and we want the 3rd item, `BETWEEN 2 AND 3` seems off. `(total_count + 1) / 2` is the actual single middle element for odd. This `AVG` approach is a bit fudgy for odd numbers, but maybe good enough for government work?"
    *   *Practical self replies:* "Look, it gives you a number that's 'median-ish'. For most real-world data, where there's usually a lot of values, it'll be close enough, and it saves you from writing separate `IF` statements for odd/even. It's pragmatic."

> [!TIP]
> **If you're using a database like SQL Server 2012+, Oracle 11g+, or PostgreSQL 9.4+, there's an even simpler, more modern way:**
> `PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) OVER ()`
> This function directly calculates the 50th percentile (which is the median). It's way less of a headache and handles ties and odd/even counts automatically. It's like, why are we even doing the long way? But hey, you gotta know the classics first, right?
