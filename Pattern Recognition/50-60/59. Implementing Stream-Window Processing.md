**Pattern**: Processing data in real-time streams or windows.

**Decomposition Strategy**:

1. Define time or count-based windows
2. Apply window-specific aggregations
3. Handle late-arriving data
4. Implement sliding or tumbling windows

**Example**: "Calculate 5-minute moving averages for sensor readings."

```SQL
-- Tumbling window approach (non-overlapping)
WITH time_windows AS (
    SELECT
        sensor_id,
        FLOOR(EXTRACT(EPOCH FROM reading_time) / 300) AS window_id,
        TO_TIMESTAMP(FLOOR(EXTRACT(EPOCH FROM reading_time) / 300) * 300) AS window_start,
        TO_TIMESTAMP((FLOOR(EXTRACT(EPOCH FROM reading_time) / 300) + 1) * 300) AS window_end,
        AVG(reading_value) AS avg_value,
        COUNT(*) AS reading_count,
        MIN(reading_value) AS min_value,
        MAX(reading_value) AS max_value
    FROM sensor_readings
    WHERE reading_time BETWEEN TIMESTAMP '2023-06-15 00:00:00' AND TIMESTAMP '2023-06-15 23:59:59'
    GROUP BY sensor_id, window_id
),

-- Sliding window approach (overlapping)
sliding_windows AS (
    SELECT
        sr1.sensor_id,
        sr1.reading_time,
        sr1.reading_value,
        AVG(sr2.reading_value) AS moving_avg,
        COUNT(sr2.reading_value) AS window_count
    FROM sensor_readings sr1
    JOIN sensor_readings sr2
        ON sr1.sensor_id = sr2.sensor_id
        AND sr2.reading_time BETWEEN sr1.reading_time - INTERVAL '5 minutes' AND sr1.reading_time
    WHERE sr1.reading_time BETWEEN TIMESTAMP '2023-06-15 00:00:00' AND TIMESTAMP '2023-06-15 23:59:59'
    GROUP BY sr1.sensor_id, sr1.reading_time, sr1.reading_value
)

-- Detect anomalies using rolling Z-score
SELECT
    sensor_id,
    reading_time,
    reading_value,
    moving_avg,
    (reading_value - moving_avg) /
        NULLIF(STDDEV(reading_value) OVER (
            PARTITION BY sensor_id
            ORDER BY reading_time
            ROWS BETWEEN 10 PRECEDING AND CURRENT ROW
        ), 0) AS z_score,
    CASE
        WHEN ABS((reading_value - moving_avg) /
            NULLIF(STDDEV(reading_value) OVER (
                PARTITION BY sensor_id
                ORDER BY reading_time
                ROWS BETWEEN 10 PRECEDING AND CURRENT ROW
            ), 0)) > 3 THEN true
        ELSE false
    END AS is_anomaly
FROM sliding_windows;
```
