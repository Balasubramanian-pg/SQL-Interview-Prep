# **Pattern**: Calculating statistics over a shifting time window.

**Decomposition Strategy**:

1. Define the window size (e.g., 7 days, 30 days)
2. Order data chronologically
3. Apply window functions with appropriate frame
4. Calculate desired statistics

**Example**: "Calculate 7-day rolling average, min, and max for daily sales."

```SQL
SELECT
    sale_date,
    daily_total,
    AVG(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS rolling_7day_avg,
    MIN(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS rolling_7day_min,
    MAX(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS rolling_7day_max
FROM daily_sales
ORDER BY sale_date;
```
Your strategy for calculating rolling window statistics is a fundamental and powerful application of **window functions** in SQL. It's an elegant pattern that efficiently aggregates data over a sliding frame without requiring self-joins or complex subqueries. The SQL example is a perfect illustration of this technique.

### Analysis of Assumptions

Your approach correctly assumes that the data is **orderable** and that the time intervals are consistent. The `ORDER BY sale_date` clause is critical; the database uses it to know how to define the "preceding" rows. The assumption is that `daily_sales` contains a record for every day, or if it doesn't, that a missing day doesn't break the logic, which it won't here, as the `ROWS BETWEEN` clause is based on row count, not time.

You also assume that **performance is a key consideration**. Window functions are highly optimized by database engines, often running with a single pass over the data, which is far more efficient than the old method of using correlated subqueries or self-joins.

### Counterpoints & Alternative Perspectives

A data scientist might argue that for time series analysis, **date-based windows** can be more semantically correct than **row-based windows**.

* **Row-based vs. Range-based Windows**: Your example uses `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`, which defines the window based on the number of rows. This is perfect if every row represents a consistent time interval (e.g., one day). However, if your data has gaps (e.g., no sales on a Sunday), a `ROWS` window would incorrectly include data from more than 7 actual days. A more robust approach, often necessary for time series, would use a **range-based window** like `RANGE BETWEEN INTERVAL '6 day' PRECEDING AND CURRENT ROW`. This ensures the window always covers a consistent 7-day period, regardless of data gaps.
* **Exclusion of the current row**: Your window frame `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW` includes the current row. For some use cases, such as forecasting, you might want to calculate a rolling average based **only on past data** to avoid data leakage. The window frame could be adjusted to `ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING` to exclude the current day's sales from the average. 
* **Handling Ties**: If there are two sales records on the same `sale_date`, the `ORDER BY` clause doesn't guarantee a stable order for them, which could lead to non-deterministic results. Adding a second, tie-breaking column to the `ORDER BY` clause (e.g., `ORDER BY sale_date, sale_id`) is good practice to ensure consistent results.

### Breaking Down the Code into Components

Your query, while concise, can be broken down into the four essential parts of a window function.

#### **1. The `OVER` Clause**

* This is the signal to the database that you want to perform a window function rather than a standard aggregation.
* It defines the "window" or set of rows that the function (`AVG`, `MIN`, etc.) will operate on.

#### **2. The `ORDER BY` Clause within the Window**

* The `ORDER BY sale_date` is the most critical part of this pattern. It defines how the window will "slide" through the data. For a rolling average, the chronological order is a must.

#### **3. The Window Frame (`ROWS BETWEEN ...`)**

* This clause specifies the **size and position** of the sliding window relative to the `CURRENT ROW`.
* `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW` means that for each row, the function should consider the current row and the 6 rows immediately before it, totaling a 7-row window.

#### **4. The Window Function (`AVG`, `MIN`, `MAX`)**

* The functions themselves (`AVG`, `MIN`, `MAX`) are standard aggregate functions, but when used with `OVER`, they operate on the defined window rather than the entire dataset.
* The query correctly calculates three different statistics within the same window definition, demonstrating the flexibility of this pattern. Each function runs over the same 7-day window, ensuring a consistent and comparable set of metrics.
