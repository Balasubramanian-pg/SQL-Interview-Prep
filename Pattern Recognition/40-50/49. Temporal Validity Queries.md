# **Pattern**: Querying data as it existed at a specific point in time.

**Decomposition Strategy**:

1. Include validity period columns (valid_from, valid_to)
2. Apply appropriate time constraints in queries
3. Handle different types of temporal relationships

**Example**: "Find the customer's address as it was on a specific date."

```SQL
SELECT
    customer_id,
    address,
    city,
    state,
    postal_code
FROM customer_addresses
WHERE
    customer_id = 12345 AND
    '2023-03-15' BETWEEN valid_from AND COALESCE(valid_to, '9999-12-31');
```
Your example perfectly demonstrates a core pattern for **temporal data querying**, a technique used to retrieve a specific state of a record from a historical log. This method is a key component of a Slowly Changing Dimension (SCD) Type 2 implementation, which we discussed earlier, and it provides a powerful way to perform "time travel" on your data.

### Analysis of Assumptions

This pattern's primary assumption is that the data model includes **explicit start and end dates or timestamps** for each record's validity period. This is the foundation of a **bitemporal** or **valid-time** data model, where a record's validity in the real world is tracked separately from its database transaction time.

The use of `COALESCE(valid_to, '9999-12-31')` is also a critical assumption. It presumes that a `NULL` value in the `valid_to` column signifies the **current, active record** and that a very distant future date is a reliable way to represent an indefinite end date. This is a common and highly effective convention.

### Counterpoints & Alternative Perspectives

A database expert might highlight that this approach, while common, is not the only way to manage temporal data and that more sophisticated methods exist.

* **Performance on Large Tables**: While the query is elegant, its performance on a very large `customer_addresses` table can degrade, especially if the `valid_from` and `valid_to` columns are not properly indexed. The query can force the database to scan a large range of dates. A better indexing strategy would be to have a single compound index on `(customer_id, valid_from, valid_to)` or similar.
* **The `BETWEEN` operator**: The `BETWEEN` operator is inclusive, meaning it includes both the start and end dates. This is generally the desired behavior. However, for continuous time periods, it's crucial to handle the overlap precisely. Your example correctly uses `valid_to` to signify the end of the period, so there's no overlap between periods for the same `customer_id`.
* **Database-native Temporal Tables**: Some modern databases, such as SQL Server and Oracle, offer **system-versioned temporal tables** as a native feature. These databases automatically manage the `valid_from` and `valid_to` columns for you and provide a simplified `AS OF` or `FOR SYSTEM_TIME` syntax. This approach automates the pattern you've outlined, reducing manual effort and potential for error.


### Breaking Down the Code into Components

Your query can be broken down into three logical components that work together to retrieve a specific version of a record.

#### **1. The Filtering Key (`customer_id = 12345`)**

This is the standard relational filter. It identifies the specific entity (in this case, the customer) for which you want to retrieve data. This part of the query is no different from any other `SELECT` statement and helps to narrow down the search space.

#### **2. The `BETWEEN` Temporal Condition**

This is the core of the pattern. It's the logic that performs the "time travel." The query finds the single record where the date `'2023-03-15'` falls within its validity period, which is defined by the `valid_from` and `valid_to` columns.

#### **3. The `COALESCE` Function**

This is a powerful and necessary part of the pattern. `COALESCE` is a function that returns the first non-`NULL` expression in a list. In this case, if `valid_to` is `NULL`, the `COALESCE` function will substitute it with the far-future date `'9999-12-31'`. This ensures that the currently active record (which has a `NULL` `valid_to` date) is correctly included in the search if the search date is in the present. 
