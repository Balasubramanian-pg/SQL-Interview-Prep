# **Pattern**: Identifying a specific ranked value.

**Decomposition Strategy**:

1. Order values in ascending/descending order
2. Apply ROW_NUMBER() or DENSE_RANK()
3. Filter for the specific rank

**Example**: "Find the 3rd highest salary in the company."

```SQL
-- Using ROW_NUMBER (excludes ties)
SELECT salary
FROM (
    SELECT
        salary,
        ROW_NUMBER() OVER (ORDER BY salary DESC) AS rnk
    FROM employees
) ranked
WHERE rnk = 3;

-- Using DENSE_RANK (includes ties)
SELECT salary
FROM (
    SELECT
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) AS rnk
    FROM employees
) ranked
WHERE rnk = 3;
```

Your approach to finding a specific ranked value using window functions is a canonical and highly efficient SQL pattern. It correctly leverages the power of `ROW_NUMBER()` and `DENSE_RANK()` to solve a common problem that would otherwise require complex and less performant subqueries or self-joins. Your examples are a perfect illustration of the key distinction between the two functions.

### Analysis of Assumptions

Your method assumes that a **clear ordering criterion** exists (`ORDER BY salary DESC`). Without a reliable way to sort the data, ranking is meaningless. This also assumes that a single column or a combination of columns can uniquely determine the order for all rows.

A key assumption is that **the distinction between ties is important**. Your examples correctly highlight this. `ROW_NUMBER()` assumes that each row gets a unique rank, even if their values are identical. `DENSE_RANK()` assumes that tied values should receive the same rank. The choice between the two depends entirely on the business question: should "the third highest salary" refer to the third distinct salary value or the salary of the third person on the list?

You're also assuming that **performance is a priority**. Window functions are highly optimized and are almost always the fastest way to perform this type of ranking. Older, less-performant methods using `LIMIT OFFSET` or correlated subqueries are much slower and less readable.

### Counterpoints & Alternative Perspectives

A database administrator might point out that while these functions are excellent, other ranking functions exist that could be more appropriate for different scenarios.

* **`RANK()` vs. `DENSE_RANK()`**: There is a third ranking function, `RANK()`, which is similar to `DENSE_RANK()` but leaves gaps in the ranking. For example, if two employees are tied for the 3rd highest salary, `DENSE_RANK()` will assign both a rank of 3, and the next rank will be 4. `RANK()` will assign both a rank of 3, but the next rank will be 5, skipping 4. This behavior can be useful in some contexts where you need to explicitly show that ranks were "skipped" due to ties.
* **The "Top-N" Problem**: While your example is about finding a specific ranked value, this pattern is often used for the "Top-N" problem (e.g., finding the top 10 highest-paid employees). The logic remains the same: `WHERE rnk <= 10`.
* **Handling Nulls**: The `ORDER BY` clause will place `NULL` values either at the top or bottom of the list depending on the database's default behavior or the explicit use of `NULLS FIRST` or `NULLS LAST`. This is a critical detail to consider when ranking to ensure `NULL` values don't skew your results.

### Breaking Down the Code into Components

Your example breaks down perfectly into three logical steps.

#### **1. The Subquery (`ranked`)**

* This is the essential first step. It is used to create a temporary, ordered result set that includes a new column containing the rank.
* This is a common pattern for window functions because you can't filter on a window function's result in the `WHERE` clause of the same query where it is calculated.

#### **2. The Window Function (`ROW_NUMBER()` or `DENSE_RANK()`)**

* The `OVER (ORDER BY salary DESC)` clause tells the function how to rank the data.
* `ROW_NUMBER()` assigns a unique, sequential integer to each row. `DENSE_RANK()` assigns a unique rank for each distinct value, with no gaps. The choice between them depends on whether you want to include or exclude ties. 

#### **3. The Outer Query Filter (`WHERE rnk = 3`)**

* This is the final step where you apply the specific ranking filter.
* By filtering on the calculated rank column, the query returns only the row(s) that meet the rank criteria you've defined (in this case, `rnk = 3`).
