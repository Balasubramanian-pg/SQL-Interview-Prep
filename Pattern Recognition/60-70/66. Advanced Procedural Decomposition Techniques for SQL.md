### Using Common Table Expressions (CTEs)

CTEs are, no cap, the GOAT for breaking down queries. They just make sense. It's like writing an outline before you write an essay.

*   **Break it down:** You can take a massive, complicated query and split it into smaller, named chunks. Each `WITH` block is its own mini-query.
*   **Readability is key:** Instead of one giant, nested mess, you give each step a clear name (`top_employees`, `monthly_sales_summary`). It's like labeling your file folders. Makes life so much easier when you come back to it later or when someone else has to read your code.
*   **Easy debugging:** If something's off, you can just `SELECT * FROM step1;` and see exactly what that part of your query is doing. No more guessing. It's practical.

> [!NOTE]
> CTEs are essentially temporary, named result sets that exist only for the duration of a single query. They don't actually get stored permanently, which is usually fine for most problems.

```sql
WITH initial_filtered_data AS (
    -- This is my first move: grab only the relevant rows, maybe some basic calculations.
    SELECT
        product_id,
        sale_date,
        quantity * price AS total_revenue
    FROM sales
    WHERE sale_date >= '2023-01-01' -- Filtering early, as we should.
),
monthly_product_summary AS (
    -- Next, let's roll up that data by month and product.
    SELECT
        product_id,
        EXTRACT(MONTH FROM sale_date) AS sale_month,
        SUM(total_revenue) AS monthly_revenue_total
    FROM initial_filtered_data -- See? Building on the previous step.
    GROUP BY product_id, sale_month
),
ranked_products_per_month AS (
    -- Now, find the top-selling product for each month.
    SELECT
        product_id,
        sale_month,
        monthly_revenue_total,
        ROW_NUMBER() OVER (PARTITION BY sale_month ORDER BY monthly_revenue_total DESC) AS rn
    FROM monthly_product_summary
)
-- Finally, just give me the actual top product for each month.
SELECT
    product_id,
    sale_month,
    monthly_revenue_total
FROM ranked_products_per_month
WHERE rn = 1; -- Just the number one spot.
```

### Using Subqueries

Subqueries are the OG way to break things down. They're like nesting dolls for your SQL.

*   **Isolate and solve:** You can write a query that solves a specific piece of the puzzle, and then use the result of that query in the outer query.
*   **Input to next part:** The output of an inner query becomes the input for the outer one. It creates a natural flow.
*   **Clear hierarchy:** It's pretty clear what's happening first (the innermost query) and what's happening last (the outermost query).

> [!CAUTION]
> Subqueries can get *really* nested, and that's when they start looking like a hot mess. If you've got more than two or three levels, it's probably time to switch to CTEs for readability. It's about maintaining clarity, not just cramming code into one line.

```sql
-- Example: Find employees whose salary is above the average of their department
SELECT
    e.name,
    e.department,
    e.salary
FROM employees e
WHERE e.salary > (
    -- This is the subquery: it figures out the average for 'this' department
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department = e.department -- Correlated subquery, tricky but effective
);

-- Another example: Find departments with more than 5 employees
SELECT
    d.department_name
FROM departments d
WHERE d.department_id IN (
    -- This subquery finds department IDs that meet the criteria
    SELECT e.department_id
    FROM employees e
    GROUP BY e.department_id
    HAVING COUNT(e.employee_id) > 5
);
```

### Using Temporary Tables

For problems that are super complex, or when you're dealing with massive datasets, temporary tables can be a lifesaver. They're actual (but temporary) tables, so the database can optimize them better.

*   **Store intermediate results:** You can literally save the result of a step into a table, give it a proper name, and then build on it.
*   **Multiple simple queries:** Instead of one monster query, you have a series of smaller, more manageable queries that create and use these temporary tables. Much easier to reason about.
*   **Performance boost (sometimes):** Because temporary tables are materialized (written to disk or memory), the database can put indexes on them or re-evaluate statistics, which can make subsequent steps much faster, especially with large datasets or complex joins.

> [!IMPORTANT]
> Remember to **clean up** your temporary tables if they're not automatically dropped by your database connection. Leaving them around can be messy. It's about being responsible and not leaving a digital trail.

```sql
-- Step 1: Filter raw data and store it.
CREATE TEMPORARY TABLE filtered_sales_data AS (
    SELECT
        sale_id,
        customer_id,
        product_id,
        sale_amount,
        sale_date
    FROM large_sales_log
    WHERE sale_date BETWEEN '2023-01-01' AND '2023-03-31'
);

-- Step 2: Aggregate the filtered data by customer.
CREATE TEMPORARY TABLE customer_quarterly_summary AS (
    SELECT
        customer_id,
        COUNT(sale_id) AS total_purchases,
        SUM(sale_amount) AS total_spent
    FROM filtered_sales_data
    GROUP BY customer_id
    HAVING SUM(sale_amount) > 1000 -- Only interested in high spenders
);

-- Final query: Get details of the top 5 high-spending customers.
SELECT
    c.customer_id,
    c.total_purchases,
    c.total_spent,
    cu.customer_name -- Assuming a 'customers' table exists for names
FROM customer_quarterly_summary c
JOIN customers cu ON c.customer_id = cu.customer_id
ORDER BY c.total_spent DESC
LIMIT 5;

-- Don't forget to clean up if needed!
-- DROP TEMPORARY TABLE IF EXISTS filtered_sales_data;
-- DROP TEMPORARY TABLE IF EXISTS customer_quarterly_summary;
```
