## Question: Given tables `employees`, `departments`, and `salaries`, find the department with the highest average salary for employees who have been with the company for at least 5 years.

> [!NOTE]
> This is a classic "multi-step aggregation and ranking" problem. It's not just one thing; it's a sequence of operations. It's why we need decomposition.

### Procedural Decomposition: (The sensible way to think about it)

#### 1. Understand the Problem:

*   **Output**: I need *one* department name. Not a list, just the single champion.
*   **Core Metric**: Average salary. Not total, not max, specifically average.
*   **Key Filter**: Employees gotta be old-school. `hire_date` means they've been here 5+ years.
*   **Final Goal**: Find the *highest* of those calculated averages.

> [!IMPORTANT]
> Always start here. If you don't actually understand what they're asking, you're just going to write nonsense. Take your time. It's practical.

#### 2. Identify Components:

*   **Tables Involved**: `employees` (for `employee_id`, `department_id`, `hire_date`), `departments` (for `department_name`), `salaries` (for `salary`).
*   **How They Link**: `employees` links to `departments` on `department_id`. `employees` links to `salaries` on `employee_id`. Standard stuff.
*   **Specific Filters/Conditions**: `DATEDIFF(YEAR, hire_date, CURRENT_DATE) >= 5` (or whatever date math your specific SQL dialect uses).
*   **The Math**: `AVG(s.salary)` and `GROUP BY d.department_name`.
*   **The Ranking**: `ORDER BY avg_salary DESC LIMIT 1`.

#### 3. Plan the Approach:

This is like sketching it out before you start building. It prevents you from just throwing code at the wall.

*   **Step 1: Filter Employees by Tenure.** Start with the `employees` table, filter by that 5-year mark. We only care about the OGs.
*   **Step 2: Connect the Dots & Get Salaries.** Take those long-term employees, join them to their `departments` so we can get the name, and join them to `salaries` to get their actual pay.
*   **Step 3: Calculate Average Salary per Department.** Group all that connected data by `department_name` and then calculate the average salary for each department.
*   **Step 4: Find the Top Department.** From those departmental averages, just pick the one with the absolute highest average.

> [!TIP]
> Use CTEs for this! Each step in your plan can become its own named `WITH` block. It keeps things super clean and easy to follow.

#### 4. Build the Solution: (Code time!)

```sql
-- First, identify employees with 5+ years tenure
-- This is like filtering out the rookies. We only want the veterans.
WITH long_term_employees AS (
    SELECT
        e.employee_id,
        e.department_id,
        e.hire_date -- Including hire_date for the filter.
    FROM
        employees e
    WHERE
        -- DATEDIFF is common. Make sure to use the right function for your specific SQL dialect.
        -- Some might use AGE(CURRENT_DATE, hire_date) or custom date functions.
        -- This ensures only employees with at least 5 full years are considered.
        DATEDIFF(YEAR, e.hire_date, CURRENT_DATE) >= 5
),

-- Next, calculate average salary by department for *those specific* long-term employees.
-- We're joining back to get department names and actual salaries for our OGs.
dept_avg_salaries AS (
    SELECT
        d.department_name,
        AVG(s.salary) AS avg_salary -- The actual average we care about.
    FROM
        long_term_employees lte -- Starting with our filtered group.
    JOIN
        departments d ON lte.department_id = d.department_id -- Get the department name.
    JOIN
        salaries s ON lte.employee_id = s.employee_id -- Get their actual salary.
    GROUP BY
        d.department_name -- Crucial: calculate average *per department*.
)

-- Finally, get the department with the single highest average.
-- This just picks the champion from our list of departmental averages.
SELECT
    department_name,
    avg_salary
FROM
    dept_avg_salaries
ORDER BY
    avg_salary DESC -- Highest average first.
LIMIT 1; -- Just the very top one. If there's a tie, this picks one arbitrarily.
```

#### 5. Test and Refine:

This is where you act like you're smarter than the database. What could go wrong?

*   **Edge Cases**:
    *   **No long-term employees?** The `long_term_employees` CTE would be empty. `dept_avg_salaries` would be empty. The final query would return no rows. Is that acceptable? Usually, yes.
    *   **Department with no long-term employees?** That department won't appear in `dept_avg_salaries` at all, which is correct.
    *   **Ties for highest average?** `LIMIT 1` will pick one. If the requirement was "return all tied departments," I'd need to use a `RANK()` window function in `dept_avg_salaries` and then filter for `rank = 1`. This is a common pitfall.
    *   **NULL `hire_date`?** `DATEDIFF` might break. Add `WHERE hire_date IS NOT NULL` if that's a possibility.
*   **Optimization**:
    *   **Indexing Awareness**: The columns used in `JOIN` conditions (`employee_id`, `department_id`) and `WHERE` clauses (`hire_date`) should definitely be indexed. Otherwise, this could be slow on a massive `employees` table.
    *   **CTE Efficiency**: For this problem, CTEs are generally efficient and improve readability massively. The database optimizer is usually smart enough to handle them well. Materializing temporary tables (like `CREATE TEMPORARY TABLE`) might be an alternative for *extremely* large intermediate results if the optimizer struggles, but usually, CTEs are fine.
*   **Alternatives (just to show off, or if performance is an issue):**
    *   **Window Functions for Ranking**: Instead of `ORDER BY ... LIMIT 1`, you could add `RANK() OVER (ORDER BY avg_salary DESC) AS rk` to `dept_avg_salaries` and then filter `WHERE rk = 1`. This would handle ties gracefully if needed.
    *   **Subquery (less readable)**: You could cram `dept_avg_salaries` into a subquery in the `FROM` clause of the final `SELECT`, but it gets messy. CTEs are cleaner.

> [!IMPORTANT]
> The act of explaining your thought process, considering alternatives, and thinking about edge cases and performance is as important as the correct SQL code itself in an interview. It shows you're not just a coder, but a problem-solver.
