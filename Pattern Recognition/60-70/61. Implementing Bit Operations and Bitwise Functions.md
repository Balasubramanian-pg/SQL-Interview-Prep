## Pattern: Using binary operations for efficient data processing.

**The Gist**: You represent a bunch of yes/no flags or options as a single number using binary bits. Then you use special "bitwise" operators to check, add, or remove those flags without messing up the others.

> [!NOTE]
> This pattern is highly efficient for storing multiple boolean (yes/no) flags in a single integer column, saving space and potentially improving query performance for certain types of checks. It's a compact way to encode features or states.

### Decomposition Strategy: (Making numbers do more work)

#### 1. Define bit field meanings.

*   First, you gotta decide what each specific bit in your number represents. This is crucial.
    *   Bit 0 (value 1): "Read" permission
    *   Bit 1 (value 2): "Write" permission
    *   Bit 2 (value 4): "Update" permission
    *   Bit 3 (value 8): "Delete" permission
    *   And so on, doubling the value for each new bit (1, 2, 4, 8, 16, 32...).

> [!IMPORTANT]
> Document these meanings clearly! If you don't, anyone (including your future self) trying to read or modify this code will be totally lost. This isn't obvious; it's a convention you create.

#### 2. Apply bitwise operators (AND, OR, XOR, NOT).

*   These are your tools for interacting with the bits:
    *   **`&` (Bitwise AND)**: Checks if a bit is *set*. If `(my_number & bit_value) > 0`, then the bit is on.
    *   **`|` (Bitwise OR)**: *Adds* a bit (turns it on) to an existing number. `my_number | bit_value`.
    *   **`~` (Bitwise NOT)**: Inverts all bits (makes 0s into 1s and 1s into 0s). Useful with `&` to *remove* a bit.
    *   **`^` (Bitwise XOR)**: Flips a bit if it's different. Useful for toggling a bit on/off.

#### 3. Extract specific bits through shifting and masking.

*   You use `&` (masking) to isolate specific bits or combinations.
*   Sometimes you might use bit shifting (`<<`, `>>`) to move bits around, but `&` and `|` are the heavy lifters for basic flag management.

#### 4. Use for compact feature encoding/decoding.

*   The whole point is to store a lot of yes/no flags in one small integer column (`permission_bits`).
*   Then, your queries decode those bits to check specific permissions or features.

### Example: "Query user permissions using bitmasks."

**What we've got**: A `users` table with `user_id`, `user_name`, and `permission_bits` (an integer column).

**Sample Data (Imagine `permission_bits` is an integer, like 7 or 15):**

| user_id | user_name | permission_bits | (Binary representation, conceptually) |
| :------ | :-------- | :-------------- | :------------------------------------ |
| 1       | Alice     | 7               | 0111 (Read, Write, Update)            |
| 2       | Bob       | 3               | 0011 (Read, Write)                    |
| 3       | Charlie   | 15              | 1111 (Read, Write, Update, Delete)    |
| 4       | David     | 1               | 0001 (Read)                           |

**The SQL (Checking, granting, revoking permissions):**

```sql
-- Define permission bits: (Crucial for understanding the code!)
-- 1 (0001): Read
-- 2 (0010): Write
-- 4 (0100): Update
-- 8 (1000): Delete

-- Step 2 & 3: Check if user has specific permissions
SELECT
    user_id,
    user_name,
    permission_bits,
    -- Check if Read bit (1) is set: (permission_bits AND 1) will be 1 if Read is set, 0 otherwise.
    permission_bits & 1 > 0 AS has_read,
    -- Check if Write bit (2) is set:
    permission_bits & 2 > 0 AS has_write,
    -- Check if Update bit (4) is set:
    permission_bits & 4 > 0 AS has_update,
    -- Check if Delete bit (8) is set:
    permission_bits & 8 > 0 AS has_delete,
    -- Check for a specific permission *combination* (Read + Write = 1 + 2 = 3).
    -- (permission_bits & 3) isolates the Read and Write bits.
    -- If those isolated bits exactly match 3, then both Read and Write are present.
    (permission_bits & 3) = 3 AS has_read_write,
    -- Check for users with all defined permissions (1+2+4+8 = 15).
    permission_bits = 15 AS has_all_permissions
FROM users;
```

**Execution Trace for Alice (permission_bits = 7, binary 0111):**

*   `has_read`: `7 & 1` is `1` (0111 & 0001 = 0001), `1 > 0` is `TRUE`.
*   `has_write`: `7 & 2` is `2` (0111 & 0010 = 0010), `2 > 0` is `TRUE`.
*   `has_update`: `7 & 4` is `4` (0111 & 0100 = 0100), `4 > 0` is `TRUE`.
*   `has_delete`: `7 & 8` is `0` (0111 & 1000 = 0000), `0 > 0` is `FALSE`.
*   `has_read_write`: `(7 & 3)` is `3` (0111 & 0011 = 0011). `3 = 3` is `TRUE`.
*   `has_all_permissions`: `7 = 15` is `FALSE`.

#### Granting and Revoking Permissions (Updating the bitmask)

```sql
-- Step 2: Grant a permission (add Write permission, which is 2, to existing permissions).
-- Bitwise OR (|) will turn on the bit for '2' without affecting other bits.
-- Example: If permission_bits was 1 (0001), after this it becomes 1 | 2 = 3 (0011).
UPDATE users
SET permission_bits = permission_bits | 2
WHERE user_id = 12345;

-- Step 2: Revoke a permission (remove Delete permission, which is 8, from existing permissions).
-- Bitwise NOT (~) on 8 gives a mask where only the 8th bit is 0, and all others are 1.
-- Bitwise AND (&) with this mask will turn off the 8th bit while leaving others as they were.
-- Example: If permission_bits was 15 (1111), after this it becomes 15 & ~8 = 7 (0111).
UPDATE users
SET permission_bits = permission_bits & ~8
WHERE user_id = 12345;
```

> [!CAUTION]
> **Lack of Readability and Maintainability:** While space-efficient, bitmasks can make code hard to read and understand if the bit meanings aren't perfectly documented. It's not immediately obvious what `permission_bits & 4` means without looking up the definition. For simple cases, it's fine, but for many flags, separate boolean columns might actually be clearer.

> [!TIP]
> **Use Named Constants:** In application code, use named constants (e.g., `PERMISSION_READ = 1`, `PERMISSION_WRITE = 2`) instead of raw numbers `1`, `2`, `4`, `8` to make your SQL and application logic much more readable. The database doesn't care, but your brain will thank you.

> [!IMPORTANT]
> Bitwise operations are specific to the integer data type. They won't work on strings or other types. Also, the maximum number of distinct flags you can store depends on the size of your integer type (e.g., a `BIGINT` can hold up to 63 flags).
